final_schedule = [n_patients]
elif t_intervals == 0 and n_patients == 0:
final_schedule = []
else:
# Skip invalid combinations for T < 2.
continue
else:
# Generate the center part of the schedule.
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients, num_center_intervals
)
# Combine start, center, and tail to form the full schedule.
final_schedule = [start_count] + center_schedule_segment + [tail_count]
# Sanity check: ensure the total patients in the schedule match.
if sum(final_schedule) != n_patients:
continue
schedules.append(final_schedule)
# Calculate the objective value for this schedule.
ewt, esp = calculate_objective_serv_time_lookup(
final_schedule, INTERVAL_DURATION, convolutions_dict
)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Plotting Parameters for Figure 1 Grid ---
Q_VALUES = [0.1, 0.15, 0.2]
W_VALUES = [0.1, 0.5, 0.9]
#| code-fold: true
# --- Create 3x3 Subplot Grid for Figure 1 ---
# Create subplots with 3D scenes.
fig = make_subplots(
rows=3, cols=3,
specs=[[{'type': 'scatter3d'} for _ in range(3)] for _ in range(3)],
# Titles will be updated later with objective value info.
subplot_titles=[f'q={q:.2f}, w={w:.1f}' for w in W_VALUES for q in Q_VALUES],
horizontal_spacing=0.02,
vertical_spacing=0.12
)
# --- First Pass: Compute all data and find global Z-axis range ---
# This ensures a consistent color scale across all subplots.
all_data = {}
global_z_min = float('inf')
global_z_max = float('-inf')
for i, w_weight in enumerate(W_VALUES):
for j, q_no_show in enumerate(Q_VALUES):
schedules, objectives = compute_schedules_and_objectives(
q_no_show, w_weight, N_PATIENTS_FIG1, T_INTERVALS
)
all_data[(i, j)] = (schedules, objectives)
if objectives:
global_z_min = min(global_z_min, min(objectives))
global_z_max = max(global_z_max, max(objectives))
# Handle case where no data was generated.
if global_z_min == float('inf'): global_z_min = 0
if global_z_max == float('-inf'): global_z_max = 1
# --- Second Pass: Populate the subplots with data ---
subplot_titles_with_min_info = []
for i, w_weight in enumerate(W_VALUES):
for j, q_no_show in enumerate(Q_VALUES):
schedules, objective_values = all_data[(i, j)]
base_title = f'q={q_no_show:.2f}, w={w_weight:.1f}'
if not schedules or not objective_values:
subplot_titles_with_min_info.append(f'{base_title}<br><sub>No data</sub>')
fig.add_trace(go.Scatter3d(x=[], y=[], z=[]), row=i + 1, col=j + 1)
continue
# Extract coordinates for the 3D plot.
x_coords = [s[0] for s in schedules]  # Start count
y_coords = [s[-1] if s else 0 for s in schedules]  # Tail count
z_values = objective_values # Objective value
# Find the minimum point to highlight it.
min_obj_val = min(z_values)
min_index = z_values.index(min_obj_val)
subplot_titles_with_min_info.append(f'{base_title}<br><sub>Min: {min_obj_val:.4f}</sub>')
# Prepare detailed hover text for each point.
wrapped_schedules = [textwrap.wrap(str(s), width=75) for s in schedules]
hover_texts = [
f"Schedule: {'<br>'.join(ws)}<br>"
f"Patients: {sum(s)}<br>"
f"Objective: {ov:.4f}"
for s, ws, ov in zip(schedules, wrapped_schedules, z_values)
]
# Add trace for all points except the minimum.
fig.add_trace(go.Scatter3d(
x=[x_coords[k] for k in range(len(schedules)) if k != min_index],
y=[y_coords[k] for k in range(len(schedules)) if k != min_index],
z=[z_values[k] for k in range(len(schedules)) if k != min_index],
mode='markers',
marker=dict(
size=4,
color=z_values,
colorscale='Viridis',
opacity=0.7,
cmin=global_z_min,
cmax=global_z_max,
# Show color bar only on the top-right plot.
colorbar=dict(title='Objective') if i == 0 and j == 2 else None,
showscale=(i == 0 and j == 2)
),
hovertemplate='%{hovertext}<extra></extra>',
hovertext=hover_texts,
showlegend=False
), row=i + 1, col=j + 1)
# Add a highlighted trace for the minimum point.
fig.add_trace(go.Scatter3d(
x=[x_coords[min_index]],
y=[y_coords[min_index]],
z=[z_values[min_index]],
mode='markers',
marker=dict(size=6, color='red', opacity=1.0),
name='Minimum',
hovertemplate='%{hovertext}<extra></extra>',
hovertext=[hover_texts[min_index]],
showlegend=False
), row=i + 1, col=j + 1)
# Update subplot titles with the minimum objective value.
for idx, title_text in enumerate(subplot_titles_with_min_info):
if idx < len(fig.layout.annotations):
fig.layout.annotations[idx].text = title_text
# --- Finalize Figure Layout ---
fig.update_layout(
title=dict(
text=f'<b>Figure 1:</b> 3D Analysis of Schedule Optimization (N={N_PATIENTS_FIG1})<br>'
'<sub>Rows: w (EWT weight), Columns: q (no-show probability)</sub>',
x=0.5, y=0.98, font_size=16
),
height=1200, width=1400,
margin=dict(t=100, b=100, l=50, r=50),
font_size=10
)
# Update 3D scene properties for all subplots.
for row_idx in range(1, 4):
for col_idx in range(1, 4):
scene_num = (row_idx - 1) * 3 + col_idx
scene_name = f'scene{scene_num}' if scene_num > 1 else 'scene'
fig.update_layout(**{
scene_name: dict(
xaxis_title='Start Count',
yaxis_title='Tail Count',
zaxis_title='Objective Value',
camera=dict(eye=dict(x=-1.5, y=-1.5, z=1.5)),
xaxis=dict(range=[0, None]),
yaxis=dict(range=[0, None])
)
})
fig.show()
#| code-fold: true
# --- Parameters and Setup for Figure 2 ---
N_PATIENTS_FIG2 = 40  # Use a different number of patients for this figure.
# Other parameters (T_INTERVALS, INTERVAL_DURATION, etc.) are reused from the previous setup.
if service_time_dist is None:
raise ValueError("Service time distribution is not available for Figure 2.")
Q_VALUES_FIG2 = [0.1, 0.2]
W_VALUES_FIG2 = [0.1, 0.9]
# --- Create 2x2 subplot grid for Figure 2 ---
fig2 = make_subplots(
rows=len(W_VALUES_FIG2), cols=len(Q_VALUES_FIG2),
specs=[[{'type': 'scatter3d'} for _ in Q_VALUES_FIG2] for _ in W_VALUES_FIG2],
subplot_titles=[f'q={q:.2f}, w={w:.1f}' for w in W_VALUES_FIG2 for q in Q_VALUES_FIG2],
horizontal_spacing=0.02,
vertical_spacing=0.12
)
# --- First Pass: Compute all data and find global Z-axis range for Figure 2 ---
global_z_min_fig2 = float('inf')
global_z_max_fig2 = float('-inf')
all_data_fig2 = {}
for i, w_weight in enumerate(W_VALUES_FIG2):
for j, q_no_show in enumerate(Q_VALUES_FIG2):
schedules, objectives = compute_schedules_and_objectives(
q_no_show, w_weight, N_PATIENTS_FIG2, T_INTERVALS
)
all_data_fig2[(i, j)] = (schedules, objectives)
if objectives:
global_z_min_fig2 = min(global_z_min_fig2, min(objectives))
global_z_max_fig2 = max(global_z_max_fig2, max(objectives))
if global_z_min_fig2 == float('inf'): global_z_min_fig2 = 0
if global_z_max_fig2 == float('-inf'): global_z_max_fig2 = 1
# --- Second Pass: Populate the subplots for Figure 2 ---
subplot_titles_with_min_fig2 = []
for i, w_weight in enumerate(W_VALUES_FIG2):
for j, q_no_show in enumerate(Q_VALUES_FIG2):
schedules, objective_values = all_data_fig2[(i, j)]
base_title = f'q={q_no_show:.2f}, w={w_weight:.1f}'
if not schedules or not objective_values:
subplot_titles_with_min_fig2.append(f'{base_title}<br><sub>No data</sub>')
fig2.add_trace(go.Scatter3d(x=[], y=[], z=[]), row=i + 1, col=j + 1)
continue
x_coords = [s[0] for s in schedules]
y_coords = [s[-1] if s else 0 for s in schedules]
z_values = objective_values
min_obj_val = min(z_values)
min_index = z_values.index(min_obj_val)
subplot_titles_with_min_fig2.append(f'{base_title}<br><sub>Min: {min_obj_val:.4f}</sub>')
wrapped_schedules = [textwrap.wrap(str(s), width=75) for s in schedules]
hover_texts = [
f"Schedule: {'<br>'.join(ws)}<br>"
f"Patients: {sum(s)}<br>"
f"Objective: {ov:.4f}"
for s, ws, ov in zip(schedules, wrapped_schedules, z_values)
]
fig2.add_trace(go.Scatter3d(
x=[x_coords[k] for k in range(len(schedules)) if k != min_index],
y=[y_coords[k] for k in range(len(schedules)) if k != min_index],
z=[z_values[k] for k in range(len(schedules)) if k != min_index],
mode='markers',
marker=dict(
size=4, color=z_values, colorscale='Viridis', opacity=0.7,
cmin=global_z_min_fig2, cmax=global_z_max_fig2,
colorbar=dict(title='Objective') if i == 0 and j == 1 else None,
showscale=(i == 0 and j == 1)
),
hovertemplate='%{hovertext}<extra></extra>', hovertext=hover_texts, showlegend=False
), row=i + 1, col=j + 1)
fig2.add_trace(go.Scatter3d(
x=[x_coords[min_index]], y=[y_coords[min_index]], z=[z_values[min_index]],
mode='markers', marker=dict(size=6, color='red', opacity=1.0),
name='Minimum', hovertemplate='%{hovertext}<extra></extra>',
hovertext=[hover_texts[min_index]], showlegend=False
), row=i + 1, col=j + 1)
# --- Finalize Figure 2 Layout ---
for idx, title_text in enumerate(subplot_titles_with_min_fig2):
if idx < len(fig2.layout.annotations):
fig2.layout.annotations[idx].text = title_text
fig2.update_layout(
title=dict(
text=f'<b>Figure 2:</b> Schedule Optimization (N={N_PATIENTS_FIG2})<br>'
'<sub>Rows: w (weight), Columns: q (no-show probability)</sub>',
x=0.5, y=0.98, font_size=16
),
height=1000, width=1200,
margin=dict(t=100, b=100, l=50, r=50), font_size=10
)
for r_idx in range(len(W_VALUES_FIG2)):
for c_idx in range(len(Q_VALUES_FIG2)):
scene_idx = r_idx * len(Q_VALUES_FIG2) + c_idx + 1
scene_name = f'scene{scene_idx}' if scene_idx > 1 else 'scene'
fig2.update_layout(**{
scene_name: dict(
xaxis_title='Start Count', yaxis_title='Tail Count', zaxis_title='Objective Value',
camera=dict(eye=dict(x=-1.5, y=-1.5, z=1.5)),
xaxis=dict(range=[0, None]), yaxis=dict(range=[0, None])
)
})
fig2.show()
#| code-fold: true
#| label: fig-single-case-N40-q01-w05-projection
#| fig-cap: "3D chart for N=40, q=0.1, w=0.5, with projection on start_count + tail_count = 32. X-axis: Start Count, Y-axis: Tail Count, Z-axis: Objective Value."
# --- Parameters for Single Case Analysis (Figure 3) ---
N_PATIENTS_SINGLE_CASE = 40
Q_SINGLE_CASE = 0.1
W_SINGLE_CASE = 0.5
# T_INTERVALS and INTERVAL_DURATION are reused from the global scope.
# --- Compute Data for the Single Case ---
schedules_single, objective_values_single = compute_schedules_and_objectives(
Q_SINGLE_CASE,
W_SINGLE_CASE,
N_PATIENTS_SINGLE_CASE,
T_INTERVALS
)
# --- Create the 3D Scatter Plot ---
fig_single = go.Figure()
if not schedules_single or not objective_values_single:
# Display a message if no data could be generated.
fig_single.add_annotation(
text="No data to plot for these parameters.", xref="paper", yref="paper",
x=0.5, y=0.5, showarrow=False, font=dict(size=16)
)
fig_single.update_layout(
title=f'3D Analysis - N={N_PATIENTS_SINGLE_CASE}, q={Q_SINGLE_CASE:.2f}, w={W_SINGLE_CASE:.1f} - No Data',
height=500, width=700
)
else:
x_coords = [s[0] for s in schedules_single]
y_coords = [s[-1] if s else 0 for s in schedules_single]
z_values = objective_values_single
min_obj_val = min(z_values)
min_index = z_values.index(min_obj_val)
# Prepare hover text.
wrapped_schedules = [textwrap.wrap(str(s), width=75) for s in schedules_single]
hover_texts = [
f"Schedule: {'<br>'.join(ws)}<br>Patients: {sum(s)}<br>"
f"Objective: {ov:.4f}<br>Start: {s[0]}, Tail: {s[-1] if s else 0}"
for s, ws, ov in zip(schedules_single, wrapped_schedules, z_values)
]
# --- Add Projection Plane: start_count + tail_count = 40 ---
plane_target_sum = 32
plane_z_min, plane_z_max = np.min(z_values), np.max(z_values)
plane_margin = (plane_z_max - plane_z_min) * 0.05 if plane_z_max > plane_z_min else 0.5
fig_single.add_trace(go.Mesh3d(
x=[0, plane_target_sum, plane_target_sum, 0],
y=[plane_target_sum, 0, 0, plane_target_sum],
z=[plane_z_min - plane_margin, plane_z_min - plane_margin, plane_z_max + plane_margin, plane_z_max + plane_margin],
i=[0, 0], j=[1, 2], k=[2, 3], # Define two triangles for the plane
opacity=0.15, color='gray', name=f'Plane S+T={plane_target_sum}'
))
# --- Add Scatter Points (excluding minimum) ---
fig_single.add_trace(go.Scatter3d(
x=[x_coords[i] for i in range(len(x_coords)) if i != min_index],
y=[y_coords[i] for i in range(len(y_coords)) if i != min_index],
z=[z_values[i] for i in range(len(z_values)) if i != min_index],
mode='markers',
marker=dict(size=4, color=z_values, colorscale='Viridis', opacity=0.7, colorbar=dict(title='Objective')),
hovertemplate='%{hovertext}<extra></extra>',
hovertext=hover_texts, name='Data points'
))
# --- Add Minimum Point ---
fig_single.add_trace(go.Scatter3d(
x=[x_coords[min_index]], y=[y_coords[min_index]], z=[z_values[min_index]],
mode='markers', marker=dict(size=6, color='red', opacity=1.0),
hovertemplate='%{hovertext}<extra></extra>',
hovertext=[hover_texts[min_index]], name=f'Minimum (Obj: {min_obj_val:.4f})'
))
# --- Add Projection Points (where start + tail = 40) ---
proj_indices = [i for i, s in enumerate(schedules_single) if s and (s[0] + s[-1] == plane_target_sum)]
if proj_indices:
fig_single.add_trace(go.Scatter3d(
x=[x_coords[i] for i in proj_indices],
y=[y_coords[i] for i in proj_indices],
z=[z_values[i] for i in proj_indices],
mode='markers',
marker=dict(size=5, color='cyan', opacity=0.9, symbol='diamond'),
hovertemplate='%{hovertext}<extra></extra>',
hovertext=[hover_texts[i] for i in proj_indices],
name=f'On Plane S+T={plane_target_sum}'
))
# --- Finalize Layout for Single Case Figure ---
fig_single.update_layout(
title=dict(
text=f'3D Schedule Analysis: N={N_PATIENTS_SINGLE_CASE}, q={Q_SINGLE_CASE:.2f}, w={W_SINGLE_CASE:.1f}<br><sub>Optimal Objective: {min_obj_val:.4f}</sub>',
x=0.5, font_size=16
),
scene=dict(
xaxis_title='Start Count', yaxis_title='Tail Count', zaxis_title='Objective Value',
camera=dict(eye=dict(x=-1.5, y=-1.5, z=1.5)),
xaxis=dict(range=[0, N_PATIENTS_SINGLE_CASE]),
yaxis=dict(range=[0, N_PATIENTS_SINGLE_CASE])
),
height=700, width=900, showlegend=True,
legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01, bgcolor="rgba(255,255,255,0.5)")
)
fig_single.show()
#| code-fold: true
def generate_schedules_on_projection(
target_sum: int,
n_patients: int,
t_intervals: int,
interval_duration: int,
convolutions: Dict[int, np.ndarray],
w_weight: float = 0.5,
) -> List[Tuple[np.ndarray, float, Optional[float]]]:
"""
Generates schedules along a projection where start + tail counts are constant.
This function creates a sequence of schedules by starting with all `target_sum`
patients in the first interval and iteratively moving one patient at a time
from the start to the tail interval. It evaluates the objective function for each.
This is useful for analyzing the convexity of the objective function along
this specific projection.
Args:
target_sum (int): The fixed sum for start_count + tail_count.
n_patients (int): Total number of patients.
t_intervals (int): Total number of time intervals.
interval_duration (int): Duration of a single time interval.
convolutions (Dict): Pre-computed convolution dictionary.
w_weight (float): The weight for the objective function.
Returns:
List[Tuple[np.ndarray, float, Optional[float]]]: A list of tuples, where
each tuple contains (schedule_array, objective_value, objective_delta).
The delta is the change from the previous schedule's objective.
"""
if not all(isinstance(arg, int) and arg >= 0 for arg in [target_sum, n_patients, t_intervals]):
raise ValueError("target_sum, n_patients, and t_intervals must be non-negative integers.")
# Define the vector for moving one patient from start to tail.
# v_star_zero is typically [-1, 0, ..., 0, 1].
v_star_matrix = get_v_star(t_intervals)
move_patient_vector = v_star_matrix[0]
# Calculate patients and intervals for the center part of the schedule.
num_center_patients = n_patients - target_sum
num_center_intervals = t_intervals - 2
if num_center_patients < 0 or num_center_intervals < 0:
return []  # Not possible to form a valid schedule.
center_schedule = generate_evenly_distributed_schedule_intervals(
num_center_patients, num_center_intervals
)
# Create the initial schedule: all `target_sum` patients at the start.
current_schedule = np.array([target_sum] + center_schedule + [0])
ewt, esp = calculate_objective_serv_time_lookup(
current_schedule.tolist(), interval_duration, convolutions
)
current_objective = w_weight * ewt + (1 - w_weight) * esp
projections_data = [(current_schedule, current_objective, None)]
# Iterate, moving one patient from start to tail each time.
for _ in range(target_sum):
# Apply the vector transformation.
next_schedule = current_schedule + move_patient_vector
if np.any(next_schedule < 0):
break # Stop if any patient count becomes negative.
ewt, esp = calculate_objective_serv_time_lookup(
next_schedule.tolist(), interval_duration, convolutions
)
next_objective = w_weight * ewt + (1 - w_weight) * esp
obj_delta = next_objective - current_objective
projections_data.append((next_schedule, next_objective, obj_delta))
# Update state for the next iteration.
current_schedule = next_schedule
current_objective = next_objective
return projections_data
# --- Parameters for Projection Analysis ---
TARGET_SUM = 32
# n_patients, t_intervals, interval_duration, and w_weight are reused from single-case analysis.
convolutions_projections = compute_convolutions(
service_time_dist.tolist(), N_PATIENTS_SINGLE_CASE, Q_SINGLE_CASE
)
# --- Generate and Plot Projection Data ---
projections_example = generate_schedules_on_projection(
target_sum=TARGET_SUM,
n_patients=N_PATIENTS_SINGLE_CASE,
t_intervals=T_INTERVALS,
interval_duration=INTERVAL_DURATION,
convolutions=convolutions_projections,
w_weight=W_SINGLE_CASE
)
#| code-fold: true
# --- Plot the Projection Analysis Results ---
if projections_example:
# Extract data for plotting.
schedules = [p[0] for p in projections_example]
objectives = [p[1] for p in projections_example]
# The first delta is None; replace with 0 for plotting.
deltas = [p[2] if p[2] is not None else 0 for p in projections_example]
# Create a figure with two subplots.
fig_projections = make_subplots(
rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1,
subplot_titles=("Objective Value Along Projection", "Change in Objective (Delta)")
)
# Add Objective Value trace.
fig_projections.add_trace(go.Scatter(
x=list(range(len(objectives))), y=objectives,
mode='lines+markers', name='Objective Value',
hovertemplate='<b>Iteration %{x}</b><br>Objective: %{y:.2f}<br>Schedule: %{customdata}<extra></extra>',
customdata=[str(s) for s in schedules], marker=dict(color='royalblue')
), row=1, col=1)
# Add Delta trace.
fig_projections.add_trace(go.Bar(
x=list(range(len(deltas))), y=deltas,
name='Objective Delta',
hovertemplate='<b>Iteration %{x}</b><br>Delta: %{y:.2f}<extra></extra>',
marker=dict(color='lightcoral')
), row=2, col=1)
# Update layout.
fig_projections.update_layout(
title_text='Analysis of Scheduling Projections (Integer Convexity Check)',
height=600, showlegend=False,
xaxis2_title='Schedule Iteration (Patients moved from Start to Tail)',
yaxis_title='Objective Value',
yaxis2_title='Objective Delta'
)
fig_projections.show()
#| code-fold: true
# --- Stage 1: Heuristic Search for a Good Starting Schedule ---
# This block performs a limited search over different start-tail sum combinations
# to find a promising initial schedule for the more intensive local search.
print("--- Starting Heuristic Search for Initial Schedule ---")
lowest_objective_value = float('inf')
best_schedule = None
# The range for target_sum is chosen heuristically.
# Start from the minimum possible sum to fit all patients.
min_target_sum = max(0, N_PATIENTS_SINGLE_CASE - (T_INTERVALS - 2))
heuristic_stop_limit = 30 # Limit the search space.
for target_sum in range(min_target_sum, heuristic_stop_limit + 1):
found_lower_in_iter = False
num_center_patients = N_PATIENTS_SINGLE_CASE - target_sum
if num_center_patients < 0: continue
center_schedule = generate_evenly_distributed_schedule_intervals(
num_center_patients, T_INTERVALS - 2
)
# Iterate through all start/tail splits for the current target_sum.
for start_count in range(target_sum + 1):
tail_count = target_sum - start_count
candidate_schedule = [start_count] + center_schedule + [tail_count]
ewt, esp = calculate_objective_serv_time_lookup(
candidate_schedule, INTERVAL_DURATION, convolutions_projections
)
current_objective = W_SINGLE_CASE * ewt + (1 - W_SINGLE_CASE) * esp
if current_objective < lowest_objective_value:
lowest_objective_value = current_objective
best_schedule = candidate_schedule
print(f"New best found: Obj={lowest_objective_value:.4f} for sum={target_sum}, S/T={start_count}/{tail_count}")
found_lower_in_iter = True
# Simple stopping criterion: if a full pass over a target_sum yields no improvement, stop.
if not found_lower_in_iter and best_schedule is not None:
print(f"\nNo improvement for target_sum={target_sum}. Stopping heuristic search.")
break
print(f"\n✅ Heuristic Search Complete. Best schedule found: {best_schedule}")
# --- Stage 2: Refine the Best Heuristic Schedule with Local Search ---
# Add a safety check to ensure the heuristic search actually found a schedule.
if best_schedule is not None:
print("\n--- Refining with Local Search ---")
v_star_matrix = get_v_star(T_INTERVALS)
# Call local_search_w_timer with the corrected parameter name.
final_schedule, final_cost, _ = local_search_w_timer(
initial_schedule=best_schedule,
interval_duration=INTERVAL_DURATION,
convolutions=convolutions_projections,
w_weight=W_SINGLE_CASE,
v_star=v_star_matrix,
t_intervals=T_INTERVALS, # CORRECTED: Changed 'size' to 't_intervals'
time_limit=10,
process_start_time=time.time(),
echo=False
)
print(f"🏁 Final best schedule after local search: {final_schedule.tolist()} with objective {final_cost:.4f}")
else:
print("\n⚠️ Heuristic search did not find a valid schedule. Skipping local search.")
