if not found_lower:
print(f"No lower objective value found for target_sum={target_sum}. Stopping search.\nBest schedule so far: {best_schedule} with objective value {lowest_objective_value}")
break
target_sum += 1
v_star = get_v_star(T_intervals)
x_star, c_star = local_search_w_timer(best_schedule, d_interval_len, convolutions_projections, w_single_case, v_star, T_intervals, time_limit = 10, echo = False)
print(f"Final best schedule found: {x_star} with objective value {c_star}")
#| code-fold: true
# --- Helper Function ---
def local_search_w_timer_new(
x: Union[List[int], np.ndarray], d: int, convolutions: Dict, w: float,
time_limit: Optional[int], process_start_time: float, echo: bool = False
) -> Tuple[np.ndarray, float, List[Dict]]:
"""
Performs local search by moving one patient at a time, logging all improvements found.
This uses a "first improvement" hill-climbing strategy.
"""
local_search_start_time = time.time()
x_star = np.array(x).flatten()
ewt, esp = calculate_objective_serv_time_lookup(x_star, d, convolutions)
c_star = w * ewt + (1 - w) * esp
log = []
T = len(x_star)
while True: # Keep searching until no improvement is found in a full pass
time_since_process_start = time.time() - process_start_time
if time_limit is not None and time_since_process_start > time_limit:
if echo: print(f"Local search time limit of {time_limit}s reached.")
break
found_improvement_in_pass = False
# Iterate over all pairs of slots to try moving one patient
for i, j in combinations(range(T), 2):
# Try moving from i to j
if x_star[i] > 0:
neighbor = x_star.copy()
neighbor[i] -= 1
neighbor[j] += 1
# Evaluate this neighbor
waiting_time, spillover = calculate_objective_serv_time_lookup(neighbor, d, convolutions)
cost = w * waiting_time + (1 - w) * spillover
if cost < c_star:
x_star, c_star = neighbor, cost
found_improvement_in_pass = True
# If an improvement was found, also check moving from j to i before logging and restarting
if not found_improvement_in_pass and x_star[j] > 0:
neighbor = x_star.copy()
neighbor[j] -= 1
neighbor[i] += 1
waiting_time, spillover = calculate_objective_serv_time_lookup(neighbor, d, convolutions)
cost = w * waiting_time + (1 - w) * spillover
if cost < c_star:
x_star, c_star = neighbor, cost
found_improvement_in_pass = True
if found_improvement_in_pass:
time_elapsed = time.time() - process_start_time
log_entry = {
"schedule": x_star.tolist(), "cost": c_star,
"source": "local_search", "time_elapsed": time_elapsed
}
log.append(log_entry)
if echo: print(f"LS found better solution: cost={c_star:.4f} at {time_elapsed:.2f}s")
break # Break from inner loop to restart the pass
if found_improvement_in_pass:
continue # An improvement was found, so restart the search pass
else:
break # No improvement in a full pass, terminate
return x_star, c_star, log
# --- Main Function with Integrated Logging ---
def find_optimal_schedule(
N_patients: int, T_intervals: int, d_interval_len: int, w: float,
convolutions_projections: Dict, heuristic_stop_limit: int = 20,
local_search_time_limit: int = 60,
start_with_heuristic: bool = True
) -> Tuple[List[Dict], float]:
"""
Finds an optimal patient schedule, logging all intermediate best solutions.
Can start with a heuristic or a naive schedule.
"""
total_start_time = time.time()
optimization_log = []
if start_with_heuristic:
print(f"ðŸš€ Starting optimization for {N_patients} patients with Heuristic Search.")
# --- Stage 1: Heuristic Search ---
print("\n--- Stage 1: Heuristic Search ---")
lowest_objective_value = float('inf')
start_target_sum = max(0, N_patients - T_intervals + 2)
num_center_intervals = T_intervals - 2
for target_sum in range(start_target_sum, heuristic_stop_limit + 1):
num_center_patients = N_patients - target_sum
if num_center_patients < 0: continue
center_schedule = generate_evenly_distributed_schedule_intervals(num_center_patients, num_center_intervals)
for s in range(target_sum + 1):
t = target_sum - s
candidate_schedule = [s, *center_schedule, t] if T_intervals > 1 else [N_patients]
ewt, esp = calculate_objective_serv_time_lookup(candidate_schedule, d_interval_len, convolutions_projections)
current_objective = w * ewt + (1 - w) * esp
if current_objective < lowest_objective_value:
lowest_objective_value = current_objective
time_elapsed = time.time() - total_start_time
log_entry = {"schedule": candidate_schedule, "cost": lowest_objective_value, "source": "heuristic", "time_elapsed": time_elapsed}
optimization_log.append(log_entry)
if not optimization_log:
print("\nHeuristic search could not find a valid initial schedule.")
# Fallback to a naive schedule
initial_schedule = [N_patients] + [0] * (T_intervals - 1)
else:
initial_schedule = optimization_log[-1]['schedule']
print(f"\nâœ… Stage 1 Complete. Best Heuristic Schedule: {initial_schedule}")
else:
print(f"ðŸš€ Starting optimization for {N_patients} patients with Local Search only.")
# Start with the same initial candidate as the heuristic to ensure a fair comparison
if T_intervals > 1:
start_target_sum = max(0, N_patients - T_intervals + 2)
num_center_intervals = T_intervals - 2
num_center_patients = N_patients - start_target_sum
center_schedule = []
if num_center_intervals > 0 and num_center_patients >= 0:
center_schedule = generate_evenly_distributed_schedule_intervals(num_center_patients, num_center_intervals)
s = 0
t = start_target_sum
initial_schedule = [s, *center_schedule, t]
else: # T_intervals <= 1
initial_schedule = [N_patients]
# Final check to ensure the sum is correct, just in case
if sum(initial_schedule) != N_patients:
print(f"Warning: Calculated initial schedule {initial_schedule} sums to {sum(initial_schedule)}, not {N_patients}. Falling back to naive.")
initial_schedule = [N_patients] + [0] * (T_intervals - 1)
print(f"Using heuristic's first candidate as starting schedule: {initial_schedule}")
# --- Stage 2: Local Search Refinement ---
print("\n--- Stage 2: Local Search Refinement ---")
if local_search_time_limit > 0 and T_intervals > 1:
_, _, local_search_log = local_search_w_timer_new(
initial_schedule, d_interval_len, convolutions_projections, w,
time_limit=local_search_time_limit,
process_start_time=total_start_time, echo=False
)
# Update the source label for plotting
source_label = "local_search" if start_with_heuristic else "local_search_from_start"
for entry in local_search_log:
entry["source"] = source_label
optimization_log.extend(local_search_log)
total_time_taken = time.time() - total_start_time
print(f"\nðŸ Optimization complete in {total_time_taken:.2f} seconds.")
return optimization_log, total_time_taken
# --- Example Usage & Plotting ---
# Define parameters
N_PATIENTS = N_patients_single_case
T_INTERVALS = T_intervals
D_INTERVAL_LEN = d_interval_len
W_WEIGHT = w_single_case
CONVOLUTIONS = convolutions_projections
# Corrected limit to ensure the heuristic search runs
HEURISTIC_LIMIT = target_sum
LS_TIME_LIMIT = 60
# Run the optimization and get the log
# --- Run 1: Heuristic + Local Search ---
heuristic_log, total_time = find_optimal_schedule(
N_patients=N_PATIENTS, T_intervals=T_INTERVALS, d_interval_len=D_INTERVAL_LEN,
w=W_WEIGHT, convolutions_projections=CONVOLUTIONS,
heuristic_stop_limit=HEURISTIC_LIMIT, local_search_time_limit=LS_TIME_LIMIT
)
# --- Run 2: Local Search Only (for the same total duration) ---
ls_only_log, _ = find_optimal_schedule(
N_patients=N_PATIENTS, T_intervals=T_INTERVALS, d_interval_len=D_INTERVAL_LEN,
w=W_WEIGHT, convolutions_projections=CONVOLUTIONS,
local_search_time_limit=total_time, # Use same total time as the first run
start_with_heuristic=False
)
# --- Combine logs and Plot ---
full_log = heuristic_log + ls_only_log
df = pd.DataFrame(full_log)
fig = go.Figure()
colors = {
'heuristic': '#636EFA',
'local_search': '#00CC96',
'local_search_from_start': '#EF553B'
}
for source_name, group in df.groupby('source'):
fig.add_trace(go.Scatter(
x=group['time_elapsed'], y=group['cost'],
name=source_name, mode='lines+markers',
line=dict(shape='hv', color=colors.get(source_name)),
marker=dict(size=8, line=dict(width=1, color='DarkSlateGrey'))
))
fig.update_layout(
title="Optimization Strategy Comparison",
xaxis_title="Time Elapsed (seconds)",
yaxis_title="Objective Function Cost",
legend_title_text="Search Method",
template="plotly_white"
)
print("\nDisplaying convergence plot...")
fig.show()
#| code-fold: true
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from scipy.linalg import hadamard
from scipy.optimize import minimize
from itertools import combinations
import random
import textwrap
from typing import List, Tuple, Dict, Optional, Union
import unittest
import time
# Assumes functions.py is in the same directory or accessible in the python path
from functions import (
get_v_star,
compute_convolutions,
calculate_objective_serv_time_lookup,
local_search_w_timer
)
#| code-fold: true
#| echo: false
# --- Helper: generate_weighted_list ---
def generate_weighted_list(max_s: int, l: float, i: int) -> Optional[np.ndarray]:
if not isinstance(max_s, int) or max_s <= 0: return None
if not isinstance(l, (int, float)) or not (1 <= l <= max_s): return None
if not isinstance(i, int) or not (0 <= i < max_s): return None
def objective_fn(x: np.ndarray) -> float:
return (np.dot(np.arange(1, max_s + 1), x) - l) ** 2
constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1.0})
bounds = [(0, 1)] * max_s
initial_guess = np.random.dirichlet(np.ones(max_s))
try:
result = minimize(objective_fn, initial_guess, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 300, 'ftol': 1e-9})
if not result.success: return None
optimized_probs = result.x
optimized_probs[optimized_probs < 0] = 0
current_sum = np.sum(optimized_probs)
if not np.isclose(current_sum, 1.0):
if current_sum > 1e-8: optimized_probs /= current_sum
else: return None
except Exception as e: return None
values = np.zeros(max_s + 1)
first_part_probs = optimized_probs[:i] if i > 0 else np.array([])
second_part_probs = optimized_probs[i:]
if i > 0: values[1 : i + 1] = np.sort(first_part_probs)
values[i + 1 : max_s + 1] = np.sort(second_part_probs)[::-1]
final_sum = np.sum(values[1:])
if not np.isclose(final_sum, 1.0):
if final_sum > 1e-8: values[1:] /= final_sum
else: return None
return values
# --- Helper: Generate evenly distributed patient schedule ---
def generate_evenly_distributed_schedule_intervals(n_patients: int, t_intervals: int) -> List[int]:
if n_patients < 0 or t_intervals < 0: raise ValueError("Inputs must be non-negative.")
if n_patients == 0: return [0] * t_intervals
if t_intervals > 0 and n_patients > t_intervals: raise ValueError(f"Cannot schedule {n_patients} in {t_intervals} intervals.")
if n_patients == t_intervals: return [1] * t_intervals
if t_intervals == 0: return [] if n_patients == 0 else [n_patients] # Special case for 0 intervals
base, extra = divmod(n_patients, t_intervals)
return [base + 1] * extra + [base] * (t_intervals - extra)
# --- Helper: Generate start and tail numbers ---
def generate_start_tail_distribution(N_patients: int, T_intervals: int) -> List[Tuple[int, int]]:
if N_patients < 0: return []
distribution = []
for i in range(N_patients + 1):
start = i
for j in range(N_patients + 1 - i):
tail = j
center_patients = N_patients - start - tail
center_intervals = T_intervals - 2
if center_intervals < 0:
if center_patients != 0: continue
# This logic seems to be for a different type of schedule generation than generate_evenly_distributed_schedule_intervals
# which handles multiple patients per slot. Let's simplify the check.
distribution.append((start, tail))
return distribution
#| code-fold: true
#| echo: false
# --- Main computation function ---
def compute_schedules_and_objectives(
q_no_show: float, w_weight: float,
current_N_patients: int, current_T_intervals: int,
s_dist: np.ndarray, d_interval_len: int
) -> Tuple[List[List[int]], List[float]]:
s_dist_list = s_dist.tolist()
convolutions_dict = compute_convolutions(s_dist_list, current_N_patients, q_no_show)
start_tail_options = generate_start_tail_distribution(current_N_patients, current_T_intervals)
schedules = []
objective_values = []
for start_count, tail_count in start_tail_options:
num_center_patients = current_N_patients - start_count - tail_count
num_center_intervals = current_T_intervals - 2
if num_center_patients < 0 or (num_center_patients > 0 and num_center_intervals <= 0 and current_T_intervals > 1):
continue
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients, num_center_intervals
)
if current_T_intervals > 1:
final_schedule = [start_count] + center_schedule_segment + [tail_count]
elif current_T_intervals == 1:
final_schedule = [current_N_patients]
else: # T=0
final_schedule = []
if len(final_schedule) != current_T_intervals:
continue
if sum(final_schedule) != current_N_patients:
continue
schedules.append(final_schedule)
ewt, esp = calculate_objective_serv_time_lookup(final_schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
#| code-fold: true
#| echo: false
def generate_schedules_w_equal_start_tail_sum(
target_sum: int, N: int, T: int, d: int,
convolutions: Dict[int, np.ndarray], w: float = 0.5
) -> List[Tuple[List[int], float]]:
projections = []
num_center_patients = N - target_sum
num_center_intervals = T - 2
if num_center_patients < 0 or (num_center_patients > 0 and num_center_intervals <= 0):
return []
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients, num_center_intervals
)
for s in range(target_sum + 1):
t = target_sum - s
schedule = [s] + center_schedule_segment + [t]
ewt, esp = calculate_objective_serv_time_lookup(schedule, d, convolutions)
objective_value = w * ewt + (1 - w) * esp
projections.append((schedule, objective_value))
return projections
#| code-fold: true
#| echo: false
def find_optimal_schedule(
N_patients: int, T_intervals: int, d_interval_len: int, w: float,
convolutions_projections: Dict, heuristic_stop_limit: int = 20,
local_search_time_limit: int = 60,
start_with_heuristic: bool = True
) -> Tuple[List[Dict], float]:
total_start_time = time.time()
optimization_log = []
if start_with_heuristic:
lowest_objective_value = float('inf')
start_target_sum = max(0, N_patients - T_intervals + 2)
num_center_intervals = T_intervals - 2
for target_sum in range(start_target_sum, heuristic_stop_limit + 1):
num_center_patients = N_patients - target_sum
if num_center_patients < 0: continue
center_schedule = generate_evenly_distributed_schedule_intervals(num_center_patients, num_center_intervals)
for s in range(target_sum + 1):
t = target_sum - s
candidate_schedule = [s, *center_schedule, t] if T_intervals > 1 else [N_patients]
ewt, esp = calculate_objective_serv_time_lookup(candidate_schedule, d_interval_len, convolutions_projections)
current_objective = w * ewt + (1 - w) * esp
if current_objective < lowest_objective_value:
lowest_objective_value = current_objective
time_elapsed = time.time() - total_start_time
log_entry = {"schedule": candidate_schedule, "cost": lowest_objective_value, "source": "heuristic", "time_elapsed": time_elapsed}
optimization_log.append(log_entry)
initial_schedule = optimization_log[-1]['schedule'] if optimization_log else ([N_patients] + [0] * (T_intervals - 1) if T_intervals > 0 else [])
else:
if T_intervals > 1:
start_target_sum = max(0, N_patients - T_intervals + 2)
num_center_intervals = T_intervals - 2
num_center_patients = N_patients - start_target_sum
center_schedule = []
if num_center_intervals > 0 and num_center_patients >= 0:
center_schedule = generate_evenly_distributed_schedule_intervals(num_center_patients, num_center_intervals)
initial_schedule = [0, *center_schedule, start_target_sum]
elif T_intervals == 1:
initial_schedule = [N_patients]
else: # T_intervals = 0
initial_schedule = []
if sum(initial_schedule) != N_patients:
initial_schedule = ([N_patients] + [0] * (T_intervals - 1) if T_intervals > 0 else [])
if local_search_time_limit > 0 and T_intervals > 1:
_, _, local_search_log = local_search_w_timer(
initial_schedule, d_interval_len, convolutions_projections, w,
time_limit=local_search_time_limit,
process_start_time=total_start_time, echo=False
)
source_label = "local_search" if start_with_heuristic else "local_search_from_start"
for entry in local_search_log:
entry["source"] = source_label
optimization_log.extend(local_search_log)
total_time_taken = time.time() - total_start_time
return optimization_log, total_time_taken
#| code-fold: true
#| echo: false
#| label: fig-solution-space-N24
#| fig-cap: "Solution space for N=24 patients. Rows vary by weight (w), columns by no-show rate (q)."
# --- Parameters & Plotting ---
T_intervals = 48
d_interval_len = 10
s_dist = generate_weighted_list(30, 15.0, 10)
def plot_grid(N_patients_fig, w_values, q_values):
fig = make_subplots(
rows=len(w_values), cols=len(q_values),
specs=[[{'type': 'scatter3d'}] * len(q_values)] * len(w_values),
subplot_titles=[f'q={q:.2f}, w={w:.1f}' for w in w_values for q in q_values],
horizontal_spacing=0.02, vertical_spacing=0.12
)
all_data = {}
global_z_min, global_z_max = float('inf'), float('-inf')
for i, w in enumerate(w_values):
for j, q in enumerate(q_values):
schedules, objectives = compute_schedules_and_objectives(q, w, N_patients_fig, T_intervals, s_dist, d_interval_len)
all_data[(i, j)] = (schedules, objectives)
if objectives:
global_z_min = min(global_z_min, min(objectives))
global_z_max = max(global_z_max, max(objectives))
if global_z_min == float('inf'): global_z_min = 0
if global_z_max == float('-inf'): global_z_max = 1
titles = []
for i, w in enumerate(w_values):
for j, q in enumerate(q_values):
schedules, objectives = all_data.get((i, j), ([], []))
title = f'q={q:.2f}, w={w:.1f}'
if not objectives:
titles.append(f'{title}<br><sub>No data</sub>')
fig.add_trace(go.Scatter3d(x=[], y=[], z=[]), row=i+1, col=j+1)
continue
x_coords = [s[0] for s in schedules]
y_coords = [s[-1] for s in schedules]
min_obj_val = min(objectives)
min_index = objectives.index(min_obj_val)
titles.append(f'{title}<br><sub>Min: {min_obj_val:.4f}</sub>')
fig.add_trace(go.Scatter3d(
x=x_coords, y=y_coords, z=objectives, mode='markers',
marker=dict(size=4, color=objectives, colorscale='Viridis', cmin=global_z_min, cmax=global_z_max, showscale=(i==0 and j==len(q_values)-1)),
hoverinfo='none', showlegend=False
), row=i+1, col=j+1)
fig.add_trace(go.Scatter3d(
x=[x_coords[min_index]], y=[y_coords[min_index]], z=[min_obj_val], mode='markers',
marker=dict(size=6, color='red'), name='Minimum', showlegend=False
), row=i+1, col=j+1)
for idx, title_text in enumerate(titles):
if idx < len(fig.layout.annotations):
fig.layout.annotations[idx].text = title_text
fig.update_layout(
title=f'3D Analysis: N={N_patients_fig}<br><sub>Rows: w (weight), Columns: q (no-show)</sub>',
height=400*len(w_values), width=1400, margin=dict(t=100)
)
for scene in fig.layout:
if scene.startswith('scene'):
fig.layout[scene].xaxis.title = 'Start Count'
fig.layout[scene].yaxis.title = 'Tail Count'
fig.layout[scene].zaxis.title = 'Objective'
return fig
plot_grid(N_patients_fig=24, w_values=[0.1, 0.5, 0.9], q_values=[0.1, 0.15, 0.2]).show()
#| code-fold: true
#| echo: false
#| label: fig-solution-space-N40
#| fig-cap: "Solution space for N=40 patients. Rows vary by weight (w), columns by no-show rate (q)."
plot_grid(N_patients_fig=40, w_values=[0.1, 0.9], q_values=[0.1, 0.2]).show()
#| code-fold: true
#| echo: false
#| label: fig-convexity
#| fig-cap: "Objective values and their deltas along the projection where start + tail = 40, demonstrating integer convexity."
N_patients_single_case = 48
q_single_case = 0.2
w_single_case = 0.5
target_sum = 40
convolutions = compute_convolutions(s_dist.tolist(), N_patients_single_case, q_single_case)
projections = generate_schedules_w_equal_start_tail_sum(target_sum, N_patients_single_case, T_intervals, d_interval_len, convolutions, w_single_case)
if projections:
objectives = [p[1] for p in projections]
deltas = np.diff(objectives, prepend=np.nan) # Use NaN for the first delta
fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1,
subplot_titles=("Objective Value", "Change in Objective (Delta)"))
fig.add_trace(go.Scatter(x=list(range(len(objectives))), y=objectives, mode='lines+markers', name='Objective'), row=1, col=1)
fig.add_trace(go.Bar(x=list(range(len(deltas))), y=deltas, name='Delta'), row=2, col=1)
fig.update_layout(title_text=f'Analysis of Projection Where Start + Tail = {target_sum}', height=600, showlegend=False)
fig.update_xaxes(title_text="Iteration Along Projection (Increasing Tail Count)", row=2, col=1)
fig.update_yaxes(title_text="Objective Value", row=1, col=1)
fig.update_yaxes(title_text="Objective Delta", row=2, col=1)
fig.show()
#| code-fold: true
#| echo: false
#| label: fig-comparison-plots
#| fig-cap: "Performance comparison of optimization strategies under different conditions."
def run_and_plot_comparison(N, w, T, d, s_dist_list, time_limit):
print(f"\n--- Running Comparison for N={N}, w={w} ---")
q = 0.1 # Using a fixed q for these comparisons
convolutions = compute_convolutions(s_dist_list, N, q)
heuristic_log, total_time = find_optimal_schedule(
N, T, d, w, convolutions,
heuristic_stop_limit=N, local_search_time_limit=time_limit
)
ls_only_log, _ = find_optimal_schedule(
N, T, d, w, convolutions,
local_search_time_limit=total_time, start_with_heuristic=False
)
full_log = heuristic_log + ls_only_log
if not full_log:
print("No data generated for comparison plot.")
return
df = pd.DataFrame(full_log)
fig = go.Figure()
colors = {'heuristic': '#636EFA', 'local_search': '#00CC96', 'local_search_from_start': '#EF553B'}
for source, group in df.groupby('source'):
fig.add_trace(go.Scatter(
x=group['time_elapsed'], y=group['cost'], name=source,
mode='lines+markers', line=dict(shape='hv', color=colors.get(source))
))
fig.update_layout(
title=f"Strategy Comparison: N={N}, w={w}",
xaxis_title="Time Elapsed (seconds)", yaxis_title="Objective Function Cost",
legend_title="Method", template="plotly_white"
)
fig.show()
# Run comparisons
s_dist_list = s_dist.tolist()
run_and_plot_comparison(N=24, w=0.1, T=T_intervals, d=d_interval_len, s_dist_list=s_dist_list, time_limit=10)
run_and_plot_comparison(N=24, w=0.9, T=T_intervals, d=d_interval_len, s_dist_list=s_dist_list, time_limit=10)
run_and_plot_comparison(N=40, w=0.1, T=T_intervals, d=d_interval_len, s_dist_list=s_dist_list, time_limit=10)
run_and_plot_comparison(N=40, w=0.9, T=T_intervals, d=d_interval_len, s_dist_list=s_dist_list, time_limit=10)
