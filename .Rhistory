best_projection = None
print(f"Target sum: {target_sum}, Best projection: {best_projection}, Lowest objective value: {lowest_objective_value}")
target_sum += 1
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - T - 2 + 1) to ensure non-negative start
stop = 10
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
t = target_sum - s
schedule_parts.extend(s)
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d, convolutions
)
new_objective_value = w * ewt + (1 - w) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
# print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}")
target_sum += 1
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - T - 2 + 1) to ensure non-negative start
stop = 10
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d, convolutions
)
new_objective_value = w * ewt + (1 - w) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
# print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}")
target_sum += 1
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - T - 2 + 1) to ensure non-negative start
stop = 10
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
# print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}")
target_sum += 1
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - T - 2 + 1) to ensure non-negative start
stop = 10
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
# print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}")
target_sum += 1
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - T - 2 + 1) to ensure non-negative start
stop = 10
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}")
target_sum += 1
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - T - 2 + 1) to ensure non-negative start
stop = 20
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}")
target_sum += 1
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - T - 2 + 1) to ensure non-negative start
stop = 20
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}. Sum schedule={sum(schedule_parts)}")
target_sum += 1
#| code-fold: true
# Extract data for plotting
schedules = [p[0] for p in projections_example]
objectives = [p[1] for p in projections_example]
deltas = [p[2] for p in projections_example]
# Replace None in deltas with 0 for plotting
deltas[0] = 0
# Create the chart
fig_projections = make_subplots(
rows=2, cols=1,
shared_xaxes=True,
vertical_spacing=0.1,
subplot_titles=("Objective Value per Schedule Iteration", "Change in Objective (Delta) per Iteration")
)
# Add Objective Value trace
fig_projections.add_trace(go.Scatter(
x=list(range(len(objectives))),
y=objectives,
mode='lines+markers',
name='Objective Value',
hovertemplate='<b>Iteration %{x}</b><br>Objective: %{y:.2f}<br>Schedule: %{customdata}<extra></extra>',
customdata=[str(s) for s in schedules],
marker=dict(color='royalblue')
), row=1, col=1)
# Add Delta trace
fig_projections.add_trace(go.Bar(
x=list(range(len(deltas))),
y=deltas,
name='Objective Delta',
hovertemplate='<b>Iteration %{x}</b><br>Delta: %{y:.2f}<extra></extra>',
marker=dict(color='lightcoral')
), row=2, col=1)
# Update layout
fig_projections.update_layout(
title_text='Analysis of Scheduling Projections',
height=600,
showlegend=False,
xaxis2_title='Schedule Iteration',
yaxis_title='Objective Value',
yaxis2_title='Objective Delta'
)
fig_projections.show()
#| code-fold: true
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - (T - 2)) to ensure non-negative start
stop = 20
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
found_lower = False
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
best_schedule = schedule_parts
print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}. Sum schedule={sum(schedule_parts)}")
found_lower = True
if not found_lower:
print(f"No lower objective value found for target_sum={target_sum}. Stopping search.\nBest schedule so far: {best_schedule} with objective value {lowest_objective_value}")
break
target_sum += 1
v_star = get_v_star(T_intervals)
x_star, c_star = local_search_w_timer(x,
d_interval_len,
convolutions_projections,
w_single_case,
v_star,
size = T_intervals,
time_limit = 60,
echo: False)
#| code-fold: true
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - (T - 2)) to ensure non-negative start
stop = 20
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
found_lower = False
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
best_schedule = schedule_parts
print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}. Sum schedule={sum(schedule_parts)}")
found_lower = True
if not found_lower:
print(f"No lower objective value found for target_sum={target_sum}. Stopping search.\nBest schedule so far: {best_schedule} with objective value {lowest_objective_value}")
break
target_sum += 1
v_star = get_v_star(T_intervals)
x_star, c_star = local_search_w_timer(x, d_interval_len, convolutions_projections, w_single_case, v_star, T_intervals, time_limit = 60, echo: False)
#| code-fold: true
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - (T - 2)) to ensure non-negative start
stop = 20
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
found_lower = False
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
best_schedule = schedule_parts
print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}. Sum schedule={sum(schedule_parts)}")
found_lower = True
if not found_lower:
print(f"No lower objective value found for target_sum={target_sum}. Stopping search.\nBest schedule so far: {best_schedule} with objective value {lowest_objective_value}")
break
target_sum += 1
v_star = get_v_star(T_intervals)
x_star, c_star = local_search_w_timer(x, d_interval_len, convolutions_projections, w_single_case, v_star, T_intervals, time_limit = 60, echo = False)
#| code-fold: true
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from scipy.linalg import hadamard
from scipy.optimize import minimize
import random
import textwrap
from typing import List, Tuple, Dict, Optional
import unittest
from functions import (
get_v_star,
compute_convolutions,
calculate_objective_serv_time_lookup,
local_search_w_timer
)
#| code-fold: true
target_sum = max(0, N_patients_single_case - T_intervals + 2)  # Start from max(0, N - (T - 2)) to ensure non-negative start
stop = 20
lowest_objective_value = float('inf')  # Initialize to a very high value
while target_sum <= stop:
found_lower = False
num_center_patients = N_patients_single_case - target_sum # Patients in the center part
num_center_intervals = T_intervals - 2 # Intervals available for the center part
if num_center_patients < 0: # Should not happen if generate_start_tail_distribution is correct
# print(f"Warning: Negative center patients ({num_center_patients}) for start={start_count}, tail={tail_count}. Skipping.")
continue
if num_center_intervals < 0:
if num_center_patients > 0:
# print(f"Warning: Cannot schedule {num_center_patients} center patients in {num_center_intervals} intervals. Skipping.")
continue
# If num_center_patients is 0 and num_center_intervals is < 0, center_schedule should be empty.
center_schedule_segment = []
elif num_center_patients == 0: # No patients for the center part
center_schedule_segment = [0] * num_center_intervals
else:
center_schedule_segment = generate_evenly_distributed_schedule_intervals(
num_center_patients,
num_center_intervals
)
# generate_evenly_distributed_schedule_intervals raises ValueError on failure
# so no need to check for None if its contract is maintained.
for s in range(target_sum + 1):
schedule_parts = [s]  # Start with the start count
t = target_sum - s
schedule_parts.extend(center_schedule_segment)
schedule_parts.append(t)
ewt, esp = calculate_objective_serv_time_lookup(
schedule_parts, d_interval_len, convolutions_projections
)
new_objective_value = w_single_case * ewt + (1 - w_single_case) * esp
if new_objective_value < lowest_objective_value:
lowest_objective_value = new_objective_value
best_schedule = schedule_parts
print(f"New lowest objective value found: {lowest_objective_value} for target_sum={target_sum}, schedule={schedule_parts}. Sum schedule={sum(schedule_parts)}")
found_lower = True
if not found_lower:
print(f"No lower objective value found for target_sum={target_sum}. Stopping search.\nBest schedule so far: {best_schedule} with objective value {lowest_objective_value}")
break
target_sum += 1
v_star = get_v_star(T_intervals)
x_star, c_star = local_search_w_timer(x, d_interval_len, convolutions_projections, w_single_case, v_star, T_intervals, time_limit = 60, echo = False)
reticulate::repl_python()
