generate_evenly_distributed_schedule_intervals_rounded(5, -1)
def test_non_integer_patients(self):
"""Test ValueError: Non-integer patients."""
with self.assertRaisesRegex(ValueError, "n_patients must be a non-negative integer."):
generate_evenly_distributed_schedule_intervals_rounded(2.5, 5) # type: ignore
def test_non_integer_intervals(self):
"""Test ValueError: Non-integer intervals."""
with self.assertRaisesRegex(ValueError, "t_intervals must be a non-negative integer."):
generate_evenly_distributed_schedule_intervals_rounded(5, 10.5) # type: ignore
def test_zero_intervals_positive_patients(self):
"""Test ValueError: 0 intervals but more than 0 patients."""
with self.assertRaisesRegex(ValueError, "Cannot schedule"):
generate_evenly_distributed_schedule_intervals_rounded(1, 0)
# --- How to run the tests ---
if __name__ == '__main__':
unittest.main(argv=['first-arg-is-ignored'], exit=False)
# --- Main computation function ---
N_patients = 24
T_intervals = 48
d_interval_len = 10
max_s_time = 30
l_target_avg_service_time = 14.0
i_sorting_split = 10
v_star_matrix = get_v_star(T_intervals)
s_dist = generate_weighted_list(max_s_time, l_target_avg_service_time, i_sorting_split)
if s_dist is None:
raise ValueError("Failed to generate service time distribution.")
def compute_schedules_and_objectives(q_no_show: float, w_weight: float):
"""Compute schedules and objectives for given parameters"""
convolutions_dict = compute_convolutions(s_dist.tolist(), N_patients, q_no_show)
distribution = generate_start_tail_distribution(N_patients, T_intervals)
schedules = []
objective_values = []
for start, tail in distribution:
schedule = [start]
center = generate_evenly_distributed_schedule_intervals(N_patients - start - tail, T_intervals - 2)
if start = N_patients:
print(center)
if center is None:
raise ValueError("Failed to generate center schedule.")
schedule.extend(center)
schedule.append(tail)
schedules.append(schedule)
ewt, esp = calculate_objective_serv_time_lookup(schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Create 3x3 subplot grid ---
q_values = [0.1, 0.15, 0.2]
w_values = [0.1, 0.5, 0.9]
# --- Main computation function ---
N_patients = 24
T_intervals = 48
d_interval_len = 10
max_s_time = 30
l_target_avg_service_time = 14.0
i_sorting_split = 10
v_star_matrix = get_v_star(T_intervals)
s_dist = generate_weighted_list(max_s_time, l_target_avg_service_time, i_sorting_split)
if s_dist is None:
raise ValueError("Failed to generate service time distribution.")
def compute_schedules_and_objectives(q_no_show: float, w_weight: float):
"""Compute schedules and objectives for given parameters"""
convolutions_dict = compute_convolutions(s_dist.tolist(), N_patients, q_no_show)
distribution = generate_start_tail_distribution(N_patients, T_intervals)
schedules = []
objective_values = []
for start, tail in distribution:
schedule = [start]
center = generate_evenly_distributed_schedule_intervals(N_patients - start - tail, T_intervals - 2)
if start == N_patients:
print(center)
if center is None:
raise ValueError("Failed to generate center schedule.")
schedule.extend(center)
schedule.append(tail)
schedules.append(schedule)
ewt, esp = calculate_objective_serv_time_lookup(schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Create 3x3 subplot grid ---
q_values = [0.1, 0.15, 0.2]
w_values = [0.1, 0.5, 0.9]
# --- Main computation function ---
N_patients = 24
T_intervals = 48
d_interval_len = 10
max_s_time = 30
l_target_avg_service_time = 14.0
i_sorting_split = 10
v_star_matrix = get_v_star(T_intervals)
s_dist = generate_weighted_list(max_s_time, l_target_avg_service_time, i_sorting_split)
if s_dist is None:
raise ValueError("Failed to generate service time distribution.")
def compute_schedules_and_objectives(q_no_show: float, w_weight: float):
"""Compute schedules and objectives for given parameters"""
convolutions_dict = compute_convolutions(s_dist.tolist(), N_patients, q_no_show)
distribution = generate_start_tail_distribution(N_patients, T_intervals)
print(f"Distribution: {distribution}")
schedules = []
objective_values = []
for start, tail in distribution:
schedule = [start]
center = generate_evenly_distributed_schedule_intervals(N_patients - start - tail, T_intervals - 2)
if start == N_patients:
print(center)
if center is None:
raise ValueError("Failed to generate center schedule.")
schedule.extend(center)
schedule.append(tail)
schedules.append(schedule)
ewt, esp = calculate_objective_serv_time_lookup(schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Create 3x3 subplot grid ---
q_values = [0.1, 0.15, 0.2]
w_values = [0.1, 0.5, 0.9]
# --- Main computation function ---
N_patients = 24
T_intervals = 48
d_interval_len = 10
max_s_time = 30
l_target_avg_service_time = 14.0
i_sorting_split = 10
v_star_matrix = get_v_star(T_intervals)
s_dist = generate_weighted_list(max_s_time, l_target_avg_service_time, i_sorting_split)
if s_dist is None:
raise ValueError("Failed to generate service time distribution.")
def compute_schedules_and_objectives(q_no_show: float, w_weight: float):
"""Compute schedules and objectives for given parameters"""
convolutions_dict = compute_convolutions(s_dist.tolist(), N_patients, q_no_show)
distribution = generate_start_tail_distribution(N_patients, T_intervals)
schedules = []
objective_values = []
for start, tail in distribution:
schedule = [start]
center = generate_evenly_distributed_schedule_intervals(N_patients - start - tail, T_intervals - 2)
if start == N_patients:
print(center)
if center is None:
raise ValueError("Failed to generate center schedule.")
schedule.extend(center)
schedule.append(tail)
schedules.append(schedule)
ewt, esp = calculate_objective_serv_time_lookup(schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Create 3x3 subplot grid ---
q_values = [0.1, 0.15, 0.2]
w_values = [0.1, 0.5, 0.9]
compute_schedules_and_objectives(0.1, 0.1)
# --- Helper: generate_weighted_list ---
def generate_weighted_list(max_s: int, l: float, i: int) -> Optional[np.ndarray]:
if not isinstance(max_s, int) or max_s <= 0: return None
if not isinstance(l, (int, float)) or not (1 <= l <= max_s): return None
if not isinstance(i, int) or not (0 <= i < max_s): return None
def objective_fn(x: np.ndarray) -> float:
return (np.dot(np.arange(1, max_s + 1), x) - l) ** 2
constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1.0})
bounds = [(0, 1)] * max_s
initial_guess = np.random.dirichlet(np.ones(max_s))
try:
result = minimize(objective_fn, initial_guess, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 300, 'ftol': 1e-9})
if not result.success: return None
optimized_probs = result.x
optimized_probs[optimized_probs < 0] = 0
current_sum = np.sum(optimized_probs)
if not np.isclose(current_sum, 1.0):
if current_sum > 1e-8: optimized_probs /= current_sum
else: return None
except Exception: return None
first_part_probs = optimized_probs[:i] if i > 0 else np.array([])
second_part_probs = optimized_probs[i:]
values = np.zeros(max_s + 1)
if i > 0: values[1 : i + 1] = np.sort(first_part_probs)
values[i + 1 : max_s + 1] = np.sort(second_part_probs)[::-1]
final_sum = np.sum(values[1:])
if not np.isclose(final_sum, 1.0):
if final_sum > 1e-8: values[1:] /= final_sum
else: return None
return values
# --- Helper: Generate evenly distributed patient schedule ---
def generate_evenly_distributed_schedule_intervals(n_patients: int, t_intervals: int) -> List[int]:
"""
Generates a list representing a schedule, aiming to distribute 'n_patients'
into 't_intervals' as evenly as possible using round(). A '1' indicates
a scheduled interval, and '0' an empty one.
Key Behavior:
- If n_patients == 0: Returns a list of all zeros of length 't_intervals'.
- If t_intervals < n_patients (and n_patients > 0): Raises a ValueError.
- If n_patients == t_intervals (and both > 0): Returns a list of all ones.
- If n_patients < t_intervals (and both > 0): The function attempts to mark
'n_patients' distinct intervals using rounding.
The patient slots are chosen using the formula round(j * t_intervals / n_patients)
for j from 0 to n_patients-1.
- **Warning**: Using round() might lead to duplicate indices, potentially
resulting in fewer than 'n_patients' being scheduled. If exactly
'n_patients' must be scheduled, the floor-based approach or a
different algorithm should be used.
Args:
n_patients: The number of patients to schedule. Must be a non-negative integer.
t_intervals: The total number of available time intervals. Must be a non-negative integer.
Returns:
A list of integers of length 't_intervals'.
Raises:
ValueError: If 'n_patients' or 't_intervals' are not non-negative integers.
ValueError: If 't_intervals' is less than 'n_patients' (and n_patients > 0).
"""
# Validate inputs
if not isinstance(n_patients, int) or n_patients < 0:
raise ValueError("n_patients must be a non-negative integer.")
if not isinstance(t_intervals, int) or t_intervals < 0:
raise ValueError("t_intervals must be a non-negative integer.")
# Handle n_patients == 0
if n_patients == 0:
return [0] * t_intervals
# At this point, n_patients > 0.
# Core logic based on comparison of n_patients and t_intervals
if t_intervals < n_patients:
raise ValueError(
f"Cannot schedule {n_patients} patients in only {t_intervals} intervals. "
"Not enough unique slots available."
)
elif n_patients == t_intervals:
return [1] * t_intervals
else: # n_patients < t_intervals
schedule = [0] * t_intervals
scheduled_count = 0
for j in range(n_patients):
# Use round() and ensure the result is an integer for indexing
index = int(round(j * t_intervals / n_patients))
# Ensure index stays within bounds (shouldn't happen, but safety first)
if index >= t_intervals:
index = t_intervals - 1
schedule[index] = 1
# Optional: Add a check/warning if the number of scheduled patients
# is less than n_patients due to rounding collisions.
# actual_scheduled = sum(schedule)
# if actual_scheduled < n_patients:
#     print(f"Warning: Due to rounding, only {actual_scheduled} out of {n_patients} patients were scheduled.")
return schedule
# --- Helper: Generate start and tail numbers ---
def generate_start_tail_distribution(N_patients: int, T_intervals) -> List[Tuple[int, int]]:
if not isinstance(N_patients, int) or N_patients <= 0: return []
distribution = []
for i in range(N_patients + 1):
start = i
for j in range(N_patients + 1 - i):
tail = j
if N_patients - start - tail <= T_intervals - 2: distribution.append((start, tail))
return distribution
# --- The Unit Tests ---
class TestScheduleGenerationRounded(unittest.TestCase):
def test_zero_patients_zero_intervals(self):
"""Test case: 0 patients, 0 intervals -> empty list."""
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(0, 0), [])
def test_zero_patients_some_intervals(self):
"""Test case: 0 patients, 5 intervals -> all zeros."""
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(0, 5), [0, 0, 0, 0, 0])
def test_equal_patients_and_intervals(self):
"""Test case: 4 patients, 4 intervals -> all ones."""
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(4, 4), [1, 1, 1, 1])
def test_simple_distribution(self):
"""Test case: 2 patients, 4 intervals -> [1, 0, 1, 0]."""
# j*4/2 -> 0, 2 -> round -> 0, 2
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(2, 4), [1, 0, 1, 0])
def test_rounding_case_1(self):
"""Test case: 3 patients, 5 intervals -> [1, 0, 1, 1, 0]."""
# j*5/3 -> 0, 1.666..., 3.333... -> round -> 0, 2, 3
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(3, 5), [1, 0, 1, 1, 0])
def test_rounding_case_2_bankers(self):
"""Test case: 2 patients, 3 intervals -> [1, 0, 1]."""
# j*3/2 -> 0, 1.5 -> round -> 0, 2 (1.5 rounds to nearest even 2)
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(2, 3), [1, 0, 1])
def test_rounding_case_3_bankers(self):
"""Test case: 4 patients, 10 intervals -> [1, 0, 1, 0, 0, 1, 0, 0, 1, 0]."""
# j*10/4 -> 0, 2.5, 5.0, 7.5 -> round -> 0, 2, 5, 8 (2.5->2, 7.5->8)
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(4, 10), [1, 0, 1, 0, 0, 1, 0, 0, 1, 0])
# Ensure 4 patients were scheduled
self.assertEqual(sum(generate_evenly_distributed_schedule_intervals_rounded(4, 10)), 4)
def test_one_patient(self):
"""Test case: 1 patient, 5 intervals -> [1, 0, 0, 0, 0]."""
# j*5/1 -> 0 -> round -> 0
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(1, 5), [1, 0, 0, 0, 0])
def test_almost_full(self):
"""Test case: 4 patients, 5 intervals -> [1, 1, 1, 0, 1]."""
# j*5/4 -> 0, 1.25, 2.5, 3.75 -> round -> 0, 1, 2, 4 (2.5->2)
self.assertEqual(generate_evenly_distributed_schedule_intervals_rounded(4, 5), [1, 1, 1, 0, 1])
# --- Error Handling Tests ---
def test_too_many_patients(self):
"""Test ValueError: More patients than intervals."""
with self.assertRaisesRegex(ValueError, "Cannot schedule"):
generate_evenly_distributed_schedule_intervals_rounded(5, 4)
def test_negative_patients(self):
"""Test ValueError: Negative number of patients."""
with self.assertRaisesRegex(ValueError, "n_patients must be a non-negative integer."):
generate_evenly_distributed_schedule_intervals_rounded(-1, 5)
def test_negative_intervals(self):
"""Test ValueError: Negative number of intervals."""
with self.assertRaisesRegex(ValueError, "t_intervals must be a non-negative integer."):
generate_evenly_distributed_schedule_intervals_rounded(5, -1)
def test_non_integer_patients(self):
"""Test ValueError: Non-integer patients."""
with self.assertRaisesRegex(ValueError, "n_patients must be a non-negative integer."):
generate_evenly_distributed_schedule_intervals_rounded(2.5, 5) # type: ignore
def test_non_integer_intervals(self):
"""Test ValueError: Non-integer intervals."""
with self.assertRaisesRegex(ValueError, "t_intervals must be a non-negative integer."):
generate_evenly_distributed_schedule_intervals_rounded(5, 10.5) # type: ignore
def test_zero_intervals_positive_patients(self):
"""Test ValueError: 0 intervals but more than 0 patients."""
with self.assertRaisesRegex(ValueError, "Cannot schedule"):
generate_evenly_distributed_schedule_intervals_rounded(1, 0)
# --- How to run the tests ---
if __name__ == '__main__':
unittest.main(argv=['first-arg-is-ignored'], exit=False)
# --- Main computation function ---
N_patients = 24
T_intervals = 48
d_interval_len = 10
max_s_time = 30
l_target_avg_service_time = 14.0
i_sorting_split = 10
v_star_matrix = get_v_star(T_intervals)
s_dist = generate_weighted_list(max_s_time, l_target_avg_service_time, i_sorting_split)
if s_dist is None:
raise ValueError("Failed to generate service time distribution.")
def compute_schedules_and_objectives(q_no_show: float, w_weight: float):
"""Compute schedules and objectives for given parameters"""
convolutions_dict = compute_convolutions(s_dist.tolist(), N_patients, q_no_show)
distribution = generate_start_tail_distribution(N_patients, T_intervals)
schedules = []
objective_values = []
for start, tail in distribution:
schedule = [start]
center = generate_evenly_distributed_schedule_intervals(N_patients - start - tail, T_intervals - 2)
if start == N_patients:
print(center)
if center is None:
raise ValueError("Failed to generate center schedule.")
schedule.extend(center)
schedule.append(tail)
schedules.append(schedule)
ewt, esp = calculate_objective_serv_time_lookup(schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Create 3x3 subplot grid ---
q_values = [0.1, 0.15, 0.2]
w_values = [0.1, 0.5, 0.9]
compute_schedules_and_objectives(0.1, 0.1)
# --- Main computation function ---
N_patients = 24
T_intervals = 48
d_interval_len = 10
max_s_time = 30
l_target_avg_service_time = 14.0
i_sorting_split = 10
v_star_matrix = get_v_star(T_intervals)
s_dist = generate_weighted_list(max_s_time, l_target_avg_service_time, i_sorting_split)
if s_dist is None:
raise ValueError("Failed to generate service time distribution.")
def compute_schedules_and_objectives(q_no_show: float, w_weight: float):
"""Compute schedules and objectives for given parameters"""
convolutions_dict = compute_convolutions(s_dist.tolist(), N_patients, q_no_show)
distribution = generate_start_tail_distribution(N_patients, T_intervals)
schedules = []
objective_values = []
for start, tail in distribution:
schedule = [start]
center = generate_evenly_distributed_schedule_intervals(N_patients - start - tail, T_intervals - 2)
if center is None:
raise ValueError("Failed to generate center schedule.")
schedule.extend(center)
schedule.append(tail)
schedules.append(schedule)
ewt, esp = calculate_objective_serv_time_lookup(schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Create 3x3 subplot grid ---
q_values = [0.1, 0.15, 0.2]
w_values = [0.1, 0.5, 0.9]
compute_schedules_and_objectives(0.1, 0.1)
# --- Main computation function ---
N_patients = 48
def compute_schedules_and_objectives(q_no_show: float, w_weight: float):
"""Compute schedules and objectives for given parameters"""
convolutions_dict = compute_convolutions(s_dist.tolist(), N_patients, q_no_show)
distribution = generate_start_tail_distribution(N_patients, T_intervals)
schedules = []
objective_values = []
for start, tail in distribution:
schedule = [start]
center = generate_evenly_distributed_schedule_intervals(N_patients - start - tail, T_intervals - 2)
if center is None:
raise ValueError("Failed to generate center schedule.")
schedule.extend(center)
schedule.append(tail)
schedules.append(schedule)
ewt, esp = calculate_objective_serv_time_lookup(schedule, d_interval_len, convolutions_dict)
objective_value = w_weight * ewt + (1 - w_weight) * esp
objective_values.append(objective_value)
return schedules, objective_values
# --- Create 3x3 subplot grid ---
q_values = [0.1, 0.15, 0.2]
w_values = [0.1, 0.5, 0.9]
# Create subplots with 3D scenes
# Calculate initial titles first for the 2x2 grid
initial_titles = [f'q={q:.2f}, w={w:.1f}' for w in w_values for q in q_values]
fig = make_subplots(
rows=2, cols=2, # Defining the 2x2 grid
specs=[[{'type': 'scatter3d'}] * 2] * 2, # Specifying 3D type for 2x2 grid
subplot_titles=initial_titles, # Setting initial titles for the 2x2 grid
horizontal_spacing=0.05,
vertical_spacing=0.12
)
# Global color scale limits for consistency
global_z_min = float('inf')
global_z_max = float('-inf')
# First pass: compute all data and find global min/max for consistent coloring
all_data = {}
for i, w in enumerate(w_values):
for j, q in enumerate(q_values):
schedules, objective_values = compute_schedules_and_objectives(q, w)
all_data[(i, j)] = (schedules, objective_values)
if objective_values: # Check if list is not empty
global_z_min = min(global_z_min, min(objective_values))
global_z_max = max(global_z_max, max(objective_values))
# Ensure min/max are not inf if no data was generated
if global_z_min == float('inf'): global_z_min = 0
if global_z_max == float('-inf'): global_z_max = 1
# Second pass: create plots
for i, w in enumerate(w_values):
for j, q in enumerate(q_values):
schedules, objective_values = all_data[(i, j)]
plot_index = i * 2 + j # Index for 2x2 grid (0 to 3)
if not schedules:
fig.layout.annotations[plot_index].text = f'q={q:.2f}, w={w:.1f}<br><sub>No Data</sub>'
continue
x = [schedule[0] if schedule else 0 for schedule in schedules]
y = [schedule[-1] if schedule else 0 for schedule in schedules]
z = objective_values
min_index = z.index(min(z))
min_obj = z[min_index]
fig.layout.annotations[plot_index].text = f'q={q:.2f}, w={w:.1f}<br><sub>Min: {min_obj:.4f}</sub>'
schedules_wrapped = [textwrap.wrap(str(schedule), width=75) for schedule in schedules]
formatted_schedules = ["<br>".join(schedule_lines) for schedule_lines in schedules_wrapped]
hover_texts = [f"Sch: {f_schedule}, N: {sum(schedule)}<br>Obj: {obj_val:.4f}<br>"
for schedule, f_schedule, obj_val in zip(schedules, formatted_schedules, z)]
normal_indices = [idx for idx in range(len(z)) if idx != min_index]
normal_x = [x[idx] for idx in normal_indices]
normal_y = [y[idx] for idx in normal_indices]
normal_z = [z[idx] for idx in normal_indices]
normal_hover = [hover_texts[idx] for idx in normal_indices]
min_x = [x[min_index]]
min_y = [y[min_index]]
min_z = [z[min_index]]
min_hover = [hover_texts[min_index]]
show_colorbar = i == 0 and j == 1 # Top-right plot for colorbar
fig.add_trace(
go.Scatter3d(
x=normal_x, y=normal_y, z=normal_z, mode='markers',
marker=dict(
size=4, color=normal_z, colorscale='Viridis', opacity=0.7,
cmin=global_z_min, cmax=global_z_max,
colorbar=dict(title='Objective') if show_colorbar else None,
showscale=show_colorbar
),
name=f'Other (q={q:.2f}, w={w:.1f})',
hovertemplate='%{hovertext}<extra></extra>',
hovertext=normal_hover, showlegend=False
),
row=i + 1, col=j + 1 # Correct mapping for 2x2
)
fig.add_trace(
go.Scatter3d(
x=min_x, y=min_y, z=min_z, mode='markers',
marker=dict(size=6, color='red', opacity=1.0),
name=f'Min (q={q:.2f}, w={w:.1f})',
hovertemplate='%{hovertext}<extra></extra>',
hovertext=min_hover, showlegend=False
),
row=i + 1, col=j + 1 # Correct mapping for 2x2
)
# Update layout for better aesthetics
fig.update_layout(
title=dict(
text='3D Analysis: Schedule Optimization Across Different Parameters<br><sub>Rows: w (weight), Columns: q (no-show probability)</sub>',
x=0.5, y=0.98, font=dict(size=16)
),
height=900, width=1000,
margin=dict(t=100, b=50, l=50, r=50),
font=dict(size=10)
)
# Update 3D scene properties for all 4 subplots
scene_count = 1
for i in range(1, 3): # Loop through 2 rows
for j in range(1, 3): # Loop through 2 columns
scene_name = f'scene{scene_count}' if scene_count > 1 else 'scene'
fig.update_layout(**{
scene_name: dict(
xaxis_title='First Elem', yaxis_title='Last Elem', zaxis_title='Objective',
camera=dict(eye=dict(x=-1.5, y=-1.5, z=1.5)),
xaxis=dict(range=[0, 1.1]), yaxis=dict(range=[0, 1.1])
)
})
scene_count += 1
fig.show()
