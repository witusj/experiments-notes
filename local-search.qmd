---
jupyter: python3
---

# `local_search` {.unnumbered}

This notebook provides documentation for the function `local_search`, which performs a local search to optimize a scheduling solution. The function iteratively explores the neighborhood of the current best solution by switching a given number of patients. It utilizes precomputed convolution results and a set of adjustment vectors (`v_star`) to evaluate and improve the objective function.

## Function Documentation

`local_search(x: Union[List[int], np.ndarray], d: int, convolutions: Dict[int, np.ndarray], w: float, v_star: np.ndarray, size: int = 2, echo: bool = False) -> Tuple[np.ndarray, float]`

#### Description

The `local_search` function optimizes a schedule by iteratively exploring its neighborhood. Starting with an initial solution `x`, the function computes its objective value using the precomputed convolutions of the service time probability mass function. The neighborhood is generated by combining adjustment vectors from `v_star` (using a powerset-based approach) and filtering out candidates that contain negative values. The search continues until no further improvement is found for neighborhoods up to the specified `size`. The objective function combines expected average waiting time per patient and spillover time weighted by `w`.

#### Parameters

- **x** (`Union[List[int], np.ndarray]`):  
  The initial solution vector representing the schedule. It can be provided as a list of integers or as a NumPy array.

- **d** (`int`):  
  The duration threshold for a time slot. It is used to adjust the service process and waiting time distribution.

- **convolutions** (`Dict[int, np.ndarray]`):  
  A dictionary containing precomputed convolutions of the service time PMF. The key `1` represents the adjusted service time distribution, and other keys represent the convolution for the corresponding number of scheduled patients.

- **w** (`float`):  
  The weighting factor for combining the two performance objectives: expected waiting time and expected spillover time.

- **v_star** (`np.ndarray`):  
  A 2D NumPy array of adjustment vectors. Each row in `v_star` is used to modify the current solution vector in order to generate its neighborhood.

- **size** (`int`, optional):  
  The maximum number of patients to switch (i.e., the size of the neighborhood to explore) during the local search. Defaults to `2`.

- **echo** (`bool`, optional):  
  A flag that, when set to `True`, prints progress and debugging messages during the search process. Defaults to `False`.

#### Returns

- **`Tuple[np.ndarray, float]`**:  
  A tuple containing:
  - The best solution found as a 1D NumPy array.
  - The corresponding cost (objective value) as a float.

#### Example

```{python}
import numpy as np
from functions import local_search, calculate_objective_serv_time_lookup, compute_convolutions, get_v_star, powerset

# Example schedule: initial solution vector
x_initial = [3, 2, 1, 0]
T = len(x_initial)
N = sum(x_initial)

# Duration threshold for a time slot
d = 5

# Example probability mass function and no-show probability
service_time = np.zeros(11)
service_time[3] = 0.2
service_time[5] = 0.3
service_time[8] = 0.5
q = 0.1

# Compute convolutions (precomputed service time distributions)
convs = compute_convolutions(service_time, N=N, q=q)

# Weighting factor for the objective function
w = 0.5

# Generate adjustment vectors for the schedule (v_star)
v_star = get_v_star(len(x_initial))

# Perform local search to optimize the schedule
best_solution, best_cost = local_search(x_initial, d, convs, w, v_star, size=T, echo=True)

print("Best Solution:", best_solution)
print("Best Cost:", best_cost)
```

```{python}
import unittest
import numpy as np
from functions import local_search, compute_convolutions, get_v_star

class TestLocalSearch(unittest.TestCase):
    def test_local_search_improvement(self):
        # Set up a simple test with a known schedule and parameters
        x_initial = [3, 2, 1, 0]
        T = len(x_initial)
        d = 5
        service_time = np.zeros(11)
        service_time[3] = 0.2
        service_time[5] = 0.3
        service_time[8] = 0.5
        q = 0.1
        convs = compute_convolutions(service_time, N=N, q=q)
        w = 0.5
        v_star = get_v_star(len(x_initial))
        
        # Perform local search
        best_solution, best_cost = local_search(x_initial, d, convs, w, v_star, size=T, echo=False)
        
        # Verify that the returned solution has the same length as the initial schedule
        self.assertEqual(len(best_solution), len(x_initial), "The optimized solution should have the same length as the initial solution.")
        
        # Check that the cost is a float and that a solution is returned
        self.assertIsInstance(best_cost, float, "Cost should be a float value.")

if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)
```