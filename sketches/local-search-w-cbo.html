<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Combinatorial Bayesian Optimization Experiments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="local-search-w-cbo_files/libs/clipboard/clipboard.min.js"></script>
<script src="local-search-w-cbo_files/libs/quarto-html/quarto.js"></script>
<script src="local-search-w-cbo_files/libs/quarto-html/popper.min.js"></script>
<script src="local-search-w-cbo_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="local-search-w-cbo_files/libs/quarto-html/anchor.min.js"></script>
<link href="local-search-w-cbo_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="local-search-w-cbo_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="local-search-w-cbo_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="local-search-w-cbo_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="local-search-w-cbo_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Combinatorial Bayesian Optimization Experiments</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="objective" class="level2">
<h2 class="anchored" data-anchor-id="objective">Objective</h2>
<p>The objective of this experiment is to evaluate and compare the performance of two distinct Combinatorial Bayesian Optimization (CBO) strategies for an outpatient appointment scheduling problem. We investigate:</p>
<ol type="1">
<li>CBO utilizing Expected Improvement (EI) as the acquisition function.</li>
<li>CBO utilizing Lower Confidence Bound (LCB) as the acquisition function with a fixed kappa (<span class="math inline">\(\kappa\)</span>) value.</li>
</ol>
<p>We aim to determine which strategy is most effective in identifying an optimal or near-optimal schedule, as measured by the objective function value, leveraging dictionary-based embeddings for the high-dimensional combinatorial space <span class="citation" data-cites="deshwal_bayesian_2023">[@deshwal_bayesian_2023]</span>.</p>
</section>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>We consider an outpatient appointment scheduling problem as described by <span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span> where the schedule is represented by a vector <span class="math inline">\(\mathbf{x} = (x_0, x_1, \ldots, x_{T-1})^T\)</span>. This vector comprises <span class="math inline">\(T\)</span> components, where <span class="math inline">\(x_j\)</span> denotes the non-negative allocation (number of patients) to time slot <span class="math inline">\(j\)</span>, for <span class="math inline">\(j = 0, \ldots, T-1\)</span>. A fundamental constraint is that the total allocation across all time slots must equal a fixed constant <span class="math inline">\(N\)</span>: <span class="math display">\[\sum_{j=0}^{T-1} x_j = N\]</span> We require <span class="math inline">\(x_j \ge 0\)</span> for all <span class="math inline">\(j = 0, \ldots, T-1\)</span>. Consequently, a valid schedule <span class="math inline">\(\mathbf{x}\)</span> belongs to the feasible set <span class="math inline">\(\mathcal{F} = \{ \mathbf{z} \in \mathbb{D}^{T} \mid \sum_{j=0}^{T-1} z_j = N, z_j \ge 0 \text{ for all } j\}\)</span>, where <span class="math inline">\(\mathbb{D}\)</span> is the set of non-negative integers (<span class="math inline">\(\mathbb{Z}_{\ge 0}\)</span>).</p>
<p><span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span> define a neighborhood structure for local search based on perturbation vectors derived from a set of <span class="math inline">\(T\)</span> basis change vectors, <span class="math inline">\(v_i \in \mathbb{D}^{T}\)</span>, for <span class="math inline">\(i = 0, \ldots, T-1\)</span>. These basis vectors represent elementary shifts of allocation between time slots:</p>
<ul>
<li><span class="math inline">\(v_0 = (-1, 0, \ldots, 0, 1)\)</span> (Shift unit <em>from</em> slot 0 <em>to</em> slot <span class="math inline">\(T-1\)</span>)</li>
<li><span class="math inline">\(v_1 = (1, -1, 0, \ldots, 0)\)</span> (Shift unit <em>from</em> slot 1 <em>to</em> slot 0)</li>
<li><span class="math inline">\(v_i = (0, \ldots, 0, \underbrace{1}_{\text{pos } i-1}, \underbrace{-1}_{\text{pos } i}, 0, \ldots, 0)\)</span> for <span class="math inline">\(i = 2, \ldots, T-1\)</span> (Shift unit <em>from</em> slot <span class="math inline">\(i\)</span> <em>to</em> slot <span class="math inline">\(i-1\)</span>)</li>
</ul>
<p>A key property of these basis vectors is that the sum of components for each vector is zero: <span class="math inline">\(\sum_{j=0}^{T-1} v_{ij} = 0\)</span> for all <span class="math inline">\(i=0, \ldots, T-1\)</span>.</p>
<p>Perturbations are constructed using a binary selection vector <span class="math inline">\(\mathbf{U} = (u_0, u_1, \ldots, u_{T-1})\)</span>, where <span class="math inline">\(u_i \in \{0, 1\}\)</span>. Each <span class="math inline">\(u_i\)</span> indicates whether the basis change <span class="math inline">\(v_i\)</span> is included in the perturbation. The resulting perturbation vector <span class="math inline">\(\mathbf{r}(\mathbf{U}) \in \mathbb{D}^{T}\)</span> is the linear combination: <span class="math display">\[\mathbf{r}(\mathbf{U}) := \sum_{i=0}^{T-1} u_i v_i\]</span></p>
<p>Since each <span class="math inline">\(v_i\)</span> sums to zero, any perturbation <span class="math inline">\(\mathbf{r}(\mathbf{U})\)</span> also sums to zero: <span class="math inline">\(\sum_{j=0}^{T-1} r_j(\mathbf{U}) = 0\)</span>. This ensures that applying such a perturbation to a valid schedule <span class="math inline">\(\mathbf{x}\)</span> preserves the total allocation <span class="math inline">\(N\)</span>.</p>
<p>The neighborhood of a schedule <span class="math inline">\(\mathbf{x} \in \mathcal{F}\)</span>, denoted by <span class="math inline">\(\mathcal{N}(\mathbf{x})\)</span>, comprises all distinct, feasible schedules <span class="math inline">\(\mathbf{x}'\)</span> reachable by applying a non-zero perturbation <span class="math inline">\(\mathbf{r}(\mathbf{U})\)</span> (<span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span>, use a slightly different but related neighborhood definition based on combinations of these basis vectors).</p>
<p>The objective function to be minimized is a weighted sum of Expected Waiting Time (EWT) and Expected Staff Penalty (ESP), as defined by <span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span>: <span class="math display">\[C(\mathbf{x}) = w \cdot EWT(\mathbf{x}) + (1-w) \cdot ESP(\mathbf{x})\]</span> <span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span> prove that this objective function is multimodular, which guarantees that a local search algorithm using their defined neighborhood converges to the global optimum.</p>
<p>However, evaluating <span class="math inline">\(C(\mathbf{x})\)</span> can be computationally expensive, especially for large <span class="math inline">\(N\)</span> and <span class="math inline">\(T\)</span>. Furthermore, the search space defined by the binary vectors <span class="math inline">\(\mathbf{U}\)</span> is high-dimensional (<span class="math inline">\(2^T - 2\)</span> possibilities, excluding <span class="math inline">\(\mathbf{0}\)</span> and <span class="math inline">\(\mathbf{1}\)</span>). Bayesian Optimization (BO) is a suitable framework for optimizing such expensive black-box functions. Standard BO methods often struggle with high-dimensional combinatorial spaces. <span class="citation" data-cites="deshwal_bayesian_2023">@deshwal_bayesian_2023</span> propose a method using dictionary-based embeddings (Hamming Embedding via Dictionaries - HED) to map the high-dimensional binary space of <span class="math inline">\(\mathbf{U}\)</span> vectors into a lower-dimensional continuous space, where standard Gaussian Process (GP) models can be effectively applied. This experiment applies the HED approach within a BO framework to solve the scheduling problem formulated by <span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span>.</p>
</section>
<section id="hypothesis" class="level2">
<h2 class="anchored" data-anchor-id="hypothesis">Hypothesis</h2>
<p>We hypothesize that:</p>
<ol type="1">
<li>Both CBO strategies, leveraging the HED embedding <span class="citation" data-cites="deshwal_bayesian_2023">[@deshwal_bayesian_2023]</span>, will be capable of finding schedules superior to the initial schedule derived from the Bailey-Welch method (@).</li>
<li>CBO strategies employing Lower Confidence Bound (LCB) may exhibit superior performance or faster convergence compared to Expected Improvement (EI), due to the explicit exploration-exploitation trade-off inherent in LCB.</li>
</ol>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<section id="tools-and-materials" class="level3">
<h3 class="anchored" data-anchor-id="tools-and-materials">Tools and Materials</h3>
<ul>
<li>Programming Language: Python 3</li>
<li>Core Libraries: NumPy, SciPy</li>
<li>Machine Learning: Scikit-learn (for <code>GaussianProcessRegressor</code>, <code>MinMaxScaler</code>)</li>
<li>Data Structures: Standard Python lists and dictionaries, NumPy arrays.</li>
<li>Imported functions: <code>bailey_welch_schedule</code>, <code>get_v_star</code>, <code>compute_convolutions</code>, <code>calculate_objective_serv_time_lookup</code> (implementing the logic from <span class="citation" data-cites="bailey1952study">@bailey1952study</span>, assumed to be in an external <code>functions.py</code> file).</li>
</ul>
</section>
<section id="experimental-design" class="level3">
<h3 class="anchored" data-anchor-id="experimental-design">Experimental Design</h3>
<p>Three distinct Bayesian optimization experiments are conducted, applying the HED embedding approach <span class="citation" data-cites="deshwal_bayesian_2023">[@deshwal_bayesian_2023]</span> to the scheduling problem:</p>
<ol type="1">
<li><strong>Experiment 1: Expected Improvement (EI)</strong>
<ul>
<li>Acquisition Function: Expected Improvement.</li>
<li>Objective: Minimize <span class="math inline">\(C(\mathbf{x})\)</span> by iteratively selecting candidate vectors <span class="math inline">\(\mathbf{U}\)</span> (via their embeddings) that maximize the EI.</li>
</ul></li>
<li><strong>Experiment 2: Lower Confidence Bound (LCB) - Fixed Kappa</strong>
<ul>
<li>Acquisition Function: Lower Confidence Bound.</li>
<li>Objective: Minimize <span class="math inline">\(C(\mathbf{x})\)</span> using a fixed <code>kappa</code> (<span class="math inline">\(\kappa\)</span>) value in the LCB acquisition function applied to the GP model over the embedded space.</li>
</ul></li>
</ol>
<p>For all experiments, Hamming Distance Embedding (HED) with a “diverse random” dictionary construction strategy <span class="citation" data-cites="deshwal_bayesian_2023">[@deshwal_bayesian_2023]</span> is employed to map the binary perturbation vectors <span class="math inline">\(\mathbf{U}\)</span> to a continuous embedding space. A Gaussian Process (GP) model with Automatic Relevance Determination (ARD) kernels models the (negative) objective function in this embedded space.</p>
</section>
<section id="variables" class="level3">
<h3 class="anchored" data-anchor-id="variables">Variables</h3>
<ul>
<li><strong>Independent Variables</strong>:
<ul>
<li>Type of acquisition function (EI, LCB).</li>
<li>The specific binary perturbation vector <span class="math inline">\(\mathbf{U}\)</span> selected in each iteration (chosen via optimizing the acquisition function over the embedded space).</li>
</ul></li>
<li><strong>Dependent Variables</strong>:
<ul>
<li>The objective function value <span class="math inline">\(C(\mathbf{x}')\)</span> for the resulting schedule <span class="math inline">\(\mathbf{x}' = \mathbf{x} + \mathbf{r}(\mathbf{U})\)</span> (calculated using the method from <span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span>).</li>
<li>The best objective function value found throughout the optimization process.</li>
</ul></li>
</ul>
</section>
<section id="data-collection" class="level3">
<h3 class="anchored" data-anchor-id="data-collection">Data Collection</h3>
<p>Data, comprising evaluated pairs <span class="math inline">\((\mathbf{U}, C(\mathbf{x}'))\)</span>, is collected iteratively:</p>
<ul>
<li>An initial set of <code>N_INITIAL</code> randomly generated <span class="math inline">\(\mathbf{U}\)</span> vectors is evaluated.</li>
<li>In each of the subsequent <code>N_ITERATIONS</code>, <code>BATCH_SIZE_q</code> new <span class="math inline">\(\mathbf{U}\)</span> vectors are selected by optimizing the respective acquisition function over <code>NUM_CANDIDATES_Acqf</code> randomly generated candidate vectors in the original binary space (evaluated via their embeddings). These newly selected vectors are then evaluated, and the results are added to the dataset.</li>
</ul>
</section>
<section id="sample-size-and-selection" class="level3">
<h3 class="anchored" data-anchor-id="sample-size-and-selection">Sample Size and Selection</h3>
<ul>
<li><strong>N_INITIAL</strong>: 20 (number of initial random evaluations)</li>
<li><strong>N_ITERATIONS</strong>: 20 (number of Bayesian optimization iterations)</li>
<li><strong>BATCH_SIZE_q</strong>: 5 (number of candidates selected and evaluated per iteration)</li>
<li><strong>NUM_CANDIDATES_Acqf</strong>: <span class="math inline">\(T \times 1024 = 20 \times 1024 = 20480\)</span> (number of random candidates generated for optimizing the acquisition function in each iteration)</li>
<li><strong>m</strong>: 128 (dimensionality of the HED embedding space, following <span class="citation" data-cites="deshwal_bayesian_2023">@deshwal_bayesian_2023</span>)</li>
</ul>
<p>The selection of new points for evaluation is guided by the respective acquisition function (EI or LCB) optimized over the embedded space representation of candidate <span class="math inline">\(\mathbf{U}\)</span> vectors.</p>
</section>
<section id="experimental-procedure" class="level3">
<h3 class="anchored" data-anchor-id="experimental-procedure">Experimental Procedure</h3>
<section id="setup" class="level4">
<h4 class="anchored" data-anchor-id="setup">1. Setup</h4>
<p>Import necessary libraries and configure warning filters.</p>
<div id="2555a44d" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Core Libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Dict, Tuple, Callable, Optional, Union, Any, Iterable</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Scikit-learn for GP, Scaling, and potentially acquisition functions</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process <span class="im">import</span> GaussianProcessRegressor</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process.kernels <span class="im">import</span> Matern, ConstantKernel, WhiteKernel</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> MinMaxScaler</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.exceptions <span class="im">import</span> ConvergenceWarning</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># SciPy for statistics (needed for Expected Improvement calculation)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functions <span class="im">import</span> bailey_welch_schedule, get_v_star, compute_convolutions, calculate_objective_serv_time_lookup</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter warnings</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span><span class="pp">RuntimeWarning</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span>ConvergenceWarning) <span class="co"># GP fitting might not always converge perfectly</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="constants" class="level4">
<h4 class="anchored" data-anchor-id="constants">2. Constants</h4>
<p>Definition of problem parameters and initial configuration.</p>
<div id="f1b95459" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Problem Definition ---</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Fixed Data (Use your actual data)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">24</span> <span class="co"># Total number of patients</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">20</span> <span class="co"># Dimension of the binary vector U</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="dv">10</span> <span class="co"># Length of each interval</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>max_s <span class="op">=</span> <span class="dv">30</span> <span class="co"># Maximum service time</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.20</span> <span class="co"># Probability of a scheduled patient not showing up</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="fl">0.1</span> <span class="co"># Weight for the waiting time in objective function</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="dv">14</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>v_star <span class="op">=</span> get_v_star(T) <span class="co"># Get the V* matrix(T x T)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Create service time distribution</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_weighted_list(max_s: <span class="bu">int</span>, l: <span class="bu">float</span>, i: <span class="bu">int</span>) <span class="op">-&gt;</span> Optional[np.ndarray]:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates a service time probability distribution using optimization.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">    This function creates a discrete probability distribution over max_s possible</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">    service times (from 1 to max_s). It uses optimization (SLSQP) to find a</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">    distribution whose weighted average service time is as close as possible</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">    to a target value 'l', subject to the constraint that the probabilities</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">    sum to 1 and each probability is between 0 and 1.</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co">    After finding the distribution, it sorts the probabilities: the first 'i'</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co">    probabilities (corresponding to service times 1 to i) are sorted in</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co">    ascending order, and the remaining probabilities (service times i+1 to max_s)</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co">    are sorted in descending order.</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="co">    Note:</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co">        - Requires NumPy and SciPy libraries (specifically scipy.optimize.minimize).</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co">        max_s (int): Maximum service time parameter (number of probability bins).</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co">                     Must be a positive integer.</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="co">        l (float): The target weighted average service time for the distribution.</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co">                   Must be between 1 and max_s, inclusive.</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co">        i (int): The index determining the sorting split point. Probabilities</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co">                 for service times 1 to 'i' are sorted ascendingly, and</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="co">                 probabilities for service times 'i+1' to 'max_s' are sorted</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co">                 descendingly. Must be between 1 and max_s-1 for meaningful sorting.</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co">        numpy.ndarray: An array of size max_s+1. The first element (index 0) is 0.</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="co">                       Elements from index 1 to max_s represent the calculated</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co">                       and sorted probability distribution, summing to 1.</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co">                       Returns None if optimization fails or inputs are invalid.</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Input Validation ---</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(max_s, <span class="bu">int</span>) <span class="kw">or</span> max_s <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error: max_s must be a positive integer, but got </span><span class="sc">{</span>max_s<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(l, (<span class="bu">int</span>, <span class="bu">float</span>)) <span class="kw">or</span> <span class="kw">not</span> (<span class="dv">1</span> <span class="op">&lt;=</span> l <span class="op">&lt;=</span> max_s):</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error: Target average 'l' (</span><span class="sc">{</span>l<span class="sc">}</span><span class="ss">) must be between 1 and max_s (</span><span class="sc">{</span>max_s<span class="sc">}</span><span class="ss">)."</span>)</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(i, <span class="bu">int</span>) <span class="kw">or</span> <span class="kw">not</span> (<span class="dv">0</span> <span class="op">&lt;</span> i <span class="op">&lt;</span> max_s):</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error: Sorting index 'i' (</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">) must be between 1 and max_s-1 (</span><span class="sc">{</span>max_s<span class="op">-</span><span class="dv">1</span><span class="sc">}</span><span class="ss">)."</span>)</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If clamping is desired instead of error:</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"Warning: Index 'i' ({i}) is outside the valid range (1 to {max_s-1}). Clamping i.")</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># i = max(1, min(i, max_s - 1))</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span> <span class="co"># Strict check based on docstring requirement</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Inner helper function for optimization ---</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> objective(x: np.ndarray) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Objective function: Squared difference between weighted average and target l."""</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># x represents probabilities P(1) to P(max_s)</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        service_times <span class="op">=</span> np.arange(<span class="dv">1</span>, max_s <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>        weighted_avg <span class="op">=</span> np.dot(service_times, x) <span class="co"># Equivalent to sum(k * P(k) for k=1 to max_s)</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (weighted_avg <span class="op">-</span> l) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Constraints for optimization ---</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Constraint 1: The sum of the probabilities must be 1</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    constraints <span class="op">=</span> ({</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>        <span class="st">'type'</span>: <span class="st">'eq'</span>,</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>        <span class="st">'fun'</span>: <span class="kw">lambda</span> x: np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="fl">1.0</span> <span class="co"># Ensure float comparison</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bounds: Each probability value x[k] must be between 0 and 1</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Creates a list of max_s tuples, e.g., [(0, 1), (0, 1), ..., (0, 1)]</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>    bounds <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>)] <span class="op">*</span> max_s</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial guess: Use Dirichlet distribution to get a random distribution that sums to 1.</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Provides a starting point for the optimizer. np.ones(max_s) gives equal weights initially.</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>    initial_guess <span class="op">=</span> np.random.dirichlet(np.ones(max_s))</span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Perform Optimization ---</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> minimize(</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>            objective,</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>            initial_guess,</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">'SLSQP'</span>,</span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>            bounds<span class="op">=</span>bounds,</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>            constraints<span class="op">=</span>constraints,</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>            <span class="co"># options={'disp': False} # Set True for detailed optimizer output</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if optimization was successful</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> result.success:</span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Warning: Optimization failed! Message: </span><span class="sc">{</span>result<span class="sc">.</span>message<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Optionally print result object for more details: print(result)</span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span> <span class="co"># Indicate failure</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The optimized probabilities (P(1) to P(max_s))</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>        optimized_probs <span class="op">=</span> result.x</span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- Post-process: Correct potential floating point inaccuracies ---</span></span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ensure probabilities are non-negative and sum *exactly* to 1</span></span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>        optimized_probs[optimized_probs <span class="op">&lt;</span> <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span> <span class="co"># Clamp small negatives to 0</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> np.<span class="bu">sum</span>(optimized_probs)</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> np.isclose(current_sum, <span class="fl">1.0</span>):</span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sum <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># Avoid division by zero</span></span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>                 optimized_probs <span class="op">/=</span> current_sum <span class="co"># Normalize to sum to 1</span></span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="st">"Warning: Optimization resulted in zero sum probabilities after clamping negatives."</span>)</span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a>                 <span class="co"># Handle this case - maybe return uniform distribution or None</span></span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>                 <span class="cf">return</span> <span class="va">None</span> <span class="co"># Or return uniform: np.ones(max_s) / max_s</span></span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"An error occurred during optimization: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Reorder the probabilities based on the index 'i' ---</span></span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Split the probabilities P(1)...P(i) and P(i+1)...P(max_s)</span></span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note: Python slicing is exclusive of the end index, array indexing is 0-based.</span></span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a>    <span class="co"># result.x[0] corresponds to P(1), result.x[i-1] to P(i).</span></span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a>    <span class="co"># result.x[i] corresponds to P(i+1), result.x[max_s-1] to P(max_s).</span></span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a>    first_part_probs <span class="op">=</span> optimized_probs[:i]   <span class="co"># Probabilities P(1) to P(i)</span></span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a>    second_part_probs <span class="op">=</span> optimized_probs[i:]  <span class="co"># Probabilities P(i+1) to P(max_s)</span></span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort the first part ascending, the second part descending</span></span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a>    sorted_first_part <span class="op">=</span> np.sort(first_part_probs)</span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a>    sorted_second_part <span class="op">=</span> np.sort(second_part_probs)[::<span class="op">-</span><span class="dv">1</span>] <span class="co"># [::-1] reverses</span></span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Create final output array ---</span></span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Array of size max_s + 1, initialized to zeros. Index 0 unused.</span></span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> np.zeros(max_s <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign the sorted probabilities back into the correct slots (index 1 onwards)</span></span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a>    values[<span class="dv">1</span> : i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> sorted_first_part      <span class="co"># Assign P(1)...P(i)</span></span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a>    values[i <span class="op">+</span> <span class="dv">1</span> : max_s <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> sorted_second_part <span class="co"># Assign P(i+1)...P(max_s)</span></span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Final check on sum after potential normalization/sorting</span></span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.isclose(np.<span class="bu">sum</span>(values[<span class="dv">1</span>:]), <span class="fl">1.0</span>):</span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a>         <span class="bu">print</span>(<span class="ss">f"Warning: Final distribution sum is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(values[<span class="dv">1</span>:])<span class="sc">}</span><span class="ss">, not 1.0. Check logic."</span>)</span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the final array with the sorted probability distribution</span></span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> values</span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span>  <span class="co"># First 5 highest values in ascending order, rest in descending order</span></span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> generate_weighted_list(max_s, l, i)</span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Average generated service time: </span><span class="sc">{</span>np<span class="sc">.</span>dot(np.arange(<span class="bu">len</span>(s)), s)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a>convolutions <span class="op">=</span> compute_convolutions(s, N, q)</span>
<span id="cb2-153"><a href="#cb2-153" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array(bailey_welch_schedule(T, d, N, s))</span>
<span id="cb2-154"><a href="#cb2-154" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial schedule: </span><span class="sc">{</span>X<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-155"><a href="#cb2-155" aria-hidden="true" tabindex="-1"></a><span class="co"># Objective Function Calculation</span></span>
<span id="cb2-156"><a href="#cb2-156" aria-hidden="true" tabindex="-1"></a>LARGE_PENALTY <span class="op">=</span> <span class="fl">1e10</span> <span class="co"># Penalty for infeasible solutions</span></span>
<span id="cb2-157"><a href="#cb2-157" aria-hidden="true" tabindex="-1"></a>ewt, esp <span class="op">=</span> calculate_objective_serv_time_lookup(X, d, convolutions)</span>
<span id="cb2-158"><a href="#cb2-158" aria-hidden="true" tabindex="-1"></a>initial_objective_value <span class="op">=</span> w <span class="op">*</span> ewt <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> esp</span>
<span id="cb2-159"><a href="#cb2-159" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial objective value: </span><span class="sc">{</span>initial_objective_value<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Average generated service time: 12.492777070904665
Initial schedule: [2 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 7]
Initial objective value: 105.9330971329289</code></pre>
</div>
</div>
</section>
<section id="common-functions-objective-evaluation-and-hed" class="level4">
<h4 class="anchored" data-anchor-id="common-functions-objective-evaluation-and-hed">3. Common Functions (Objective Evaluation and HED)</h4>
<p>Objective evaluation implements <span class="math inline">\(C(\mathbf{x})\)</span> from <span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span>. HED implementation follows <span class="citation" data-cites="deshwal_bayesian_2023">@deshwal_bayesian_2023</span>.</p>
<div id="baea5b51" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_objective(U_np, X_vec, v_star, convolutions, d, w):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Target function: Evaluates objective for a single binary numpy array U.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns a float.</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input validation (same as before)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(U_np, np.ndarray):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">"Input U must be a numpy array"</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_np.ndim <span class="op">!=</span> <span class="dv">1</span>:</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>         <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input U must be 1-dimensional"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_np.shape[<span class="dv">0</span>] <span class="op">!=</span> v_star.shape[<span class="dv">0</span>]:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>         <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Dimension mismatch: U length </span><span class="sc">{</span>U_np<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> != V* rows </span><span class="sc">{</span>v_star<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> X_vec.shape[<span class="dv">0</span>] <span class="op">!=</span> v_star.shape[<span class="dv">1</span>]:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>         <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Dimension mismatch: X length must match V* columns."</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.<span class="bu">all</span>((U_np <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (U_np <span class="op">==</span> <span class="dv">1</span>)):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>         <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input U must be binary (0s and 1s)."</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate Y based on selected rows of V_star</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    V_sum <span class="op">=</span> np.<span class="bu">sum</span>(v_star[U_np <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> X_vec <span class="op">+</span> V_sum</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check feasibility and calculate objective</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.<span class="bu">all</span>(Y <span class="op">&gt;=</span> <span class="dv">0</span>):</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        ewt, esp <span class="op">=</span> calculate_objective_serv_time_lookup(Y, d, convolutions)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        objective_value <span class="op">=</span> w <span class="op">*</span> ewt <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> esp</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> objective_value</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Infeasible solution</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> LARGE_PENALTY</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="co"># --- HED Implementation ---</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hamming_distance(u1, u2):</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculates Hamming distance between two binary numpy arrays."""</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(u1 <span class="op">!=</span> u2)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_diverse_random_dictionary(T, m):</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generates the random dictionary A for HED."""</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    dictionary_A <span class="op">=</span> np.zeros((m, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample theta for density of 1s in this dictionary vector</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        theta <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> (np.random.rand(T) <span class="op">&lt;</span> theta).astype(<span class="bu">int</span>)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        dictionary_A[i, :] <span class="op">=</span> row</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dictionary_A</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _generate_binary_hadamard_matrix_recursive(dim):</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates a binary (0/1) Hadamard-like matrix of size dim x dim.</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co">    'dim' must be a power of 2.</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="co">    This uses the Sylvester's construction H_2n = [[H_n, H_n], [H_n, 1-H_n]]</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="co">    starting with H_1 = [[1]].</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> (dim <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> (dim <span class="op">&amp;</span> (dim <span class="op">-</span> <span class="dv">1</span>) <span class="op">==</span> <span class="dv">0</span>)): <span class="co"># Checks if dim is a power of 2</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Dimension must be a power of 2."</span>)</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dim <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array([[<span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>        h_prev <span class="op">=</span> _generate_binary_hadamard_matrix_recursive(dim <span class="op">//</span> <span class="dv">2</span>)</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>        h_top <span class="op">=</span> np.hstack((h_prev, h_prev))</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>        h_bottom <span class="op">=</span> np.hstack((h_prev, <span class="dv">1</span> <span class="op">-</span> h_prev)) <span class="co"># 1-H_n for binary</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.vstack((h_top, h_bottom))</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_wavelet_dictionary(T, m):</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates a dictionary A of size m x T using the subsampled binary wavelet approach.</span></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a><span class="co">        T (int): The dimensionality of the input space (number of columns in dictionary).</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a><span class="co">        m (int): The desired number of dictionary elements (number of rows).</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: An m x T integer numpy array representing the dictionary.</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"T (dimensionality) must be positive."</span>)</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"m (dictionary size) must be positive."</span>)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Determine the smallest power of 2 &gt;= T for the full wavelet matrix</span></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>        n_wavelet <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> (T <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> (T <span class="op">&amp;</span> (T <span class="op">-</span> <span class="dv">1</span>) <span class="op">==</span> <span class="dv">0</span>)): <span class="co"># T is already a power of 2</span></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>        n_wavelet <span class="op">=</span> T</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>        n_wavelet <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>math.ceil(math.log2(T))</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Generate the full n_wavelet x n_wavelet binary Hadamard matrix</span></span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print(f"Generating full wavelet matrix of size: {n_wavelet}x{n_wavelet}")</span></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>    full_wavelet_matrix <span class="op">=</span> _generate_binary_hadamard_matrix_recursive(n_wavelet)</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Subsample T columns if n_wavelet &gt; T</span></span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_wavelet <span class="op">&gt;</span> T:</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"Subsampling {T} columns from {n_wavelet} columns.")</span></span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>        col_indices <span class="op">=</span> np.random.choice(n_wavelet, size<span class="op">=</span>T, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>        col_indices.sort() <span class="co"># Optional: for deterministic testing if seed is set</span></span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>        wavelet_matrix_T_cols <span class="op">=</span> full_wavelet_matrix[:, col_indices]</span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>        wavelet_matrix_T_cols <span class="op">=</span> full_wavelet_matrix <span class="co"># n_wavelet == T</span></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Subsample m rows</span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a>    num_available_rows <span class="op">=</span> wavelet_matrix_T_cols.shape[<span class="dv">0</span>]</span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">&gt;</span> num_available_rows:</span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Warning: Requested dictionary size m (</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">) is greater than "</span></span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a>              <span class="ss">f"available unique wavelet rows (</span><span class="sc">{</span>num_available_rows<span class="sc">}</span><span class="ss">). "</span></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>              <span class="ss">f"Using all available rows and repeating if necessary, or consider reducing m."</span>)</span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For simplicity, if m &gt; num_available_rows, we'll sample with replacement</span></span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a>        <span class="co"># or you could choose to error, or return fewer rows.</span></span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The paper implies m should be less than or equal to the rows of B_d.</span></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If sampling with replacement is needed:</span></span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a>        row_indices <span class="op">=</span> np.random.choice(num_available_rows, size<span class="op">=</span>m, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If strictly no replacement and m &gt; num_available_rows, one might error or cap m</span></span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>        <span class="co"># row_indices = np.random.choice(num_available_rows, size=min(m, num_available_rows), replace=False)</span></span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if m &gt; num_available_rows:</span></span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     # Handle the case where more rows are needed than available unique ones</span></span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     # This might involve repeating rows or another strategy</span></span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     pass</span></span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"Subsampling {m} rows from {num_available_rows} available rows.")</span></span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>        row_indices <span class="op">=</span> np.random.choice(num_available_rows, size<span class="op">=</span>m, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a>    row_indices.sort() <span class="co"># Optional: for deterministic testing if seed is set</span></span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a>    dictionary_A <span class="op">=</span> wavelet_matrix_T_cols[row_indices, :]</span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dictionary_A</span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_vector(U_np, dictionary_A):</span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Embeds a single binary vector U using HED."""</span></span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a>    embedding_phi <span class="op">=</span> np.zeros(m, dtype<span class="op">=</span><span class="bu">float</span>) <span class="co"># Use float for GP</span></span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a>        embedding_phi[i] <span class="op">=</span> hamming_distance(U_np, dictionary_A[i, :])</span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> embedding_phi</span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_batch(U_batch_np, dictionary_A):</span>
<span id="cb4-137"><a href="#cb4-137" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Embeds a batch of binary vectors U."""</span></span>
<span id="cb4-138"><a href="#cb4-138" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input U_batch_np is expected to be a NumPy array</span></span>
<span id="cb4-139"><a href="#cb4-139" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb4-140"><a href="#cb4-140" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_batch_np.ndim <span class="op">==</span> <span class="dv">1</span>: <span class="co"># Handle single vector case</span></span>
<span id="cb4-141"><a href="#cb4-141" aria-hidden="true" tabindex="-1"></a>        U_batch_np <span class="op">=</span> U_batch_np.reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb4-142"><a href="#cb4-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-143"><a href="#cb4-143" aria-hidden="true" tabindex="-1"></a>    batch_size <span class="op">=</span> U_batch_np.shape[<span class="dv">0</span>]</span>
<span id="cb4-144"><a href="#cb4-144" aria-hidden="true" tabindex="-1"></a>    embeddings_np <span class="op">=</span> np.zeros((batch_size, m), dtype<span class="op">=</span><span class="bu">float</span>) <span class="co"># Use float for GP</span></span>
<span id="cb4-145"><a href="#cb4-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-146"><a href="#cb4-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(batch_size):</span>
<span id="cb4-147"><a href="#cb4-147" aria-hidden="true" tabindex="-1"></a>        embeddings_np[j, :] <span class="op">=</span> embed_vector(U_batch_np[j, :], dictionary_A)</span>
<span id="cb4-148"><a href="#cb4-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-149"><a href="#cb4-149" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return NumPy array directly</span></span>
<span id="cb4-150"><a href="#cb4-150" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> embeddings_np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="experiment-1-cbo-with-expected-improvement-ei" class="level4">
<h4 class="anchored" data-anchor-id="experiment-1-cbo-with-expected-improvement-ei">4. Experiment 1: CBO with Expected Improvement (EI)</h4>
<p>Applies the methodology from <span class="citation" data-cites="deshwal_bayesian_2023">@deshwal_bayesian_2023</span> using EI.</p>
<div id="077cbac7" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- get_fitted_model function remains the same ---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_fitted_model(train_X_embedded_scaled, train_Y, m):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... (implementation is unchanged) ...</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_Y.ndim <span class="op">&gt;</span> <span class="dv">1</span> <span class="kw">and</span> train_Y.shape[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>: train_Y <span class="op">=</span> train_Y.ravel()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> ConstantKernel(<span class="fl">1.0</span>, constant_value_bounds<span class="op">=</span>(<span class="fl">1e-3</span>, <span class="fl">1e3</span>)) <span class="op">*</span> <span class="op">\</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>             Matern(length_scale<span class="op">=</span>np.ones(m), length_scale_bounds<span class="op">=</span>(<span class="fl">1e-2</span>, <span class="fl">1e2</span>), nu<span class="op">=</span><span class="fl">2.5</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>             WhiteKernel(noise_level<span class="op">=</span><span class="fl">1e-10</span>, <span class="co"># Small value for numerical stability</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                         noise_level_bounds<span class="op">=</span><span class="st">"fixed"</span>) <span class="co"># Bounds for noise optimization</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    gp_model <span class="op">=</span> GaussianProcessRegressor(kernel<span class="op">=</span>kernel, alpha<span class="op">=</span><span class="fl">1e-10</span>, n_restarts_optimizer<span class="op">=</span><span class="dv">10</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    gp_model.fit(train_X_embedded_scaled, train_Y)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gp_model</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lower_confidence_bound(mu, sigma, kappa<span class="op">=</span><span class="fl">2.576</span>):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the Lower Confidence Bound (LCB) acquisition function.</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes maximization of this value guides the search (since mu is neg objective).</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Higher LCB means lower predicted objective or lower penalty for uncertainty.</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">    mu, sigma: Predicted mean and standard deviation (NumPy arrays).</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co">    kappa: Controls the balance between exploitation (high mu -&gt; low original objective)</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co">           and exploration (low sigma).</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure sigma is non-negative</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.maximum(sigma, <span class="dv">0</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mu <span class="op">-</span> kappa <span class="op">*</span> sigma <span class="co"># &lt;&lt;&lt; Sign flipped from UCB</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimize_acqf_discrete_via_embedding(gp_model, scaler, dictionary_A, T, q, num_candidates, kappa):</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="co">    Optimizes LCB acquisition function by sampling random binary candidates,</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="co">    embedding, SCALING, predicting with GP, and calculating LCB.</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co">    Selects the top q candidates based on LCB.</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns candidates as a numpy array (q x T).</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Generate Random Binary Candidates</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    candidate_u_vectors_np <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>(num_candidates, T))</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Embed the Candidates</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    embedded_candidates_np <span class="op">=</span> embed_batch(candidate_u_vectors_np, dictionary_A)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Scale the Embedded Candidates</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    embedded_candidates_scaled_np <span class="op">=</span> scaler.transform(embedded_candidates_np)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Predict Mean and Std Dev using the GP Model</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    mu, std <span class="op">=</span> gp_model.predict(embedded_candidates_scaled_np, return_std<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5. Calculate Acquisition Function (Lower Confidence Bound) &lt;&lt;&lt; CHANGED HERE</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    acq_values <span class="op">=</span> lower_confidence_bound(mu, std, kappa<span class="op">=</span>kappa) <span class="co"># Use LCB</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 6. Select Top Candidates (based on highest LCB) &lt;&lt;&lt; COMMENT UPDATED</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We maximize LCB = mu - kappa*sigma, where mu is neg_objective</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>    top_indices <span class="op">=</span> np.argsort(acq_values)[<span class="op">-</span>q:]</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    top_indices <span class="op">=</span> top_indices[::<span class="op">-</span><span class="dv">1</span>] <span class="co"># Ensure descending order of LCB</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> candidate_u_vectors_np[top_indices, :]</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Local Search with Embedded BO ---</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>MAX_LOCAL_SEARCH_ITERATIONS <span class="op">=</span> <span class="dv">10</span> <span class="co"># Max iterations for the outer local search loop</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>CONVERGENCE_TOLERANCE <span class="op">=</span> <span class="fl">1e-5</span>    <span class="co"># If improvement is less than this, consider converged</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>NO_IMPROVEMENT_STREAK_LIMIT <span class="op">=</span> <span class="dv">3</span> <span class="co"># Stop if no improvement for this many LS iterations</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a><span class="co"># BO Parameters (can be tuned)</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>KAPPA <span class="op">=</span> <span class="fl">2.576</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>N_INITIAL_BO <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>N_ITERATIONS_BO <span class="op">=</span> <span class="dv">20</span> <span class="co"># Max BO iterations *if no improvement is found earlier*</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>BATCH_SIZE_q <span class="op">=</span> <span class="dv">5</span>     <span class="co"># Number of candidates BO proposes at once</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> math.ceil(T<span class="op">/</span><span class="dv">2</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>NUM_CANDIDATES_Acqf <span class="op">=</span> (T <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">1024</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">100</span> <span class="co"># Ensure Acqf has candidates even if T=0 (though U will be empty)</span></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>current_X_ls <span class="op">=</span> np.copy(X) <span class="co"># Start with the initial X</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>best_overall_f_ls <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>best_overall_U_ls <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>best_overall_Y_ls <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>no_improvement_streak <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Starting Local Search with initial X: </span><span class="sc">{</span>current_X_ls<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ls_iter <span class="kw">in</span> <span class="bu">range</span>(MAX_LOCAL_SEARCH_ITERATIONS):</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n\n</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss"> LOCAL SEARCH ITERATION </span><span class="sc">{</span>ls_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>MAX_LOCAL_SEARCH_ITERATIONS<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Current X for this LS iteration: </span><span class="sc">{</span>current_X_ls<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>    current_best_f_in_ls_iter <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>) <span class="co"># Best objective for the *current* X</span></span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- BO Loop (inner loop) ---</span></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_list_bo <span class="op">=</span> []</span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>    evaluated_f_vals_bo <span class="op">=</span> []</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>    train_Y_list_bo <span class="op">=</span> [] <span class="co"># For negated objectives (GP maximizes)</span></span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Initialization for BO (using current_X_ls)</span></span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>    <span class="co">#    We can add some diverse initial candidates or just let BO explore</span></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>    <span class="co">#    For simplicity, we'll generate a few random ones if initial_candidates is specific to global start</span></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>    bo_initial_points <span class="op">=</span> [np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>T) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(N_INITIAL_BO)]</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>    bo_initial_points.insert(<span class="dv">0</span>, np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>)) <span class="co"># Add U=zeros as the first point</span></span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure at least one non-empty schedule if possible</span></span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="kw">not</span> <span class="bu">any</span>(np.<span class="bu">any</span>(u) <span class="cf">for</span> u <span class="kw">in</span> bo_initial_points):</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>        idx_to_set <span class="op">=</span> np.random.randint(T)</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>        bo_initial_points[<span class="dv">0</span>][idx_to_set] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> U_init <span class="kw">in</span> bo_initial_points: <span class="co"># Use a small set of diverse points for each BO run</span></span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>        f_val <span class="op">=</span> evaluate_objective(U_init, current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>        neg_f_val <span class="op">=</span> <span class="op">-</span>f_val</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list_bo.append(U_init)</span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals_bo.append(f_val)</span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>        train_Y_list_bo.append(neg_f_val)</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> evaluated_f_vals_bo:</span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>        best_f_this_bo_run <span class="op">=</span> <span class="bu">min</span>(evaluated_f_vals_bo)</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>        best_U_this_bo_run_idx <span class="op">=</span> np.argmin(evaluated_f_vals_bo)</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>        best_U_this_bo_run <span class="op">=</span> evaluated_U_np_list_bo[best_U_this_bo_run_idx]</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># Should not happen if N_INITIAL_BO &gt; 0</span></span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>        best_f_this_bo_run <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>        best_U_this_bo_run <span class="op">=</span> np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>) <span class="co"># Placeholder</span></span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"BO Initial best objective for current X: </span><span class="sc">{</span>best_f_this_bo_run<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>    improvement_found_in_bo <span class="op">=</span> <span class="va">False</span></span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bo_iter <span class="kw">in</span> <span class="bu">range</span>(N_ITERATIONS_BO):</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- BO Iteration </span><span class="sc">{</span>bo_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>N_ITERATIONS_BO<span class="sc">}</span><span class="ss"> (LS Iter </span><span class="sc">{</span>ls_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">) ---"</span>)</span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>        start_time_bo <span class="op">=</span> time.time()</span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>        <span class="co"># a. Generate dictionary A</span></span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>        current_dictionary_A <span class="op">=</span> generate_diverse_random_dictionary(T, m) <span class="co"># Or wavelet</span></span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>        <span class="co"># b. Embed ALL evaluated U vectors for this BO run</span></span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> evaluated_U_np_list_bo: <span class="cf">continue</span></span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_array_bo <span class="op">=</span> np.array(evaluated_U_np_list_bo)</span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>        embedded_train_X_bo <span class="op">=</span> embed_batch(evaluated_U_np_array_bo, current_dictionary_A)</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>        <span class="co"># c. Scale</span></span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a>        scaler_bo <span class="op">=</span> MinMaxScaler()</span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> embedded_train_X_bo.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>            embedded_train_X_scaled_bo <span class="op">=</span> scaler_bo.fit_transform(embedded_train_X_bo)</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>            embedded_train_X_scaled_bo <span class="op">=</span> embedded_train_X_bo</span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a>        train_Y_for_fit_bo <span class="op">=</span> np.array(train_Y_list_bo)</span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a>        <span class="co"># d. Fit GP Model</span></span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> embedded_train_X_scaled_bo.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a>           train_Y_for_fit_bo.shape[<span class="dv">0</span>] <span class="op">==</span> embedded_train_X_scaled_bo.shape[<span class="dv">0</span>]:</span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>                gp_model_bo <span class="op">=</span> get_fitted_model(embedded_train_X_scaled_bo, train_Y_for_fit_bo, m)</span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Warning: GP fitting error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">. Skipping BO iteration."</span>)</span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Warning: Not enough data or mismatch for GP. Skipping BO iteration."</span>)</span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-153"><a href="#cb5-153" aria-hidden="true" tabindex="-1"></a>        <span class="co"># f. Optimize Acquisition Function (LCB)</span></span>
<span id="cb5-154"><a href="#cb5-154" aria-hidden="true" tabindex="-1"></a>        next_U_candidates_np_bo <span class="op">=</span> optimize_acqf_discrete_via_embedding(</span>
<span id="cb5-155"><a href="#cb5-155" aria-hidden="true" tabindex="-1"></a>            gp_model<span class="op">=</span>gp_model_bo,</span>
<span id="cb5-156"><a href="#cb5-156" aria-hidden="true" tabindex="-1"></a>            scaler<span class="op">=</span>scaler_bo,</span>
<span id="cb5-157"><a href="#cb5-157" aria-hidden="true" tabindex="-1"></a>            dictionary_A<span class="op">=</span>current_dictionary_A,</span>
<span id="cb5-158"><a href="#cb5-158" aria-hidden="true" tabindex="-1"></a>            T<span class="op">=</span>T,</span>
<span id="cb5-159"><a href="#cb5-159" aria-hidden="true" tabindex="-1"></a>            q<span class="op">=</span>BATCH_SIZE_q,</span>
<span id="cb5-160"><a href="#cb5-160" aria-hidden="true" tabindex="-1"></a>            num_candidates<span class="op">=</span>NUM_CANDIDATES_Acqf,</span>
<span id="cb5-161"><a href="#cb5-161" aria-hidden="true" tabindex="-1"></a>            kappa<span class="op">=</span>KAPPA</span>
<span id="cb5-162"><a href="#cb5-162" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-163"><a href="#cb5-163" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> next_U_candidates_np_bo.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-164"><a href="#cb5-164" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Acquisition function optimization yielded no new candidates. Stopping BO for this LS iteration."</span>)</span>
<span id="cb5-165"><a href="#cb5-165" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb5-166"><a href="#cb5-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-167"><a href="#cb5-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-168"><a href="#cb5-168" aria-hidden="true" tabindex="-1"></a>        <span class="co"># g. Evaluate Objective for new candidates</span></span>
<span id="cb5-169"><a href="#cb5-169" aria-hidden="true" tabindex="-1"></a>        newly_evaluated_U_bo <span class="op">=</span> []</span>
<span id="cb5-170"><a href="#cb5-170" aria-hidden="true" tabindex="-1"></a>        newly_evaluated_f_bo <span class="op">=</span> []</span>
<span id="cb5-171"><a href="#cb5-171" aria-hidden="true" tabindex="-1"></a>        newly_evaluated_neg_f_bo <span class="op">=</span> []</span>
<span id="cb5-172"><a href="#cb5-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-173"><a href="#cb5-173" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(next_U_candidates_np_bo.shape[<span class="dv">0</span>]):</span>
<span id="cb5-174"><a href="#cb5-174" aria-hidden="true" tabindex="-1"></a>            next_U_bo <span class="op">=</span> next_U_candidates_np_bo[i, :]</span>
<span id="cb5-175"><a href="#cb5-175" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if already evaluated in *this specific BO run*</span></span>
<span id="cb5-176"><a href="#cb5-176" aria-hidden="true" tabindex="-1"></a>            already_evaluated_this_bo <span class="op">=</span> <span class="bu">any</span>(np.array_equal(next_U_bo, u) <span class="cf">for</span> u <span class="kw">in</span> evaluated_U_np_list_bo)</span>
<span id="cb5-177"><a href="#cb5-177" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> already_evaluated_this_bo:</span>
<span id="cb5-178"><a href="#cb5-178" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"  Candidate </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> was already evaluated in this BO run. Skipping."</span>)</span>
<span id="cb5-179"><a href="#cb5-179" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb5-180"><a href="#cb5-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-181"><a href="#cb5-181" aria-hidden="true" tabindex="-1"></a>            next_f_bo <span class="op">=</span> evaluate_objective(next_U_bo, current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb5-182"><a href="#cb5-182" aria-hidden="true" tabindex="-1"></a>            next_neg_f_bo <span class="op">=</span> <span class="op">-</span>next_f_bo</span>
<span id="cb5-183"><a href="#cb5-183" aria-hidden="true" tabindex="-1"></a>            temp_Y_bo <span class="op">=</span> current_X_ls <span class="op">+</span> np.<span class="bu">sum</span>(v_star[next_U_bo <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>) <span class="co"># Calculate Y for this candidate</span></span>
<span id="cb5-184"><a href="#cb5-184" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  BO Candidate </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: Obj = </span><span class="sc">{</span>next_f_bo<span class="sc">:.4f}</span><span class="ss"> (with current_X_ls)"</span>) <span class="co"># Y: {temp_Y_bo}</span></span>
<span id="cb5-185"><a href="#cb5-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-186"><a href="#cb5-186" aria-hidden="true" tabindex="-1"></a>            newly_evaluated_U_bo.append(next_U_bo)</span>
<span id="cb5-187"><a href="#cb5-187" aria-hidden="true" tabindex="-1"></a>            newly_evaluated_f_bo.append(next_f_bo)</span>
<span id="cb5-188"><a href="#cb5-188" aria-hidden="true" tabindex="-1"></a>            newly_evaluated_neg_f_bo.append(next_neg_f_bo)</span>
<span id="cb5-189"><a href="#cb5-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-190"><a href="#cb5-190" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> next_f_bo <span class="op">&lt;</span> best_f_this_bo_run:</span>
<span id="cb5-191"><a href="#cb5-191" aria-hidden="true" tabindex="-1"></a>                best_f_this_bo_run <span class="op">=</span> next_f_bo</span>
<span id="cb5-192"><a href="#cb5-192" aria-hidden="true" tabindex="-1"></a>                best_U_this_bo_run <span class="op">=</span> next_U_bo <span class="co"># Update best U for this BO run</span></span>
<span id="cb5-193"><a href="#cb5-193" aria-hidden="true" tabindex="-1"></a>                improvement_found_in_bo <span class="op">=</span> <span class="va">True</span></span>
<span id="cb5-194"><a href="#cb5-194" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"    New best for this BO run: Obj=</span><span class="sc">{</span>best_f_this_bo_run<span class="sc">:.4f}</span><span class="ss">, U=</span><span class="sc">{</span>best_U_this_bo_run<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-195"><a href="#cb5-195" aria-hidden="true" tabindex="-1"></a>                <span class="co"># --- LOCAL SEARCH DECISION POINT ---</span></span>
<span id="cb5-196"><a href="#cb5-196" aria-hidden="true" tabindex="-1"></a>                <span class="co"># If this new objective is better than the current_best_f_in_ls_iter</span></span>
<span id="cb5-197"><a href="#cb5-197" aria-hidden="true" tabindex="-1"></a>                <span class="co"># (which is the objective associated with current_X_ls itself, or best found so far for current_X_ls)</span></span>
<span id="cb5-198"><a href="#cb5-198" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Then, we have found an improvement. We can break the BO loop and update X.</span></span>
<span id="cb5-199"><a href="#cb5-199" aria-hidden="true" tabindex="-1"></a>                <span class="co"># For a true "first improvement" local search, we'd break here.</span></span>
<span id="cb5-200"><a href="#cb5-200" aria-hidden="true" tabindex="-1"></a>                <span class="co"># For a "best improvement" within BO, we continue BO, then update LS.</span></span>
<span id="cb5-201"><a href="#cb5-201" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Let's implement "first improvement found by BO for current X"</span></span>
<span id="cb5-202"><a href="#cb5-202" aria-hidden="true" tabindex="-1"></a>                <span class="co"># To make it more "local searchy", we compare to the objective of X itself</span></span>
<span id="cb5-203"><a href="#cb5-203" aria-hidden="true" tabindex="-1"></a>                <span class="co"># or a very good objective found from X.</span></span>
<span id="cb5-204"><a href="#cb5-204" aria-hidden="true" tabindex="-1"></a>                <span class="co"># If we are trying to improve upon current_X_ls (whose implicit U is "all zeros" for modifications)</span></span>
<span id="cb5-205"><a href="#cb5-205" aria-hidden="true" tabindex="-1"></a>                <span class="co"># obj_of_current_X = evaluate_objective(np.zeros(T, dtype=int), current_X_ls, v_star, convolutions, d, w)</span></span>
<span id="cb5-206"><a href="#cb5-206" aria-hidden="true" tabindex="-1"></a>                <span class="co"># We need a baseline. The baseline is the best objective found so far *for the current X_ls*.</span></span>
<span id="cb5-207"><a href="#cb5-207" aria-hidden="true" tabindex="-1"></a>                <span class="co"># This is `best_f_this_bo_run` before this candidate was evaluated.</span></span>
<span id="cb5-208"><a href="#cb5-208" aria-hidden="true" tabindex="-1"></a>                <span class="co"># So, if `next_f_bo` is better than the previous `best_f_this_bo_run`, it's an improvement.</span></span>
<span id="cb5-209"><a href="#cb5-209" aria-hidden="true" tabindex="-1"></a>                <span class="co"># No, `best_f_this_bo_run` is the best *during this specific BO run*.</span></span>
<span id="cb5-210"><a href="#cb5-210" aria-hidden="true" tabindex="-1"></a>                <span class="co"># We need to compare to `current_best_f_in_ls_iter` which should be the obj of `current_X_ls`</span></span>
<span id="cb5-211"><a href="#cb5-211" aria-hidden="true" tabindex="-1"></a>                <span class="co"># if we haven't found a better U for it yet.</span></span>
<span id="cb5-212"><a href="#cb5-212" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Let's initialize `current_best_f_in_ls_iter` with the objective of `current_X_ls` (U=zeros)</span></span>
<span id="cb5-213"><a href="#cb5-213" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> ls_iter <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> bo_iter <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> i <span class="op">==</span><span class="dv">0</span>: <span class="co"># At very start, or start of new LS with new X</span></span>
<span id="cb5-214"><a href="#cb5-214" aria-hidden="true" tabindex="-1"></a>                    obj_of_current_X_ls <span class="op">=</span> evaluate_objective(np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>), current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb5-215"><a href="#cb5-215" aria-hidden="true" tabindex="-1"></a>                    current_best_f_in_ls_iter <span class="op">=</span> obj_of_current_X_ls</span>
<span id="cb5-216"><a href="#cb5-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-217"><a href="#cb5-217" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> next_f_bo <span class="op">&lt;</span> current_best_f_in_ls_iter:</span>
<span id="cb5-218"><a href="#cb5-218" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"    BO found a U that improves upon current_X_ls (Obj: </span><span class="sc">{</span>next_f_bo<span class="sc">:.4f}</span><span class="ss"> &lt; </span><span class="sc">{</span>current_best_f_in_ls_iter<span class="sc">:.4f}</span><span class="ss">)."</span>)</span>
<span id="cb5-219"><a href="#cb5-219" aria-hidden="true" tabindex="-1"></a>                    current_best_f_in_ls_iter <span class="op">=</span> next_f_bo <span class="co"># Update best for this LS iter</span></span>
<span id="cb5-220"><a href="#cb5-220" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># This U (next_U_bo) is the candidate for the next X</span></span>
<span id="cb5-221"><a href="#cb5-221" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># We can decide to break BO here and update X, or continue BO for best improvement.</span></span>
<span id="cb5-222"><a href="#cb5-222" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># For "first improvement" local search:</span></span>
<span id="cb5-223"><a href="#cb5-223" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># break # This break will exit the loop over next_U_candidates_np_bo</span></span>
<span id="cb5-224"><a href="#cb5-224" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">pass</span> <span class="co"># Let BO finish its batch to make a more informed choice for this LS step</span></span>
<span id="cb5-225"><a href="#cb5-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-226"><a href="#cb5-226" aria-hidden="true" tabindex="-1"></a>        <span class="co"># h. Augment Dataset for this BO run</span></span>
<span id="cb5-227"><a href="#cb5-227" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list_bo.extend(newly_evaluated_U_bo)</span>
<span id="cb5-228"><a href="#cb5-228" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals_bo.extend(newly_evaluated_f_bo)</span>
<span id="cb5-229"><a href="#cb5-229" aria-hidden="true" tabindex="-1"></a>        train_Y_list_bo.extend(newly_evaluated_neg_f_bo)</span>
<span id="cb5-230"><a href="#cb5-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-231"><a href="#cb5-231" aria-hidden="true" tabindex="-1"></a>        iter_time_bo <span class="op">=</span> time.time() <span class="op">-</span> start_time_bo</span>
<span id="cb5-232"><a href="#cb5-232" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Best objective for current X in this BO run: </span><span class="sc">{</span>best_f_this_bo_run<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-233"><a href="#cb5-233" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  BO Iteration </span><span class="sc">{</span>bo_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> completed in </span><span class="sc">{</span>iter_time_bo<span class="sc">:.2f}</span><span class="ss"> sec."</span>)</span>
<span id="cb5-234"><a href="#cb5-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-235"><a href="#cb5-235" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if improvement_found_in_bo and "first improvement" was desired from the batch:</span></span>
<span id="cb5-236"><a href="#cb5-236" aria-hidden="true" tabindex="-1"></a>        <span class="co">#    break # This break will exit the BO iterations loop</span></span>
<span id="cb5-237"><a href="#cb5-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-238"><a href="#cb5-238" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- End of BO Loop for current_X_ls ---</span></span>
<span id="cb5-239"><a href="#cb5-239" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Finished BO for LS Iteration </span><span class="sc">{</span>ls_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb5-240"><a href="#cb5-240" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best U found by BO for current_X_ls: </span><span class="sc">{</span>best_U_this_bo_run<span class="sc">}</span><span class="ss">, Obj: </span><span class="sc">{</span>best_f_this_bo_run<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-241"><a href="#cb5-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-242"><a href="#cb5-242" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compare the best result from this BO run (best_f_this_bo_run for current_X_ls)</span></span>
<span id="cb5-243"><a href="#cb5-243" aria-hidden="true" tabindex="-1"></a>    <span class="co"># with the overall best found so far in the local search (best_overall_f_ls)</span></span>
<span id="cb5-244"><a href="#cb5-244" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The "move" in local search happens if `best_f_this_bo_run` is better than</span></span>
<span id="cb5-245"><a href="#cb5-245" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the objective of `current_X_ls` (using U=zeros for modifications).</span></span>
<span id="cb5-246"><a href="#cb5-246" aria-hidden="true" tabindex="-1"></a>    obj_of_current_X_ls_no_mod <span class="op">=</span> evaluate_objective(np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>), current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb5-247"><a href="#cb5-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-248"><a href="#cb5-248" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> best_f_this_bo_run <span class="op">&lt;</span> obj_of_current_X_ls_no_mod <span class="op">-</span> CONVERGENCE_TOLERANCE:</span>
<span id="cb5-249"><a href="#cb5-249" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Improvement found! New best obj </span><span class="sc">{</span>best_f_this_bo_run<span class="sc">:.4f}</span><span class="ss"> &lt; obj of current X </span><span class="sc">{</span>obj_of_current_X_ls_no_mod<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-250"><a href="#cb5-250" aria-hidden="true" tabindex="-1"></a>        Y_improved <span class="op">=</span> current_X_ls <span class="op">+</span> np.<span class="bu">sum</span>(v_star[best_U_this_bo_run <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-251"><a href="#cb5-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-252"><a href="#cb5-252" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check feasibility of the new Y before accepting the move</span></span>
<span id="cb5-253"><a href="#cb5-253" aria-hidden="true" tabindex="-1"></a>        is_Y_feasible <span class="op">=</span> np.<span class="bu">all</span>(Y_improved <span class="op">&gt;=</span> <span class="dv">0</span>)</span>
<span id="cb5-254"><a href="#cb5-254" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_Y_feasible:</span>
<span id="cb5-255"><a href="#cb5-255" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Re-evaluate with penalty if the direct evaluation didn't catch it</span></span>
<span id="cb5-256"><a href="#cb5-256" aria-hidden="true" tabindex="-1"></a>            <span class="co"># (depends on how evaluate_objective handles feasibility internally)</span></span>
<span id="cb5-257"><a href="#cb5-257" aria-hidden="true" tabindex="-1"></a>            <span class="co"># This check is mostly for sanity, evaluate_objective should handle it.</span></span>
<span id="cb5-258"><a href="#cb5-258" aria-hidden="true" tabindex="-1"></a>            obj_of_Y_improved_check <span class="op">=</span> evaluate_objective(best_U_this_bo_run, current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb5-259"><a href="#cb5-259" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> obj_of_Y_improved_check <span class="op">&gt;=</span> LARGE_PENALTY:</span>
<span id="cb5-260"><a href="#cb5-260" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="ss">f"  Proposed Y from U=</span><span class="sc">{</span>best_U_this_bo_run<span class="sc">}</span><span class="ss"> is INFEASIBLE. Obj=</span><span class="sc">{</span>obj_of_Y_improved_check<span class="sc">:.4f}</span><span class="ss">. Rejecting move."</span>)</span>
<span id="cb5-261"><a href="#cb5-261" aria-hidden="true" tabindex="-1"></a>                 no_improvement_streak <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-262"><a href="#cb5-262" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co"># It was feasible or penalty was low enough</span></span>
<span id="cb5-263"><a href="#cb5-263" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"  Moving to new state Y: </span><span class="sc">{</span>Y_improved<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-264"><a href="#cb5-264" aria-hidden="true" tabindex="-1"></a>                current_X_ls <span class="op">=</span> np.copy(Y_improved) <span class="co"># Update X for the next LS iteration</span></span>
<span id="cb5-265"><a href="#cb5-265" aria-hidden="true" tabindex="-1"></a>                no_improvement_streak <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-266"><a href="#cb5-266" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-267"><a href="#cb5-267" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  Moving to new state Y: </span><span class="sc">{</span>Y_improved<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-268"><a href="#cb5-268" aria-hidden="true" tabindex="-1"></a>            current_X_ls <span class="op">=</span> np.copy(Y_improved) <span class="co"># Update X for the next LS iteration</span></span>
<span id="cb5-269"><a href="#cb5-269" aria-hidden="true" tabindex="-1"></a>            no_improvement_streak <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-270"><a href="#cb5-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-271"><a href="#cb5-271" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update overall best if this new state (Y_improved) is the best ever</span></span>
<span id="cb5-272"><a href="#cb5-272" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The objective of Y_improved *as a new starting state X* is evaluate_objective(zeros, Y_improved, ...)</span></span>
<span id="cb5-273"><a href="#cb5-273" aria-hidden="true" tabindex="-1"></a>        obj_of_new_X_state <span class="op">=</span> evaluate_objective(np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>), current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb5-274"><a href="#cb5-274" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> obj_of_new_X_state <span class="op">&lt;</span> best_overall_f_ls:</span>
<span id="cb5-275"><a href="#cb5-275" aria-hidden="true" tabindex="-1"></a>            best_overall_f_ls <span class="op">=</span> obj_of_new_X_state</span>
<span id="cb5-276"><a href="#cb5-276" aria-hidden="true" tabindex="-1"></a>            best_overall_U_ls <span class="op">=</span> np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>) <span class="co"># U is relative to X, so for the new X, U is initially zeros</span></span>
<span id="cb5-277"><a href="#cb5-277" aria-hidden="true" tabindex="-1"></a>            best_overall_Y_ls <span class="op">=</span> np.copy(current_X_ls)</span>
<span id="cb5-278"><a href="#cb5-278" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"    New OVERALL best state found. Obj of new X: </span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-279"><a href="#cb5-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-280"><a href="#cb5-280" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-281"><a href="#cb5-281" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"No improvement over current_X_ls (Obj </span><span class="sc">{</span>obj_of_current_X_ls_no_mod<span class="sc">:.4f}</span><span class="ss"> vs BO best </span><span class="sc">{</span>best_f_this_bo_run<span class="sc">:.4f}</span><span class="ss">). Staying at current X."</span>)</span>
<span id="cb5-282"><a href="#cb5-282" aria-hidden="true" tabindex="-1"></a>        no_improvement_streak <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-283"><a href="#cb5-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-284"><a href="#cb5-284" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> no_improvement_streak <span class="op">&gt;=</span> NO_IMPROVEMENT_STREAK_LIMIT:</span>
<span id="cb5-285"><a href="#cb5-285" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"No improvement for </span><span class="sc">{</span>no_improvement_streak<span class="sc">}</span><span class="ss"> local search iterations. Stopping."</span>)</span>
<span id="cb5-286"><a href="#cb5-286" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb5-287"><a href="#cb5-287" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ls_iter <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="bu">abs</span>(best_f_this_bo_run <span class="op">-</span> obj_of_current_X_ls_no_mod) <span class="op">&lt;</span> CONVERGENCE_TOLERANCE <span class="kw">and</span> best_f_this_bo_run <span class="op">&lt;</span> obj_of_current_X_ls_no_mod :</span>
<span id="cb5-288"><a href="#cb5-288" aria-hidden="true" tabindex="-1"></a>        <span class="co"># This condition is a bit tricky. If BO found something slightly better but very close,</span></span>
<span id="cb5-289"><a href="#cb5-289" aria-hidden="true" tabindex="-1"></a>        <span class="co"># and we made the move, the next obj_of_current_X_ls_no_mod will be that new value.</span></span>
<span id="cb5-290"><a href="#cb5-290" aria-hidden="true" tabindex="-1"></a>        <span class="co"># True convergence is when BO cannot find a U that makes current_X_ls + U_vstar better than current_X_ls.</span></span>
<span id="cb5-291"><a href="#cb5-291" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span> <span class="co"># Rely on no_improvement_streak for now.</span></span>
<span id="cb5-292"><a href="#cb5-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-293"><a href="#cb5-293" aria-hidden="true" tabindex="-1"></a><span class="co"># --- End of Local Search Loop ---</span></span>
<span id="cb5-294"><a href="#cb5-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-295"><a href="#cb5-295" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n\n</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss"> LOCAL SEARCH FINISHED </span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-296"><a href="#cb5-296" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> best_overall_Y_ls <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-297"><a href="#cb5-297" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Overall Objective (of the final X state): </span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-298"><a href="#cb5-298" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print(f"Best Overall U (relative to the X that produced it): {best_overall_U_ls}") # This U is just zeros for the final X</span></span>
<span id="cb5-299"><a href="#cb5-299" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Overall Y (final state vector): </span><span class="sc">{</span>best_overall_Y_ls<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-300"><a href="#cb5-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-301"><a href="#cb5-301" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verification of the final best_overall_Y_ls</span></span>
<span id="cb5-302"><a href="#cb5-302" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Verification of Final Best Local Search State ---"</span>)</span>
<span id="cb5-303"><a href="#cb5-303" aria-hidden="true" tabindex="-1"></a>    is_feasible_final <span class="op">=</span> np.<span class="bu">all</span>(best_overall_Y_ls <span class="op">&gt;=</span> <span class="dv">0</span>)</span>
<span id="cb5-304"><a href="#cb5-304" aria-hidden="true" tabindex="-1"></a>    recalculated_obj_final <span class="op">=</span> LARGE_PENALTY</span>
<span id="cb5-305"><a href="#cb5-305" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> is_feasible_final:</span>
<span id="cb5-306"><a href="#cb5-306" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Objective of this state is when U=zeros (no further modifications)</span></span>
<span id="cb5-307"><a href="#cb5-307" aria-hidden="true" tabindex="-1"></a>        ewt_f, esp_f <span class="op">=</span> calculate_objective_serv_time_lookup(best_overall_Y_ls, d, convolutions)</span>
<span id="cb5-308"><a href="#cb5-308" aria-hidden="true" tabindex="-1"></a>        recalculated_obj_final <span class="op">=</span> w <span class="op">*</span> ewt_f <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> esp_f</span>
<span id="cb5-309"><a href="#cb5-309" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Is the best Y_ls feasible? </span><span class="sc">{</span>is_feasible_final<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-310"><a href="#cb5-310" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> is_feasible_final:</span>
<span id="cb5-311"><a href="#cb5-311" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Objective value of best Y_ls (recalculated): </span><span class="sc">{</span>recalculated_obj_final<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-312"><a href="#cb5-312" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> np.isclose(best_overall_f_ls, recalculated_obj_final):</span>
<span id="cb5-313"><a href="#cb5-313" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Warning: Stored best LS objective (</span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">) "</span></span>
<span id="cb5-314"><a href="#cb5-314" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f"does not match recalculation (</span><span class="sc">{</span>recalculated_obj_final<span class="sc">:.4f}</span><span class="ss">)!"</span>)</span>
<span id="cb5-315"><a href="#cb5-315" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> best_overall_f_ls <span class="op">&lt;</span> LARGE_PENALTY:</span>
<span id="cb5-316"><a href="#cb5-316" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Warning: Best LS objective (</span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">) is not penalty, but feasibility check failed for Y."</span>)</span>
<span id="cb5-317"><a href="#cb5-317" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-318"><a href="#cb5-318" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Best LS solution found corresponds to an infeasible penalty value."</span>)</span>
<span id="cb5-319"><a href="#cb5-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-320"><a href="#cb5-320" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb5-321"><a href="#cb5-321" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Local search did not find any valid state or no iterations were run meaningfully."</span>)</span>
<span id="cb5-322"><a href="#cb5-322" aria-hidden="true" tabindex="-1"></a>end_time <span class="op">=</span> time.time()</span>
<span id="cb5-323"><a href="#cb5-323" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total time taken for Local Search: </span><span class="sc">{</span>end_time <span class="op">-</span> start_time<span class="sc">:.2f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Starting Local Search with initial X: [2 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 7]


========== LOCAL SEARCH ITERATION 1/10 ==========
Current X for this LS iteration: [2 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 7]
BO Initial best objective for current X: 105.8076

--- BO Iteration 1/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 115.7075 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 1 completed in 3.26 sec.

--- BO Iteration 2/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 115.9573 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 117.0874 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 2 completed in 2.88 sec.

--- BO Iteration 3/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 114.6255 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 118.0132 (with current_X_ls)
  BO Candidate 3: Obj = 115.9593 (with current_X_ls)
  BO Candidate 4: Obj = 117.4191 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 3 completed in 3.16 sec.

--- BO Iteration 4/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 114.9993 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 4 completed in 3.14 sec.

--- BO Iteration 5/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 5 completed in 3.77 sec.

--- BO Iteration 6/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 6 completed in 4.30 sec.

--- BO Iteration 7/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 115.0601 (with current_X_ls)
  BO Candidate 1: Obj = 118.3992 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 116.1196 (with current_X_ls)
  BO Candidate 4: Obj = 117.0613 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 7 completed in 3.57 sec.

--- BO Iteration 8/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 106.1707 (with current_X_ls)
  BO Candidate 3: Obj = 109.0811 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 8 completed in 3.04 sec.

--- BO Iteration 9/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 114.5139 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 115.6807 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 9 completed in 4.43 sec.

--- BO Iteration 10/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 108.8146 (with current_X_ls)
  BO Candidate 1: Obj = 116.0003 (with current_X_ls)
  BO Candidate 2: Obj = 114.7785 (with current_X_ls)
  BO Candidate 3: Obj = 112.2701 (with current_X_ls)
  BO Candidate 4: Obj = 115.0037 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 10 completed in 3.40 sec.

--- BO Iteration 11/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 116.0891 (with current_X_ls)
  BO Candidate 1: Obj = 113.2760 (with current_X_ls)
  BO Candidate 2: Obj = 108.0123 (with current_X_ls)
  BO Candidate 3: Obj = 114.3845 (with current_X_ls)
  BO Candidate 4: Obj = 113.0990 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 11 completed in 3.63 sec.

--- BO Iteration 12/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 107.2969 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 12 completed in 4.33 sec.

--- BO Iteration 13/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 114.8980 (with current_X_ls)
  BO Candidate 1: Obj = 115.9868 (with current_X_ls)
  BO Candidate 2: Obj = 109.0492 (with current_X_ls)
  BO Candidate 3: Obj = 116.5834 (with current_X_ls)
  BO Candidate 4: Obj = 116.5275 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 13 completed in 4.00 sec.

--- BO Iteration 14/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 115.9130 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 116.3278 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 116.1634 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 14 completed in 4.53 sec.

--- BO Iteration 15/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 114.8590 (with current_X_ls)
  BO Candidate 2: Obj = 118.2989 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 15 completed in 4.94 sec.

--- BO Iteration 16/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 115.7372 (with current_X_ls)
  BO Candidate 1: Obj = 117.9097 (with current_X_ls)
  BO Candidate 2: Obj = 116.4013 (with current_X_ls)
  BO Candidate 3: Obj = 115.7284 (with current_X_ls)
  BO Candidate 4: Obj = 117.3505 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 16 completed in 4.07 sec.

--- BO Iteration 17/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 115.9053 (with current_X_ls)
  BO Candidate 1: Obj = 114.6815 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 115.9553 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 17 completed in 4.75 sec.

--- BO Iteration 18/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 115.0192 (with current_X_ls)
  BO Candidate 1: Obj = 115.2595 (with current_X_ls)
  BO Candidate 2: Obj = 113.6320 (with current_X_ls)
  BO Candidate 3: Obj = 109.7674 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 105.8076
  BO Iteration 18 completed in 7.34 sec.

--- BO Iteration 19/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 118.3628 (with current_X_ls)
  BO Candidate 1: Obj = 116.4828 (with current_X_ls)
  BO Candidate 2: Obj = 105.3669 (with current_X_ls)
    New best for this BO run: Obj=105.3669, U=[0 1 0 1 0 0 1 1 1 0 0 1 1 1 0 0 1 1 1 0]
    BO found a U that improves upon current_X_ls (Obj: 105.3669 &lt; inf).
  BO Candidate 3: Obj = 105.3669 (with current_X_ls)
  BO Candidate 4: Obj = 108.4865 (with current_X_ls)
  Best objective for current X in this BO run: 105.3669
  BO Iteration 19 completed in 7.03 sec.

--- BO Iteration 20/20 (LS Iter 1) ---
  BO Candidate 0: Obj = 116.5424 (with current_X_ls)
  BO Candidate 1: Obj = 109.7439 (with current_X_ls)
  BO Candidate 2: Obj = 103.0379 (with current_X_ls)
    New best for this BO run: Obj=103.0379, U=[0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 1 1 1]
    BO found a U that improves upon current_X_ls (Obj: 103.0379 &lt; 105.3669).
  BO Candidate 3: Obj = 109.1226 (with current_X_ls)
  BO Candidate 4: Obj = 108.1118 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 20 completed in 5.57 sec.

Finished BO for LS Iteration 1.
Best U found by BO for current_X_ls: [0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 1 1 1], Obj: 103.0379
Improvement found! New best obj 103.0379 &lt; obj of current X 105.9331
  Moving to new state Y: [3 0 2 0 1 1 0 2 0 1 1 0 2 0 1 1 1 1 1 6]
    New OVERALL best state found. Obj of new X: 103.0379


========== LOCAL SEARCH ITERATION 2/10 ==========
Current X for this LS iteration: [3 0 2 0 1 1 0 2 0 1 1 0 2 0 1 1 1 1 1 6]
BO Initial best objective for current X: 103.0379

--- BO Iteration 1/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 1 completed in 3.18 sec.

--- BO Iteration 2/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 113.8598 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 107.0622 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 2 completed in 3.71 sec.

--- BO Iteration 3/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.5049 (with current_X_ls)
  BO Candidate 3: Obj = 113.2261 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 3 completed in 3.29 sec.

--- BO Iteration 4/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 105.4335 (with current_X_ls)
  BO Candidate 2: Obj = 105.2476 (with current_X_ls)
  BO Candidate 3: Obj = 104.5542 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 4 completed in 3.06 sec.

--- BO Iteration 5/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 110.8725 (with current_X_ls)
  BO Candidate 1: Obj = 103.8253 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 104.7004 (with current_X_ls)
  BO Candidate 4: Obj = 103.7855 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 5 completed in 3.08 sec.

--- BO Iteration 6/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 6 completed in 3.67 sec.

--- BO Iteration 7/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 110.3426 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 108.9676 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 7 completed in 3.55 sec.

--- BO Iteration 8/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 8 completed in 3.69 sec.

--- BO Iteration 9/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 108.2470 (with current_X_ls)
  BO Candidate 1: Obj = 110.0732 (with current_X_ls)
  BO Candidate 2: Obj = 107.0296 (with current_X_ls)
  BO Candidate 3: Obj = 105.4274 (with current_X_ls)
  BO Candidate 4: Obj = 108.8094 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 9 completed in 3.88 sec.

--- BO Iteration 10/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 107.4360 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 106.3702 (with current_X_ls)
  BO Candidate 3: Obj = 104.5336 (with current_X_ls)
  BO Candidate 4: Obj = 108.1810 (with current_X_ls)
  Best objective for current X in this BO run: 103.0379
  BO Iteration 10 completed in 4.15 sec.

--- BO Iteration 11/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 110.1000 (with current_X_ls)
  BO Candidate 1: Obj = 108.5444 (with current_X_ls)
  BO Candidate 2: Obj = 104.6833 (with current_X_ls)
  BO Candidate 3: Obj = 102.9789 (with current_X_ls)
    New best for this BO run: Obj=102.9789, U=[0 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 1 1]
    BO found a U that improves upon current_X_ls (Obj: 102.9789 &lt; inf).
  BO Candidate 4: Obj = 102.4187 (with current_X_ls)
    New best for this BO run: Obj=102.4187, U=[0 0 1 0 0 0 0 0 0 1 1 0 1 0 1 0 0 1 1 1]
    BO found a U that improves upon current_X_ls (Obj: 102.4187 &lt; 102.9789).
  Best objective for current X in this BO run: 102.4187
  BO Iteration 11 completed in 5.17 sec.

--- BO Iteration 12/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 12 completed in 4.95 sec.

--- BO Iteration 13/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 111.3676 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 13 completed in 3.32 sec.

--- BO Iteration 14/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 106.9454 (with current_X_ls)
  BO Candidate 1: Obj = 107.4883 (with current_X_ls)
  BO Candidate 2: Obj = 109.4049 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 14 completed in 4.49 sec.

--- BO Iteration 15/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 104.7801 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 15 completed in 4.67 sec.

--- BO Iteration 16/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 106.0612 (with current_X_ls)
  BO Candidate 3: Obj = 105.1899 (with current_X_ls)
  BO Candidate 4: Obj = 105.1899 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 16 completed in 4.97 sec.

--- BO Iteration 17/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 111.4399 (with current_X_ls)
  BO Candidate 4: Obj = 109.8539 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 17 completed in 5.67 sec.

--- BO Iteration 18/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 104.3500 (with current_X_ls)
  BO Candidate 1: Obj = 104.4284 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 106.2031 (with current_X_ls)
  BO Candidate 4: Obj = 103.3047 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 18 completed in 4.97 sec.

--- BO Iteration 19/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 104.5275 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 107.8081 (with current_X_ls)
  BO Candidate 3: Obj = 102.9059 (with current_X_ls)
  BO Candidate 4: Obj = 107.5440 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 19 completed in 6.33 sec.

--- BO Iteration 20/20 (LS Iter 2) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 102.4187
  BO Iteration 20 completed in 5.89 sec.

Finished BO for LS Iteration 2.
Best U found by BO for current_X_ls: [0 0 1 0 0 0 0 0 0 1 1 0 1 0 1 0 0 1 1 1], Obj: 102.4187
Improvement found! New best obj 102.4187 &lt; obj of current X 103.0379
  Moving to new state Y: [3 1 1 0 1 1 0 2 1 1 0 1 1 1 0 1 2 1 1 5]
    New OVERALL best state found. Obj of new X: 102.4187


========== LOCAL SEARCH ITERATION 3/10 ==========
Current X for this LS iteration: [3 1 1 0 1 1 0 2 1 1 0 1 1 1 0 1 2 1 1 5]
BO Initial best objective for current X: 101.2785

--- BO Iteration 1/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 103.0279 (with current_X_ls)
  BO Candidate 1: Obj = 100.7176 (with current_X_ls)
    New best for this BO run: Obj=100.7176, U=[0 0 0 0 1 1 0 1 1 0 0 1 0 1 1 1 1 0 0 0]
    BO found a U that improves upon current_X_ls (Obj: 100.7176 &lt; inf).
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 106.5928 (with current_X_ls)
  BO Candidate 4: Obj = 103.0639 (with current_X_ls)
  Best objective for current X in this BO run: 100.7176
  BO Iteration 1 completed in 3.23 sec.

--- BO Iteration 2/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.6332 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.7176
  BO Iteration 2 completed in 2.74 sec.

--- BO Iteration 3/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 101.8826 (with current_X_ls)
  BO Candidate 1: Obj = 102.9805 (with current_X_ls)
  BO Candidate 2: Obj = 101.7908 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.7176
  BO Iteration 3 completed in 2.81 sec.

--- BO Iteration 4/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 100.2544 (with current_X_ls)
    New best for this BO run: Obj=100.2544, U=[0 1 0 0 0 0 0 1 0 0 0 0 1 1 1 1 1 0 0 0]
    BO found a U that improves upon current_X_ls (Obj: 100.2544 &lt; 100.7176).
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 105.7514 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 4 completed in 2.84 sec.

--- BO Iteration 5/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 107.7030 (with current_X_ls)
  BO Candidate 3: Obj = 112.0639 (with current_X_ls)
  BO Candidate 4: Obj = 105.3759 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 5 completed in 3.63 sec.

--- BO Iteration 6/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 101.4881 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.6245 (with current_X_ls)
  BO Candidate 3: Obj = 103.9148 (with current_X_ls)
  BO Candidate 4: Obj = 103.1974 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 6 completed in 3.36 sec.

--- BO Iteration 7/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 104.7126 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 107.5437 (with current_X_ls)
  BO Candidate 3: Obj = 107.6621 (with current_X_ls)
  BO Candidate 4: Obj = 111.2820 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 7 completed in 3.56 sec.

--- BO Iteration 8/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 108.9089 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 8 completed in 4.38 sec.

--- BO Iteration 9/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 112.0243 (with current_X_ls)
  BO Candidate 2: Obj = 106.8659 (with current_X_ls)
  BO Candidate 3: Obj = 107.9201 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 9 completed in 2.40 sec.

--- BO Iteration 10/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 111.1375 (with current_X_ls)
  BO Candidate 1: Obj = 106.4284 (with current_X_ls)
  BO Candidate 2: Obj = 105.9016 (with current_X_ls)
  BO Candidate 3: Obj = 107.8435 (with current_X_ls)
  BO Candidate 4: Obj = 101.3743 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 10 completed in 4.14 sec.

--- BO Iteration 11/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 106.2173 (with current_X_ls)
  BO Candidate 1: Obj = 101.5236 (with current_X_ls)
  BO Candidate 2: Obj = 106.9287 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 105.0060 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 11 completed in 4.54 sec.

--- BO Iteration 12/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 110.5369 (with current_X_ls)
  BO Candidate 1: Obj = 107.8037 (with current_X_ls)
  BO Candidate 2: Obj = 106.1053 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 12 completed in 2.86 sec.

--- BO Iteration 13/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 100.3612 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 13 completed in 3.27 sec.

--- BO Iteration 14/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 106.9474 (with current_X_ls)
  BO Candidate 3: Obj = 109.7595 (with current_X_ls)
  BO Candidate 4: Obj = 110.3371 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 14 completed in 5.31 sec.

--- BO Iteration 15/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 104.4909 (with current_X_ls)
  BO Candidate 1: Obj = 105.7322 (with current_X_ls)
  BO Candidate 2: Obj = 108.9040 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 105.1582 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 15 completed in 4.64 sec.

--- BO Iteration 16/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 101.7763 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 111.0242 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 16 completed in 4.86 sec.

--- BO Iteration 17/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 102.9035 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 17 completed in 3.42 sec.

--- BO Iteration 18/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 109.2774 (with current_X_ls)
  BO Candidate 1: Obj = 102.4980 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 106.1593 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 18 completed in 5.81 sec.

--- BO Iteration 19/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 110.4277 (with current_X_ls)
  BO Candidate 2: Obj = 110.4965 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 110.4577 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 19 completed in 4.58 sec.

--- BO Iteration 20/20 (LS Iter 3) ---
  BO Candidate 0: Obj = 106.1430 (with current_X_ls)
  BO Candidate 1: Obj = 109.7891 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 20 completed in 6.14 sec.

Finished BO for LS Iteration 3.
Best U found by BO for current_X_ls: [0 1 0 0 0 0 0 1 0 0 0 0 1 1 1 1 1 0 0 0], Obj: 100.2544
Improvement found! New best obj 100.2544 &lt; obj of current X 102.4187
  Moving to new state Y: [4 0 1 0 1 1 1 1 1 1 0 2 1 1 0 1 1 1 1 5]
    New OVERALL best state found. Obj of new X: 100.2544


========== LOCAL SEARCH ITERATION 4/10 ==========
Current X for this LS iteration: [4 0 1 0 1 1 1 1 1 1 0 2 1 1 0 1 1 1 1 5]
BO Initial best objective for current X: 100.2544

--- BO Iteration 1/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 100.9781 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 1 completed in 2.89 sec.

--- BO Iteration 2/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 107.0858 (with current_X_ls)
  BO Candidate 1: Obj = 106.7144 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 108.0289 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 2 completed in 3.42 sec.

--- BO Iteration 3/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.2385 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 102.5292 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 3 completed in 3.35 sec.

--- BO Iteration 4/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 101.4729 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 4 completed in 4.29 sec.

--- BO Iteration 5/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 101.6052 (with current_X_ls)
  BO Candidate 1: Obj = 102.2958 (with current_X_ls)
  BO Candidate 2: Obj = 103.0278 (with current_X_ls)
  BO Candidate 3: Obj = 104.9584 (with current_X_ls)
  BO Candidate 4: Obj = 102.7185 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 5 completed in 3.46 sec.

--- BO Iteration 6/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 105.6578 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 106.8742 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 6 completed in 3.77 sec.

--- BO Iteration 7/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 105.1578 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.5050 (with current_X_ls)
  BO Candidate 3: Obj = 103.6266 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 7 completed in 3.84 sec.

--- BO Iteration 8/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 102.8966 (with current_X_ls)
  BO Candidate 1: Obj = 105.8952 (with current_X_ls)
  BO Candidate 2: Obj = 103.8800 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 103.6891 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 8 completed in 4.04 sec.

--- BO Iteration 9/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 104.6903 (with current_X_ls)
  BO Candidate 1: Obj = 102.6893 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 9 completed in 3.66 sec.

--- BO Iteration 10/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 104.1438 (with current_X_ls)
  BO Candidate 1: Obj = 105.1963 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 105.3860 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 10 completed in 3.76 sec.

--- BO Iteration 11/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 105.2380 (with current_X_ls)
  BO Candidate 1: Obj = 102.4555 (with current_X_ls)
  BO Candidate 2: Obj = 106.0877 (with current_X_ls)
  BO Candidate 3: Obj = 105.0863 (with current_X_ls)
  BO Candidate 4: Obj = 104.1728 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 11 completed in 3.92 sec.

--- BO Iteration 12/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 106.1741 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 102.8835 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 12 completed in 4.10 sec.

--- BO Iteration 13/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 104.5049 (with current_X_ls)
  BO Candidate 1: Obj = 104.5049 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 102.8112 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 13 completed in 5.65 sec.

--- BO Iteration 14/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 101.6512 (with current_X_ls)
  BO Candidate 1: Obj = 104.7943 (with current_X_ls)
  BO Candidate 2: Obj = 104.3953 (with current_X_ls)
  BO Candidate 3: Obj = 106.2512 (with current_X_ls)
  BO Candidate 4: Obj = 102.3640 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 14 completed in 4.52 sec.

--- BO Iteration 15/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 103.5494 (with current_X_ls)
  BO Candidate 1: Obj = 103.3761 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 102.8852 (with current_X_ls)
  BO Candidate 4: Obj = 103.5179 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 15 completed in 4.81 sec.

--- BO Iteration 16/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 102.9433 (with current_X_ls)
  BO Candidate 1: Obj = 108.0892 (with current_X_ls)
  BO Candidate 2: Obj = 102.7794 (with current_X_ls)
  BO Candidate 3: Obj = 104.8559 (with current_X_ls)
  BO Candidate 4: Obj = 105.9760 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 16 completed in 5.63 sec.

--- BO Iteration 17/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 105.4183 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 17 completed in 4.29 sec.

--- BO Iteration 18/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 105.5281 (with current_X_ls)
  BO Candidate 1: Obj = 105.7844 (with current_X_ls)
  BO Candidate 2: Obj = 105.0407 (with current_X_ls)
  BO Candidate 3: Obj = 102.1690 (with current_X_ls)
  BO Candidate 4: Obj = 105.9067 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 18 completed in 5.02 sec.

--- BO Iteration 19/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 101.4323 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 19 completed in 5.59 sec.

--- BO Iteration 20/20 (LS Iter 4) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 101.9991 (with current_X_ls)
  BO Candidate 2: Obj = 101.3421 (with current_X_ls)
  BO Candidate 3: Obj = 101.8901 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 20 completed in 3.47 sec.

Finished BO for LS Iteration 4.
Best U found by BO for current_X_ls: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], Obj: 100.2544
No improvement over current_X_ls (Obj 100.2544 vs BO best 100.2544). Staying at current X.


========== LOCAL SEARCH ITERATION 5/10 ==========
Current X for this LS iteration: [4 0 1 0 1 1 1 1 1 1 0 2 1 1 0 1 1 1 1 5]
BO Initial best objective for current X: 100.2544

--- BO Iteration 1/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 103.7586 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 104.9204 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 1 completed in 3.00 sec.

--- BO Iteration 2/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 102.6996 (with current_X_ls)
  BO Candidate 1: Obj = 106.4191 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 104.5359 (with current_X_ls)
  BO Candidate 4: Obj = 106.7682 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 2 completed in 3.09 sec.

--- BO Iteration 3/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 105.0941 (with current_X_ls)
  BO Candidate 1: Obj = 102.5228 (with current_X_ls)
  BO Candidate 2: Obj = 100.3173 (with current_X_ls)
  BO Candidate 3: Obj = 102.4900 (with current_X_ls)
  BO Candidate 4: Obj = 103.1620 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 3 completed in 3.50 sec.

--- BO Iteration 4/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 103.0039 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 4 completed in 3.95 sec.

--- BO Iteration 5/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 104.3547 (with current_X_ls)
  BO Candidate 1: Obj = 102.2480 (with current_X_ls)
  BO Candidate 2: Obj = 102.7894 (with current_X_ls)
  BO Candidate 3: Obj = 103.9473 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 5 completed in 4.39 sec.

--- BO Iteration 6/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 104.6136 (with current_X_ls)
  BO Candidate 1: Obj = 102.4961 (with current_X_ls)
  BO Candidate 2: Obj = 103.7444 (with current_X_ls)
  BO Candidate 3: Obj = 104.4877 (with current_X_ls)
  BO Candidate 4: Obj = 103.3704 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 6 completed in 4.10 sec.

--- BO Iteration 7/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 107.2295 (with current_X_ls)
  BO Candidate 3: Obj = 105.1700 (with current_X_ls)
  BO Candidate 4: Obj = 105.7821 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 7 completed in 5.43 sec.

--- BO Iteration 8/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 104.7339 (with current_X_ls)
  BO Candidate 1: Obj = 102.5672 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 104.2034 (with current_X_ls)
  BO Candidate 4: Obj = 103.1122 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 8 completed in 3.91 sec.

--- BO Iteration 9/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 103.3612 (with current_X_ls)
  BO Candidate 1: Obj = 103.9450 (with current_X_ls)
  BO Candidate 2: Obj = 102.2358 (with current_X_ls)
  BO Candidate 3: Obj = 102.4114 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 9 completed in 3.85 sec.

--- BO Iteration 10/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 10 completed in 4.72 sec.

--- BO Iteration 11/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 104.3018 (with current_X_ls)
  BO Candidate 1: Obj = 103.7620 (with current_X_ls)
  BO Candidate 2: Obj = 104.7664 (with current_X_ls)
  BO Candidate 3: Obj = 103.5589 (with current_X_ls)
  BO Candidate 4: Obj = 103.9116 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 11 completed in 4.94 sec.

--- BO Iteration 12/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 104.5347 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 102.6223 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 12 completed in 7.15 sec.

--- BO Iteration 13/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 102.5025 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 105.7172 (with current_X_ls)
  BO Candidate 3: Obj = 107.2502 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 13 completed in 5.62 sec.

--- BO Iteration 14/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 14 completed in 5.39 sec.

--- BO Iteration 15/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 105.1307 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 103.8483 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 104.1753 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 15 completed in 5.32 sec.

--- BO Iteration 16/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 103.8590 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.9892 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 16 completed in 5.88 sec.

--- BO Iteration 17/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 102.6703 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 103.8930 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 17 completed in 5.18 sec.

--- BO Iteration 18/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 18 completed in 3.76 sec.

--- BO Iteration 19/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 103.2240 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 102.2896 (with current_X_ls)
  BO Candidate 3: Obj = 104.6835 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 19 completed in 6.77 sec.

--- BO Iteration 20/20 (LS Iter 5) ---
  BO Candidate 0: Obj = 104.5236 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 20 completed in 3.65 sec.

Finished BO for LS Iteration 5.
Best U found by BO for current_X_ls: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], Obj: 100.2544
No improvement over current_X_ls (Obj 100.2544 vs BO best 100.2544). Staying at current X.


========== LOCAL SEARCH ITERATION 6/10 ==========
Current X for this LS iteration: [4 0 1 0 1 1 1 1 1 1 0 2 1 1 0 1 1 1 1 5]
BO Initial best objective for current X: 100.2544

--- BO Iteration 1/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 104.6631 (with current_X_ls)
  BO Candidate 1: Obj = 103.9249 (with current_X_ls)
  BO Candidate 2: Obj = 102.7693 (with current_X_ls)
  BO Candidate 3: Obj = 103.5422 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 1 completed in 4.83 sec.

--- BO Iteration 2/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 104.1325 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 2 completed in 3.34 sec.

--- BO Iteration 3/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 103.8609 (with current_X_ls)
  BO Candidate 2: Obj = 104.7553 (with current_X_ls)
  BO Candidate 3: Obj = 104.6892 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 3 completed in 3.82 sec.

--- BO Iteration 4/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 101.6541 (with current_X_ls)
  BO Candidate 1: Obj = 104.1646 (with current_X_ls)
  BO Candidate 2: Obj = 102.4302 (with current_X_ls)
  BO Candidate 3: Obj = 102.4302 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 4 completed in 3.69 sec.

--- BO Iteration 5/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 103.7726 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 101.9215 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 5 completed in 4.02 sec.

--- BO Iteration 6/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 105.5905 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 6 completed in 3.64 sec.

--- BO Iteration 7/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 101.1383 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 7 completed in 3.60 sec.

--- BO Iteration 8/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 105.5378 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 103.2351 (with current_X_ls)
  Best objective for current X in this BO run: 100.2544
  BO Iteration 8 completed in 4.28 sec.

--- BO Iteration 9/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 99.8386 (with current_X_ls)
    New best for this BO run: Obj=99.8386, U=[0 0 1 0 1 1 1 0 0 0 0 1 0 0 0 1 1 1 1 1]
    BO found a U that improves upon current_X_ls (Obj: 99.8386 &lt; inf).
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 102.2933 (with current_X_ls)
  BO Candidate 3: Obj = 104.6689 (with current_X_ls)
  BO Candidate 4: Obj = 103.5465 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 9 completed in 4.53 sec.

--- BO Iteration 10/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 106.7554 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 106.0610 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 10 completed in 4.63 sec.

--- BO Iteration 11/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 104.9585 (with current_X_ls)
  BO Candidate 1: Obj = 105.1096 (with current_X_ls)
  BO Candidate 2: Obj = 103.8365 (with current_X_ls)
  BO Candidate 3: Obj = 103.3830 (with current_X_ls)
  BO Candidate 4: Obj = 103.9327 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 11 completed in 4.66 sec.

--- BO Iteration 12/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 103.2161 (with current_X_ls)
  BO Candidate 1: Obj = 103.5278 (with current_X_ls)
  BO Candidate 2: Obj = 101.8521 (with current_X_ls)
  BO Candidate 3: Obj = 102.0327 (with current_X_ls)
  BO Candidate 4: Obj = 101.8181 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 12 completed in 3.12 sec.

--- BO Iteration 13/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 13 completed in 4.26 sec.

--- BO Iteration 14/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 104.8442 (with current_X_ls)
  BO Candidate 1: Obj = 104.3559 (with current_X_ls)
  BO Candidate 2: Obj = 104.1935 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 14 completed in 5.18 sec.

--- BO Iteration 15/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 102.9483 (with current_X_ls)
  BO Candidate 1: Obj = 104.9382 (with current_X_ls)
  BO Candidate 2: Obj = 104.2069 (with current_X_ls)
  BO Candidate 3: Obj = 103.4583 (with current_X_ls)
  BO Candidate 4: Obj = 103.1826 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 15 completed in 4.86 sec.

--- BO Iteration 16/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 104.7253 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 103.4257 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 16 completed in 2.64 sec.

--- BO Iteration 17/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 106.7236 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 101.8827 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 17 completed in 4.51 sec.

--- BO Iteration 18/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 101.6479 (with current_X_ls)
  BO Candidate 1: Obj = 103.9799 (with current_X_ls)
  BO Candidate 2: Obj = 106.5250 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 105.0512 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 18 completed in 4.77 sec.

--- BO Iteration 19/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 103.0316 (with current_X_ls)
  BO Candidate 1: Obj = 104.0400 (with current_X_ls)
  BO Candidate 2: Obj = 106.4262 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 104.2497 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 19 completed in 7.14 sec.

--- BO Iteration 20/20 (LS Iter 6) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 102.4482 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 101.9717 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 20 completed in 6.69 sec.

Finished BO for LS Iteration 6.
Best U found by BO for current_X_ls: [0 0 1 0 1 1 1 0 0 0 0 1 0 0 0 1 1 1 1 1], Obj: 99.8386
Improvement found! New best obj 99.8386 &lt; obj of current X 100.2544
  Moving to new state Y: [4 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 4]
    New OVERALL best state found. Obj of new X: 99.8386


========== LOCAL SEARCH ITERATION 7/10 ==========
Current X for this LS iteration: [4 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 4]
BO Initial best objective for current X: 99.8386

--- BO Iteration 1/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 102.2328 (with current_X_ls)
  BO Candidate 1: Obj = 103.6598 (with current_X_ls)
  BO Candidate 2: Obj = 102.9488 (with current_X_ls)
  BO Candidate 3: Obj = 101.6790 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 1 completed in 2.94 sec.

--- BO Iteration 2/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 101.4687 (with current_X_ls)
  BO Candidate 1: Obj = 105.3676 (with current_X_ls)
  BO Candidate 2: Obj = 101.2171 (with current_X_ls)
  BO Candidate 3: Obj = 105.8486 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 2 completed in 2.99 sec.

--- BO Iteration 3/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 102.0779 (with current_X_ls)
  BO Candidate 1: Obj = 101.8523 (with current_X_ls)
  BO Candidate 2: Obj = 105.3059 (with current_X_ls)
  BO Candidate 3: Obj = 101.9416 (with current_X_ls)
  BO Candidate 4: Obj = 106.2507 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 3 completed in 2.79 sec.

--- BO Iteration 4/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 106.2551 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 100.5003 (with current_X_ls)
  BO Candidate 3: Obj = 105.2887 (with current_X_ls)
  BO Candidate 4: Obj = 100.9123 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 4 completed in 3.00 sec.

--- BO Iteration 5/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 106.9286 (with current_X_ls)
  BO Candidate 1: Obj = 105.4975 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 106.4964 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 5 completed in 3.48 sec.

--- BO Iteration 6/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 105.6521 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 105.8116 (with current_X_ls)
  BO Candidate 3: Obj = 101.5658 (with current_X_ls)
  BO Candidate 4: Obj = 101.2943 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 6 completed in 2.68 sec.

--- BO Iteration 7/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 103.4600 (with current_X_ls)
  BO Candidate 1: Obj = 103.5917 (with current_X_ls)
  BO Candidate 2: Obj = 103.5917 (with current_X_ls)
  BO Candidate 3: Obj = 103.3535 (with current_X_ls)
  BO Candidate 4: Obj = 102.3568 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 7 completed in 3.81 sec.

--- BO Iteration 8/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 102.1492 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 105.8770 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 101.6009 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 8 completed in 3.92 sec.

--- BO Iteration 9/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 104.4073 (with current_X_ls)
  BO Candidate 2: Obj = 104.5489 (with current_X_ls)
  BO Candidate 3: Obj = 103.3749 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 9 completed in 3.61 sec.

--- BO Iteration 10/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 106.9631 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 107.2316 (with current_X_ls)
  BO Candidate 3: Obj = 101.5227 (with current_X_ls)
  BO Candidate 4: Obj = 103.5420 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 10 completed in 4.21 sec.

--- BO Iteration 11/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 101.3211 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 101.9705 (with current_X_ls)
  BO Candidate 4: Obj = 106.6700 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 11 completed in 4.15 sec.

--- BO Iteration 12/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 105.0121 (with current_X_ls)
  BO Candidate 1: Obj = 101.4872 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 103.2051 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 12 completed in 4.55 sec.

--- BO Iteration 13/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 104.8981 (with current_X_ls)
  BO Candidate 1: Obj = 104.6372 (with current_X_ls)
  BO Candidate 2: Obj = 106.1304 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 104.8526 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 13 completed in 3.96 sec.

--- BO Iteration 14/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 103.7915 (with current_X_ls)
  BO Candidate 1: Obj = 104.2298 (with current_X_ls)
  BO Candidate 2: Obj = 102.6601 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 107.0259 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 14 completed in 3.70 sec.

--- BO Iteration 15/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 102.2759 (with current_X_ls)
  BO Candidate 1: Obj = 105.7660 (with current_X_ls)
  BO Candidate 2: Obj = 101.8942 (with current_X_ls)
  BO Candidate 3: Obj = 105.2754 (with current_X_ls)
  BO Candidate 4: Obj = 107.0787 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 15 completed in 4.01 sec.

--- BO Iteration 16/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 104.8361 (with current_X_ls)
  BO Candidate 1: Obj = 106.6435 (with current_X_ls)
  BO Candidate 2: Obj = 106.4270 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 106.0576 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 16 completed in 5.90 sec.

--- BO Iteration 17/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 101.2041 (with current_X_ls)
  BO Candidate 1: Obj = 101.5896 (with current_X_ls)
  BO Candidate 2: Obj = 102.5993 (with current_X_ls)
  BO Candidate 3: Obj = 101.8873 (with current_X_ls)
  BO Candidate 4: Obj = 101.6032 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 17 completed in 5.56 sec.

--- BO Iteration 18/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 107.2682 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 107.2476 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 18 completed in 7.10 sec.

--- BO Iteration 19/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 101.6887 (with current_X_ls)
  BO Candidate 1: Obj = 105.5425 (with current_X_ls)
  BO Candidate 2: Obj = 105.7175 (with current_X_ls)
  BO Candidate 3: Obj = 105.3399 (with current_X_ls)
  BO Candidate 4: Obj = 104.8039 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 19 completed in 7.74 sec.

--- BO Iteration 20/20 (LS Iter 7) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 100.3901 (with current_X_ls)
  BO Candidate 3: Obj = 100.1031 (with current_X_ls)
  BO Candidate 4: Obj = 104.4143 (with current_X_ls)
  Best objective for current X in this BO run: 99.8386
  BO Iteration 20 completed in 6.68 sec.

Finished BO for LS Iteration 7.
Best U found by BO for current_X_ls: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], Obj: 99.8386
No improvement over current_X_ls (Obj 99.8386 vs BO best 99.8386). Staying at current X.


========== LOCAL SEARCH ITERATION 8/10 ==========
Current X for this LS iteration: [4 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 4]
BO Initial best objective for current X: 99.0144

--- BO Iteration 1/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 106.1086 (with current_X_ls)
  BO Candidate 1: Obj = 101.2730 (with current_X_ls)
  BO Candidate 2: Obj = 102.4801 (with current_X_ls)
  BO Candidate 3: Obj = 106.6070 (with current_X_ls)
  BO Candidate 4: Obj = 102.6904 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 1 completed in 2.97 sec.

--- BO Iteration 2/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 104.5937 (with current_X_ls)
  BO Candidate 1: Obj = 100.3267 (with current_X_ls)
  BO Candidate 2: Obj = 101.3908 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 101.4105 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 2 completed in 2.97 sec.

--- BO Iteration 3/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 102.4263 (with current_X_ls)
  BO Candidate 1: Obj = 107.7335 (with current_X_ls)
  BO Candidate 2: Obj = 105.7035 (with current_X_ls)
  BO Candidate 3: Obj = 108.5005 (with current_X_ls)
  BO Candidate 4: Obj = 106.5992 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 3 completed in 3.86 sec.

--- BO Iteration 4/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 103.5646 (with current_X_ls)
  BO Candidate 1: Obj = 103.4665 (with current_X_ls)
  BO Candidate 2: Obj = 103.2028 (with current_X_ls)
  BO Candidate 3: Obj = 107.7140 (with current_X_ls)
  BO Candidate 4: Obj = 102.2116 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 4 completed in 3.03 sec.

--- BO Iteration 5/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 106.4955 (with current_X_ls)
  BO Candidate 1: Obj = 104.7959 (with current_X_ls)
  BO Candidate 2: Obj = 105.8311 (with current_X_ls)
  BO Candidate 3: Obj = 106.5066 (with current_X_ls)
  BO Candidate 4: Obj = 104.7346 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 5 completed in 3.77 sec.

--- BO Iteration 6/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 105.4549 (with current_X_ls)
  BO Candidate 1: Obj = 103.0202 (with current_X_ls)
  BO Candidate 2: Obj = 103.0770 (with current_X_ls)
  BO Candidate 3: Obj = 103.5845 (with current_X_ls)
  BO Candidate 4: Obj = 102.8432 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 6 completed in 3.41 sec.

--- BO Iteration 7/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 101.0578 (with current_X_ls)
  BO Candidate 1: Obj = 101.2165 (with current_X_ls)
  BO Candidate 2: Obj = 105.8341 (with current_X_ls)
  BO Candidate 3: Obj = 100.6249 (with current_X_ls)
  BO Candidate 4: Obj = 101.8353 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 7 completed in 3.79 sec.

--- BO Iteration 8/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 102.1905 (with current_X_ls)
  BO Candidate 4: Obj = 102.0802 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 8 completed in 3.61 sec.

--- BO Iteration 9/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 101.9906 (with current_X_ls)
  BO Candidate 2: Obj = 102.3899 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 9 completed in 3.12 sec.

--- BO Iteration 10/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 105.1378 (with current_X_ls)
  BO Candidate 2: Obj = 107.0516 (with current_X_ls)
  BO Candidate 3: Obj = 105.7648 (with current_X_ls)
  BO Candidate 4: Obj = 104.4505 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 10 completed in 3.50 sec.

--- BO Iteration 11/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 107.5179 (with current_X_ls)
  BO Candidate 1: Obj = 107.1333 (with current_X_ls)
  BO Candidate 2: Obj = 107.4980 (with current_X_ls)
  BO Candidate 3: Obj = 106.7960 (with current_X_ls)
  BO Candidate 4: Obj = 102.9739 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 11 completed in 5.14 sec.

--- BO Iteration 12/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 102.8579 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 12 completed in 7.44 sec.

--- BO Iteration 13/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 102.3405 (with current_X_ls)
  BO Candidate 1: Obj = 102.1766 (with current_X_ls)
  BO Candidate 2: Obj = 106.2839 (with current_X_ls)
  BO Candidate 3: Obj = 106.9670 (with current_X_ls)
  BO Candidate 4: Obj = 103.9050 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 13 completed in 5.26 sec.

--- BO Iteration 14/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 107.3509 (with current_X_ls)
  BO Candidate 1: Obj = 102.5705 (with current_X_ls)
  BO Candidate 2: Obj = 107.4802 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 103.0885 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 14 completed in 6.10 sec.

--- BO Iteration 15/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 102.9030 (with current_X_ls)
  BO Candidate 1: Obj = 103.8232 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 103.1453 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 15 completed in 5.13 sec.

--- BO Iteration 16/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 103.0359 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 107.5721 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 16 completed in 4.71 sec.

--- BO Iteration 17/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 103.8563 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.1767 (with current_X_ls)
  BO Candidate 3: Obj = 104.0113 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 17 completed in 5.74 sec.

--- BO Iteration 18/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 101.7421 (with current_X_ls)
  BO Candidate 1: Obj = 107.1131 (with current_X_ls)
  BO Candidate 2: Obj = 107.9879 (with current_X_ls)
  BO Candidate 3: Obj = 107.9879 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 18 completed in 6.13 sec.

--- BO Iteration 19/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 103.1326 (with current_X_ls)
  BO Candidate 1: Obj = 107.6349 (with current_X_ls)
  BO Candidate 2: Obj = 102.8759 (with current_X_ls)
  BO Candidate 3: Obj = 102.4742 (with current_X_ls)
  BO Candidate 4: Obj = 107.3296 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 19 completed in 7.75 sec.

--- BO Iteration 20/20 (LS Iter 8) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 101.8782 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 103.0775 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 20 completed in 6.53 sec.

Finished BO for LS Iteration 8.
Best U found by BO for current_X_ls: [1 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 1 1 1 1], Obj: 99.0144
Improvement found! New best obj 99.0144 &lt; obj of current X 99.8386
  Moving to new state Y: [3 1 0 1 1 2 0 1 1 1 1 0 1 2 1 1 1 1 1 4]
    New OVERALL best state found. Obj of new X: 99.0144


========== LOCAL SEARCH ITERATION 9/10 ==========
Current X for this LS iteration: [3 1 0 1 1 2 0 1 1 1 1 0 1 2 1 1 1 1 1 4]
BO Initial best objective for current X: 99.0144

--- BO Iteration 1/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 105.0165 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 101.2411 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 1 completed in 3.59 sec.

--- BO Iteration 2/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 106.1924 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 105.3380 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 2 completed in 4.39 sec.

--- BO Iteration 3/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 103.9944 (with current_X_ls)
  BO Candidate 1: Obj = 102.4403 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 102.8847 (with current_X_ls)
  BO Candidate 4: Obj = 102.6103 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 3 completed in 3.99 sec.

--- BO Iteration 4/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 106.8022 (with current_X_ls)
  BO Candidate 1: Obj = 105.7587 (with current_X_ls)
  BO Candidate 2: Obj = 104.9983 (with current_X_ls)
  BO Candidate 3: Obj = 104.9983 (with current_X_ls)
  BO Candidate 4: Obj = 105.5959 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 4 completed in 4.03 sec.

--- BO Iteration 5/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 104.6722 (with current_X_ls)
  BO Candidate 1: Obj = 104.2948 (with current_X_ls)
  BO Candidate 2: Obj = 103.6575 (with current_X_ls)
  BO Candidate 3: Obj = 106.3040 (with current_X_ls)
  BO Candidate 4: Obj = 105.2382 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 5 completed in 4.71 sec.

--- BO Iteration 6/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 103.5212 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 6 completed in 4.92 sec.

--- BO Iteration 7/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 99.4938 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 102.2674 (with current_X_ls)
  BO Candidate 3: Obj = 102.1160 (with current_X_ls)
  BO Candidate 4: Obj = 102.7106 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 7 completed in 4.69 sec.

--- BO Iteration 8/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 106.8416 (with current_X_ls)
  BO Candidate 1: Obj = 103.2800 (with current_X_ls)
  BO Candidate 2: Obj = 103.0785 (with current_X_ls)
  BO Candidate 3: Obj = 102.9009 (with current_X_ls)
  BO Candidate 4: Obj = 106.6908 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 8 completed in 4.78 sec.

--- BO Iteration 9/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 99.7176 (with current_X_ls)
  BO Candidate 1: Obj = 102.4716 (with current_X_ls)
  BO Candidate 2: Obj = 103.1893 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 102.4347 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 9 completed in 4.88 sec.

--- BO Iteration 10/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 104.0397 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 104.6964 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 10 completed in 5.15 sec.

--- BO Iteration 11/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 104.7957 (with current_X_ls)
  BO Candidate 2: Obj = 104.5060 (with current_X_ls)
  BO Candidate 3: Obj = 104.3629 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 11 completed in 4.04 sec.

--- BO Iteration 12/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 106.3356 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 12 completed in 7.26 sec.

--- BO Iteration 13/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 105.1529 (with current_X_ls)
  BO Candidate 2: Obj = 101.6255 (with current_X_ls)
  BO Candidate 3: Obj = 102.2449 (with current_X_ls)
  BO Candidate 4: Obj = 102.6179 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 13 completed in 6.08 sec.

--- BO Iteration 14/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 104.8197 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 103.4153 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 14 completed in 8.70 sec.

--- BO Iteration 15/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 101.9293 (with current_X_ls)
  BO Candidate 1: Obj = 103.9686 (with current_X_ls)
  BO Candidate 2: Obj = 103.3801 (with current_X_ls)
  BO Candidate 3: Obj = 102.9361 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 15 completed in 5.82 sec.

--- BO Iteration 16/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 104.4834 (with current_X_ls)
  BO Candidate 2: Obj = 102.6695 (with current_X_ls)
  BO Candidate 3: Obj = 105.6199 (with current_X_ls)
  BO Candidate 4: Obj = 105.6199 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 16 completed in 7.36 sec.

--- BO Iteration 17/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 106.0140 (with current_X_ls)
  BO Candidate 4: Obj = 105.1853 (with current_X_ls)
  Best objective for current X in this BO run: 99.0144
  BO Iteration 17 completed in 9.73 sec.

--- BO Iteration 18/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 105.3147 (with current_X_ls)
  BO Candidate 1: Obj = 104.8761 (with current_X_ls)
  BO Candidate 2: Obj = 103.9208 (with current_X_ls)
  BO Candidate 3: Obj = 103.9874 (with current_X_ls)
  BO Candidate 4: Obj = 98.3451 (with current_X_ls)
    New best for this BO run: Obj=98.3451, U=[1 1 0 1 1 1 0 0 0 0 0 0 1 1 0 0 1 0 1 1]
    BO found a U that improves upon current_X_ls (Obj: 98.3451 &lt; inf).
  Best objective for current X in this BO run: 98.3451
  BO Iteration 18 completed in 5.07 sec.

--- BO Iteration 19/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 103.5154 (with current_X_ls)
  BO Candidate 1: Obj = 103.5874 (with current_X_ls)
  BO Candidate 2: Obj = 98.4904 (with current_X_ls)
  BO Candidate 3: Obj = 99.7024 (with current_X_ls)
  BO Candidate 4: Obj = 98.6329 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 19 completed in 8.73 sec.

--- BO Iteration 20/20 (LS Iter 9) ---
  BO Candidate 0: Obj = 104.5445 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 105.2944 (with current_X_ls)
  BO Candidate 3: Obj = 101.6830 (with current_X_ls)
  BO Candidate 4: Obj = 103.1152 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 20 completed in 6.49 sec.

Finished BO for LS Iteration 9.
Best U found by BO for current_X_ls: [1 1 0 1 1 1 0 0 0 0 0 0 1 1 0 0 1 0 1 1], Obj: 98.3451
Improvement found! New best obj 98.3451 &lt; obj of current X 99.0144
  Moving to new state Y: [3 0 1 1 1 1 0 1 1 1 1 1 1 1 1 2 0 2 1 4]
    New OVERALL best state found. Obj of new X: 98.3451


========== LOCAL SEARCH ITERATION 10/10 ==========
Current X for this LS iteration: [3 0 1 1 1 1 0 1 1 1 1 1 1 1 1 2 0 2 1 4]
BO Initial best objective for current X: 98.3451

--- BO Iteration 1/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 106.2403 (with current_X_ls)
  BO Candidate 2: Obj = 101.0994 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 107.4513 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 1 completed in 3.27 sec.

--- BO Iteration 2/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 101.5719 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 101.6435 (with current_X_ls)
  BO Candidate 3: Obj = 104.3316 (with current_X_ls)
  BO Candidate 4: Obj = 104.7783 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 2 completed in 3.06 sec.

--- BO Iteration 3/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 101.8302 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 101.7387 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 3 completed in 3.73 sec.

--- BO Iteration 4/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 103.2925 (with current_X_ls)
  BO Candidate 1: Obj = 101.4615 (with current_X_ls)
  BO Candidate 2: Obj = 101.6724 (with current_X_ls)
  BO Candidate 3: Obj = 103.7291 (with current_X_ls)
  BO Candidate 4: Obj = 103.7213 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 4 completed in 3.53 sec.

--- BO Iteration 5/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 100.2803 (with current_X_ls)
  BO Candidate 1: Obj = 102.7303 (with current_X_ls)
  BO Candidate 2: Obj = 104.6160 (with current_X_ls)
  BO Candidate 3: Obj = 100.8881 (with current_X_ls)
  BO Candidate 4: Obj = 102.0994 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 5 completed in 3.65 sec.

--- BO Iteration 6/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 102.8981 (with current_X_ls)
  BO Candidate 1: Obj = 101.6975 (with current_X_ls)
  BO Candidate 2: Obj = 102.6573 (with current_X_ls)
  BO Candidate 3: Obj = 101.1204 (with current_X_ls)
  BO Candidate 4: Obj = 102.1257 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 6 completed in 4.00 sec.

--- BO Iteration 7/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 102.6542 (with current_X_ls)
  BO Candidate 1: Obj = 101.7804 (with current_X_ls)
  BO Candidate 2: Obj = 100.9683 (with current_X_ls)
  BO Candidate 3: Obj = 103.2382 (with current_X_ls)
  BO Candidate 4: Obj = 101.2125 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 7 completed in 3.37 sec.

--- BO Iteration 8/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 103.4674 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 8 completed in 4.01 sec.

--- BO Iteration 9/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 102.9611 (with current_X_ls)
  BO Candidate 2: Obj = 101.0391 (with current_X_ls)
  BO Candidate 3: Obj = 104.8303 (with current_X_ls)
  BO Candidate 4: Obj = 102.5186 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 9 completed in 3.87 sec.

--- BO Iteration 10/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 106.9856 (with current_X_ls)
  BO Candidate 2: Obj = 105.9560 (with current_X_ls)
  BO Candidate 3: Obj = 103.5001 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 10 completed in 4.53 sec.

--- BO Iteration 11/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 101.6206 (with current_X_ls)
  BO Candidate 1: Obj = 104.7557 (with current_X_ls)
  BO Candidate 2: Obj = 105.4256 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 11 completed in 4.17 sec.

--- BO Iteration 12/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 102.0257 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 100.7102 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 12 completed in 4.34 sec.

--- BO Iteration 13/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 102.3498 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 105.5566 (with current_X_ls)
  BO Candidate 3: Obj = 104.0339 (with current_X_ls)
  BO Candidate 4: Obj = 104.2637 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 13 completed in 4.43 sec.

--- BO Iteration 14/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 100.8637 (with current_X_ls)
  BO Candidate 1: Obj = 101.2565 (with current_X_ls)
  BO Candidate 2: Obj = 106.2813 (with current_X_ls)
  BO Candidate 3: Obj = 101.6569 (with current_X_ls)
  BO Candidate 4: Obj = 100.9968 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 14 completed in 4.22 sec.

--- BO Iteration 15/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 102.3735 (with current_X_ls)
  BO Candidate 2: Obj = 104.7136 (with current_X_ls)
  BO Candidate 3: Obj = 102.0294 (with current_X_ls)
  BO Candidate 4: Obj = 102.6670 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 15 completed in 4.61 sec.

--- BO Iteration 16/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 103.6429 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 10000000000.0000 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 16 completed in 4.72 sec.

--- BO Iteration 17/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 102.4856 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 100.4501 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 17 completed in 6.02 sec.

--- BO Iteration 18/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 101.1975 (with current_X_ls)
  BO Candidate 1: Obj = 101.1741 (with current_X_ls)
  BO Candidate 2: Obj = 101.1419 (with current_X_ls)
  BO Candidate 3: Obj = 101.1432 (with current_X_ls)
  BO Candidate 4: Obj = 102.4150 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 18 completed in 6.06 sec.

--- BO Iteration 19/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 1: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 2: Obj = 101.4865 (with current_X_ls)
  BO Candidate 3: Obj = 10000000000.0000 (with current_X_ls)
  BO Candidate 4: Obj = 104.5537 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 19 completed in 6.31 sec.

--- BO Iteration 20/20 (LS Iter 10) ---
  BO Candidate 0: Obj = 106.8403 (with current_X_ls)
  BO Candidate 1: Obj = 102.3091 (with current_X_ls)
  BO Candidate 2: Obj = 100.7621 (with current_X_ls)
  BO Candidate 3: Obj = 101.0283 (with current_X_ls)
  BO Candidate 4: Obj = 101.3363 (with current_X_ls)
  Best objective for current X in this BO run: 98.3451
  BO Iteration 20 completed in 8.19 sec.

Finished BO for LS Iteration 10.
Best U found by BO for current_X_ls: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], Obj: 98.3451
No improvement over current_X_ls (Obj 98.3451 vs BO best 98.3451). Staying at current X.


========== LOCAL SEARCH FINISHED ==========
Best Overall Objective (of the final X state): 98.3451
Best Overall Y (final state vector): [3 0 1 1 1 1 0 1 1 1 1 1 1 1 1 2 0 2 1 4]

--- Verification of Final Best Local Search State ---
Is the best Y_ls feasible? True
Objective value of best Y_ls (recalculated): 98.3451
Total time taken for Local Search: 900.09 seconds</code></pre>
</div>
</div>
</section>
<section id="experiment-2" class="level4">
<h4 class="anchored" data-anchor-id="experiment-2">5. Experiment 2:</h4>
<div id="443418e8" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Local Search with Embedded BO (Stricter First Improvement) ---</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>MAX_LOCAL_SEARCH_ITERATIONS <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>CONVERGENCE_TOLERANCE <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>NO_IMPROVEMENT_STREAK_LIMIT <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>KAPPA <span class="op">=</span> <span class="fl">2.576</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>N_INITIAL_BO <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>N_ITERATIONS_BO <span class="op">=</span> <span class="dv">20</span> <span class="co"># Max BO iterations *if no improvement is found earlier*</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>BATCH_SIZE_q <span class="op">=</span> <span class="dv">5</span>     <span class="co"># Number of candidates BO proposes at once</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> math.ceil(T<span class="op">/</span><span class="dv">2</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>NUM_CANDIDATES_Acqf <span class="op">=</span> (T <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">1024</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">100</span> <span class="co"># Ensure Acqf has candidates even if T=0 (though U will be empty)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>current_X_ls <span class="op">=</span> np.copy(X)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>best_overall_f_ls <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>best_overall_Y_ls <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>no_improvement_streak <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial evaluation of the starting X state</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>obj_of_initial_X <span class="op">=</span> evaluate_objective(np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.array([]), current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>best_overall_f_ls <span class="op">=</span> obj_of_initial_X</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>best_overall_Y_ls <span class="op">=</span> np.copy(current_X_ls)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Starting Local Search. Initial X obj: </span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ls_iter <span class="kw">in</span> <span class="bu">range</span>(MAX_LOCAL_SEARCH_ITERATIONS):</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n\n</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss"> LOCAL SEARCH ITERATION </span><span class="sc">{</span>ls_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>MAX_LOCAL_SEARCH_ITERATIONS<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Current X for this LS iteration (Obj: </span><span class="sc">{</span>evaluate_objective(np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.array([]), current_X_ls, v_star, convolutions, d, w)<span class="sc">:.4f}</span><span class="ss">)"</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The baseline to beat in this LS iteration is the objective of current_X_ls with no modifications</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    baseline_obj_for_ls_iter <span class="op">=</span> evaluate_objective(np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.array([]), current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Baseline objective to beat for current X: </span><span class="sc">{</span>baseline_obj_for_ls_iter<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    bo_found_improving_U <span class="op">=</span> <span class="va">False</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    best_U_from_bo_for_current_X <span class="op">=</span> np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.array([])</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    best_f_from_bo_for_current_X <span class="op">=</span> baseline_obj_for_ls_iter <span class="co"># Start with baseline</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- BO Loop (inner loop) ---</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_list_bo <span class="op">=</span> []</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    evaluated_f_vals_bo <span class="op">=</span> []</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    train_Y_list_bo <span class="op">=</span> []</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Initialization for BO</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># Only generate U candidates if T &gt; 0</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        bo_initial_points <span class="op">=</span> [np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>T) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(N_INITIAL_BO)]</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        bo_initial_points.insert(<span class="dv">0</span>, np.zeros(T, dtype<span class="op">=</span><span class="bu">int</span>)) <span class="co"># Add U=zeros as the first point</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">any</span>(np.<span class="bu">any</span>(u) <span class="cf">for</span> u <span class="kw">in</span> bo_initial_points) <span class="kw">and</span> N_INITIAL_BO <span class="op">&gt;</span> <span class="dv">0</span> :</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>            idx_to_set <span class="op">=</span> np.random.randint(T)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>            bo_initial_points[<span class="dv">0</span>][idx_to_set] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># T=0</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>        bo_initial_points <span class="op">=</span> [np.array([])] <span class="co"># U is empty if T=0</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> U_init <span class="kw">in</span> bo_initial_points:</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>        f_val <span class="op">=</span> evaluate_objective(U_init, current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>        neg_f_val <span class="op">=</span> <span class="op">-</span>f_val</span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list_bo.append(U_init)</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals_bo.append(f_val)</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>        train_Y_list_bo.append(neg_f_val)</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> f_val <span class="op">&lt;</span> best_f_from_bo_for_current_X:</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>            best_f_from_bo_for_current_X <span class="op">=</span> f_val</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>            best_U_from_bo_for_current_X <span class="op">=</span> U_init</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> f_val <span class="op">&lt;</span> baseline_obj_for_ls_iter <span class="op">-</span> CONVERGENCE_TOLERANCE:</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"  BO Init found immediate improver U=</span><span class="sc">{</span>U_init<span class="sc">}</span><span class="ss">, Obj=</span><span class="sc">{</span>f_val<span class="sc">:.4f}</span><span class="ss"> (beats </span><span class="sc">{</span>baseline_obj_for_ls_iter<span class="sc">:.4f}</span><span class="ss">)"</span>)</span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>                bo_found_improving_U <span class="op">=</span> <span class="va">True</span></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span> <span class="co"># Exit BO initialization loop</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> bo_found_improving_U: <span class="co"># If init found improvement, skip further BO iterations</span></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span> <span class="co"># Proceed to LS decision block</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># Continue with BO iterations if no immediate improvement from init</span></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> bo_iter <span class="kw">in</span> <span class="bu">range</span>(N_ITERATIONS_BO):</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- BO Iteration </span><span class="sc">{</span>bo_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>N_ITERATIONS_BO<span class="sc">}</span><span class="ss"> (LS Iter </span><span class="sc">{</span>ls_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">) ---"</span>)</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>            start_time_bo <span class="op">=</span> time.time()</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>            current_dictionary_A <span class="op">=</span> generate_diverse_random_dictionary(T, m)</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> evaluated_U_np_list_bo: <span class="cf">continue</span></span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>            evaluated_U_np_array_bo <span class="op">=</span> np.array(evaluated_U_np_list_bo, dtype<span class="op">=</span><span class="bu">object</span>) <span class="co"># dtype=object for ragged arrays if T=0</span></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Ensure U vectors are 2D for embed_batch, even if T=0 (N,0)</span></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> T <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> evaluated_U_np_array_bo.ndim <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>                 evaluated_U_np_array_bo <span class="op">=</span> evaluated_U_np_array_bo.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>            embedded_train_X_bo <span class="op">=</span> embed_batch(evaluated_U_np_array_bo, current_dictionary_A)</span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>            scaler_bo <span class="op">=</span> MinMaxScaler()</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> embedded_train_X_bo.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>                embedded_train_X_scaled_bo <span class="op">=</span> scaler_bo.fit_transform(embedded_train_X_bo)</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>                embedded_train_X_scaled_bo <span class="op">=</span> embedded_train_X_bo</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>            train_Y_for_fit_bo <span class="op">=</span> np.array(train_Y_list_bo)</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> embedded_train_X_scaled_bo.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>               train_Y_for_fit_bo.shape[<span class="dv">0</span>] <span class="op">==</span> embedded_train_X_scaled_bo.shape[<span class="dv">0</span>]:</span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>                    gp_model_bo <span class="op">=</span> get_fitted_model(embedded_train_X_scaled_bo, train_Y_for_fit_bo, m)</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Warning: GP fitting error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">. Skipping BO iteration."</span>)</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="st">"Warning: Not enough/mismatched data for GP. Skipping BO iteration."</span>)</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>            next_U_candidates_np_bo <span class="op">=</span> optimize_acqf_discrete_via_embedding(</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>                gp_model<span class="op">=</span>gp_model_bo, scaler<span class="op">=</span>scaler_bo, dictionary_A<span class="op">=</span>current_dictionary_A,</span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a>                T<span class="op">=</span>T, q<span class="op">=</span>BATCH_SIZE_q, num_candidates<span class="op">=</span>NUM_CANDIDATES_Acqf, kappa<span class="op">=</span>KAPPA</span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> next_U_candidates_np_bo.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="st">"Acquisition function yielded no new candidates. Continuing BO."</span>)</span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>            newly_evaluated_U_bo <span class="op">=</span> []</span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a>            newly_evaluated_f_bo <span class="op">=</span> []</span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>            newly_evaluated_neg_f_bo <span class="op">=</span> []</span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i_cand <span class="kw">in</span> <span class="bu">range</span>(next_U_candidates_np_bo.shape[<span class="dv">0</span>]):</span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a>                next_U_bo <span class="op">=</span> next_U_candidates_np_bo[i_cand, :]</span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a>                already_evaluated_this_bo <span class="op">=</span> <span class="bu">any</span>(np.array_equal(next_U_bo, u) <span class="cf">for</span> u <span class="kw">in</span> evaluated_U_np_list_bo)</span>
<span id="cb7-120"><a href="#cb7-120" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> already_evaluated_this_bo: <span class="cf">continue</span></span>
<span id="cb7-121"><a href="#cb7-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-122"><a href="#cb7-122" aria-hidden="true" tabindex="-1"></a>                next_f_bo <span class="op">=</span> evaluate_objective(next_U_bo, current_X_ls, v_star, convolutions, d, w)</span>
<span id="cb7-123"><a href="#cb7-123" aria-hidden="true" tabindex="-1"></a>                next_neg_f_bo <span class="op">=</span> <span class="op">-</span>next_f_bo</span>
<span id="cb7-124"><a href="#cb7-124" aria-hidden="true" tabindex="-1"></a>                <span class="co"># temp_Y_bo = current_X_ls + (np.sum(v_star[next_U_bo == 1, :], axis=0) if T &gt; 0 else 0)</span></span>
<span id="cb7-125"><a href="#cb7-125" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"  BO Acqf Candidate </span><span class="sc">{</span>i_cand<span class="sc">}</span><span class="ss">: Obj = </span><span class="sc">{</span>next_f_bo<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-126"><a href="#cb7-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-127"><a href="#cb7-127" aria-hidden="true" tabindex="-1"></a>                newly_evaluated_U_bo.append(next_U_bo)</span>
<span id="cb7-128"><a href="#cb7-128" aria-hidden="true" tabindex="-1"></a>                newly_evaluated_f_bo.append(next_f_bo)</span>
<span id="cb7-129"><a href="#cb7-129" aria-hidden="true" tabindex="-1"></a>                newly_evaluated_neg_f_bo.append(next_neg_f_bo)</span>
<span id="cb7-130"><a href="#cb7-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-131"><a href="#cb7-131" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> next_f_bo <span class="op">&lt;</span> best_f_from_bo_for_current_X: <span class="co"># Update best found in this BO run</span></span>
<span id="cb7-132"><a href="#cb7-132" aria-hidden="true" tabindex="-1"></a>                    best_f_from_bo_for_current_X <span class="op">=</span> next_f_bo</span>
<span id="cb7-133"><a href="#cb7-133" aria-hidden="true" tabindex="-1"></a>                    best_U_from_bo_for_current_X <span class="op">=</span> next_U_bo</span>
<span id="cb7-134"><a href="#cb7-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-135"><a href="#cb7-135" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> next_f_bo <span class="op">&lt;</span> baseline_obj_for_ls_iter <span class="op">-</span> CONVERGENCE_TOLERANCE:</span>
<span id="cb7-136"><a href="#cb7-136" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"    BO Acqf found immediate improver U=</span><span class="sc">{</span>next_U_bo<span class="sc">}</span><span class="ss">, Obj=</span><span class="sc">{</span>next_f_bo<span class="sc">:.4f}</span><span class="ss"> (beats </span><span class="sc">{</span>baseline_obj_for_ls_iter<span class="sc">:.4f}</span><span class="ss">)"</span>)</span>
<span id="cb7-137"><a href="#cb7-137" aria-hidden="true" tabindex="-1"></a>                    bo_found_improving_U <span class="op">=</span> <span class="va">True</span></span>
<span id="cb7-138"><a href="#cb7-138" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Update best_U_from_bo_for_current_X one last time with this specific improver</span></span>
<span id="cb7-139"><a href="#cb7-139" aria-hidden="true" tabindex="-1"></a>                    best_U_from_bo_for_current_X <span class="op">=</span> next_U_bo</span>
<span id="cb7-140"><a href="#cb7-140" aria-hidden="true" tabindex="-1"></a>                    best_f_from_bo_for_current_X <span class="op">=</span> next_f_bo</span>
<span id="cb7-141"><a href="#cb7-141" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span> <span class="co"># Exit loop evaluating candidates from acquisition function</span></span>
<span id="cb7-142"><a href="#cb7-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-143"><a href="#cb7-143" aria-hidden="true" tabindex="-1"></a>            evaluated_U_np_list_bo.extend(newly_evaluated_U_bo)</span>
<span id="cb7-144"><a href="#cb7-144" aria-hidden="true" tabindex="-1"></a>            evaluated_f_vals_bo.extend(newly_evaluated_f_bo)</span>
<span id="cb7-145"><a href="#cb7-145" aria-hidden="true" tabindex="-1"></a>            train_Y_list_bo.extend(newly_evaluated_neg_f_bo)</span>
<span id="cb7-146"><a href="#cb7-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-147"><a href="#cb7-147" aria-hidden="true" tabindex="-1"></a>            iter_time_bo <span class="op">=</span> time.time() <span class="op">-</span> start_time_bo</span>
<span id="cb7-148"><a href="#cb7-148" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  Best obj for current X in this BO run so far: </span><span class="sc">{</span>best_f_from_bo_for_current_X<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-149"><a href="#cb7-149" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  BO Iteration </span><span class="sc">{</span>bo_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> completed in </span><span class="sc">{</span>iter_time_bo<span class="sc">:.2f}</span><span class="ss"> sec."</span>)</span>
<span id="cb7-150"><a href="#cb7-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-151"><a href="#cb7-151" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> bo_found_improving_U:</span>
<span id="cb7-152"><a href="#cb7-152" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span> <span class="co"># Exit BO iterations loop as an improver was found</span></span>
<span id="cb7-153"><a href="#cb7-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-154"><a href="#cb7-154" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- End of BO Loop for current_X_ls ---</span></span>
<span id="cb7-155"><a href="#cb7-155" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Finished BO for LS Iteration </span><span class="sc">{</span>ls_iter <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb7-156"><a href="#cb7-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-157"><a href="#cb7-157" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> bo_found_improving_U:</span>
<span id="cb7-158"><a href="#cb7-158" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"BO found an improving U: </span><span class="sc">{</span>best_U_from_bo_for_current_X<span class="sc">}</span><span class="ss">, Obj: </span><span class="sc">{</span>best_f_from_bo_for_current_X<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-159"><a href="#cb7-159" aria-hidden="true" tabindex="-1"></a>        Y_improved <span class="op">=</span> current_X_ls <span class="op">+</span> (np.<span class="bu">sum</span>(v_star[best_U_from_bo_for_current_X <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb7-160"><a href="#cb7-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-161"><a href="#cb7-161" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sanity check feasibility of Y_improved (evaluate_objective should handle penalties)</span></span>
<span id="cb7-162"><a href="#cb7-162" aria-hidden="true" tabindex="-1"></a>        obj_of_Y_improved_check <span class="op">=</span> evaluate_objective(np.zeros(T,dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.array([]), Y_improved, v_star, convolutions, d, w)</span>
<span id="cb7-163"><a href="#cb7-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-164"><a href="#cb7-164" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> obj_of_Y_improved_check <span class="op">&gt;=</span> LARGE_PENALTY <span class="kw">and</span> best_f_from_bo_for_current_X <span class="op">&gt;=</span> LARGE_PENALTY : <span class="co"># Check if the *state* Y_improved is penalized</span></span>
<span id="cb7-165"><a href="#cb7-165" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  Proposed Y from U=</span><span class="sc">{</span>best_U_from_bo_for_current_X<span class="sc">}</span><span class="ss"> results in a penalized state. Obj=</span><span class="sc">{</span>obj_of_Y_improved_check<span class="sc">:.4f}</span><span class="ss">. Rejecting move."</span>)</span>
<span id="cb7-166"><a href="#cb7-166" aria-hidden="true" tabindex="-1"></a>            no_improvement_streak <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-167"><a href="#cb7-167" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-168"><a href="#cb7-168" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  Improvement accepted. Moving to new state Y: (Obj of Y state: </span><span class="sc">{</span>obj_of_Y_improved_check<span class="sc">:.4f}</span><span class="ss">)"</span>)</span>
<span id="cb7-169"><a href="#cb7-169" aria-hidden="true" tabindex="-1"></a>            current_X_ls <span class="op">=</span> np.copy(Y_improved)</span>
<span id="cb7-170"><a href="#cb7-170" aria-hidden="true" tabindex="-1"></a>            no_improvement_streak <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-171"><a href="#cb7-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-172"><a href="#cb7-172" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Update overall best if this new state is the best ever</span></span>
<span id="cb7-173"><a href="#cb7-173" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> obj_of_Y_improved_check <span class="op">&lt;</span> best_overall_f_ls:</span>
<span id="cb7-174"><a href="#cb7-174" aria-hidden="true" tabindex="-1"></a>                best_overall_f_ls <span class="op">=</span> obj_of_Y_improved_check</span>
<span id="cb7-175"><a href="#cb7-175" aria-hidden="true" tabindex="-1"></a>                best_overall_Y_ls <span class="op">=</span> np.copy(current_X_ls)</span>
<span id="cb7-176"><a href="#cb7-176" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"    New OVERALL best state found. Obj of new X: </span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-177"><a href="#cb7-177" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb7-178"><a href="#cb7-178" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"BO did not find a U that improves upon current_X_ls (baseline: </span><span class="sc">{</span>baseline_obj_for_ls_iter<span class="sc">:.4f}</span><span class="ss">, BO best for X: </span><span class="sc">{</span>best_f_from_bo_for_current_X<span class="sc">:.4f}</span><span class="ss">)."</span>)</span>
<span id="cb7-179"><a href="#cb7-179" aria-hidden="true" tabindex="-1"></a>        no_improvement_streak <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-180"><a href="#cb7-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-181"><a href="#cb7-181" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> no_improvement_streak <span class="op">&gt;=</span> NO_IMPROVEMENT_STREAK_LIMIT:</span>
<span id="cb7-182"><a href="#cb7-182" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"No improvement for </span><span class="sc">{</span>no_improvement_streak<span class="sc">}</span><span class="ss"> local search iterations. Stopping."</span>)</span>
<span id="cb7-183"><a href="#cb7-183" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb7-184"><a href="#cb7-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-185"><a href="#cb7-185" aria-hidden="true" tabindex="-1"></a><span class="co"># --- End of Local Search Loop ---</span></span>
<span id="cb7-186"><a href="#cb7-186" aria-hidden="true" tabindex="-1"></a><span class="co"># (Results and Verification part remains the same as your previous version, using best_overall_f_ls and best_overall_Y_ls)</span></span>
<span id="cb7-187"><a href="#cb7-187" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n\n</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss"> LOCAL SEARCH FINISHED </span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">10</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-188"><a href="#cb7-188" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> best_overall_Y_ls <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb7-189"><a href="#cb7-189" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Overall Objective (of the final X state): </span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-190"><a href="#cb7-190" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Overall Y (final state vector): </span><span class="sc">{</span>best_overall_Y_ls<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-191"><a href="#cb7-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-192"><a href="#cb7-192" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verification of the final best_overall_Y_ls</span></span>
<span id="cb7-193"><a href="#cb7-193" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Verification of Final Best Local Search State ---"</span>)</span>
<span id="cb7-194"><a href="#cb7-194" aria-hidden="true" tabindex="-1"></a>    is_feasible_final <span class="op">=</span> np.<span class="bu">all</span>(best_overall_Y_ls <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="co"># Basic feasibility</span></span>
<span id="cb7-195"><a href="#cb7-195" aria-hidden="true" tabindex="-1"></a>    recalculated_obj_final <span class="op">=</span> LARGE_PENALTY</span>
<span id="cb7-196"><a href="#cb7-196" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The true objective of the state Y_ls is when U is all zeros for it</span></span>
<span id="cb7-197"><a href="#cb7-197" aria-hidden="true" tabindex="-1"></a>    recalculated_obj_final <span class="op">=</span> evaluate_objective(np.zeros(T,dtype<span class="op">=</span><span class="bu">int</span>) <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.array([]), best_overall_Y_ls, v_star, convolutions, d, w)</span>
<span id="cb7-198"><a href="#cb7-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-199"><a href="#cb7-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-200"><a href="#cb7-200" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Is the best Y_ls feasible (according to its obj value &lt; LARGE_PENALTY)? </span><span class="sc">{</span>recalculated_obj_final <span class="op">&lt;</span> LARGE_PENALTY<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-201"><a href="#cb7-201" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> recalculated_obj_final <span class="op">&lt;</span> LARGE_PENALTY:</span>
<span id="cb7-202"><a href="#cb7-202" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Objective value of best Y_ls (recalculated from state): </span><span class="sc">{</span>recalculated_obj_final<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-203"><a href="#cb7-203" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> np.isclose(best_overall_f_ls, recalculated_obj_final):</span>
<span id="cb7-204"><a href="#cb7-204" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Warning: Stored best LS objective (</span><span class="sc">{</span>best_overall_f_ls<span class="sc">:.4f}</span><span class="ss">) "</span></span>
<span id="cb7-205"><a href="#cb7-205" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f"does not match recalculation (</span><span class="sc">{</span>recalculated_obj_final<span class="sc">:.4f}</span><span class="ss">)!"</span>)</span>
<span id="cb7-206"><a href="#cb7-206" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb7-207"><a href="#cb7-207" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Best LS solution state has a penalty objective: </span><span class="sc">{</span>recalculated_obj_final<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb7-208"><a href="#cb7-208" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb7-209"><a href="#cb7-209" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Local search did not find any valid state or no iterations were run meaningfully."</span>)</span>
<span id="cb7-210"><a href="#cb7-210" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-211"><a href="#cb7-211" aria-hidden="true" tabindex="-1"></a>end_time <span class="op">=</span> time.time()</span>
<span id="cb7-212"><a href="#cb7-212" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total time taken for Local Search: </span><span class="sc">{</span>end_time <span class="op">-</span> start_time<span class="sc">:.2f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Starting Local Search. Initial X obj: 105.9331


========== LOCAL SEARCH ITERATION 1/10 ==========
Current X for this LS iteration (Obj: 105.9331)
  Baseline objective to beat for current X: 105.9331
  BO Init found immediate improver U=[0 0 1 0 1 0 1 0 0 0 0 1 1 1 1 1 1 1 0 1], Obj=105.3020 (beats 105.9331)

Finished BO for LS Iteration 1.
BO found an improving U: [0 0 1 0 1 0 1 0 0 0 0 1 1 1 1 1 1 1 0 1], Obj: 105.3020
  Improvement accepted. Moving to new state Y: (Obj of Y state: 105.3020)
    New OVERALL best state found. Obj of new X: 105.3020


========== LOCAL SEARCH ITERATION 2/10 ==========
Current X for this LS iteration (Obj: 105.3020)
  Baseline objective to beat for current X: 105.3020
  BO Init found immediate improver U=[0 1 0 0 0 0 0 1 1 0 1 1 1 0 0 0 0 0 1 1], Obj=102.9515 (beats 105.3020)

Finished BO for LS Iteration 2.
BO found an improving U: [0 1 0 0 0 0 0 1 1 0 1 1 1 0 0 0 0 0 1 1], Obj: 102.9515
  Improvement accepted. Moving to new state Y: (Obj of Y state: 102.9515)
    New OVERALL best state found. Obj of new X: 102.9515


========== LOCAL SEARCH ITERATION 3/10 ==========
Current X for this LS iteration (Obj: 102.9515)
  Baseline objective to beat for current X: 102.9515
  BO Init found immediate improver U=[1 1 0 1 0 1 0 0 1 1 1 1 0 1 0 0 1 1 1 0], Obj=102.6609 (beats 102.9515)

Finished BO for LS Iteration 3.
BO found an improving U: [1 1 0 1 0 1 0 0 1 1 1 1 0 1 0 0 1 1 1 0], Obj: 102.6609
  Improvement accepted. Moving to new state Y: (Obj of Y state: 102.6609)
    New OVERALL best state found. Obj of new X: 102.6609


========== LOCAL SEARCH ITERATION 4/10 ==========
Current X for this LS iteration (Obj: 102.6609)
  Baseline objective to beat for current X: 102.6609

--- BO Iteration 1/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 1 completed in 3.10 sec.

--- BO Iteration 2/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 109.1454
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 108.1472
  BO Acqf Candidate 4: Obj = 108.0408
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 2 completed in 3.13 sec.

--- BO Iteration 3/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 106.9460
  BO Acqf Candidate 1: Obj = 110.9527
  BO Acqf Candidate 2: Obj = 108.4150
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 108.0790
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 3 completed in 3.75 sec.

--- BO Iteration 4/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 104.8896
  BO Acqf Candidate 2: Obj = 107.4624
  BO Acqf Candidate 3: Obj = 111.0429
  BO Acqf Candidate 4: Obj = 111.0087
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 4 completed in 3.21 sec.

--- BO Iteration 5/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 107.2183
  BO Acqf Candidate 4: Obj = 107.7702
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 5 completed in 3.71 sec.

--- BO Iteration 6/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 6 completed in 3.77 sec.

--- BO Iteration 7/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 110.7807
  BO Acqf Candidate 1: Obj = 106.4606
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 106.7145
  BO Acqf Candidate 4: Obj = 107.0337
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 7 completed in 4.27 sec.

--- BO Iteration 8/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 106.6584
  BO Acqf Candidate 3: Obj = 106.8175
  BO Acqf Candidate 4: Obj = 105.2854
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 8 completed in 3.50 sec.

--- BO Iteration 9/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 106.5591
  BO Acqf Candidate 2: Obj = 113.3206
  BO Acqf Candidate 3: Obj = 113.2201
  BO Acqf Candidate 4: Obj = 107.2795
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 9 completed in 3.91 sec.

--- BO Iteration 10/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 108.4927
  BO Acqf Candidate 1: Obj = 107.3191
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 108.8597
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 10 completed in 3.30 sec.

--- BO Iteration 11/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 111.5934
  BO Acqf Candidate 1: Obj = 105.7019
  BO Acqf Candidate 2: Obj = 105.4681
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 11 completed in 4.37 sec.

--- BO Iteration 12/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 111.9954
  BO Acqf Candidate 2: Obj = 109.5624
  BO Acqf Candidate 3: Obj = 107.0232
  BO Acqf Candidate 4: Obj = 110.0557
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 12 completed in 6.15 sec.

--- BO Iteration 13/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 13 completed in 5.07 sec.

--- BO Iteration 14/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 109.7048
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 14 completed in 3.07 sec.

--- BO Iteration 15/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 107.4272
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 105.1677
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 15 completed in 5.63 sec.

--- BO Iteration 16/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 105.1291
  BO Acqf Candidate 1: Obj = 106.4838
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 106.2008
  BO Acqf Candidate 4: Obj = 105.9090
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 16 completed in 3.87 sec.

--- BO Iteration 17/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 105.6261
  BO Acqf Candidate 1: Obj = 107.0053
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 107.9925
  BO Acqf Candidate 4: Obj = 111.8886
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 17 completed in 7.11 sec.

--- BO Iteration 18/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 111.0966
  BO Acqf Candidate 4: Obj = 112.7426
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 18 completed in 3.60 sec.

--- BO Iteration 19/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 105.3166
  BO Acqf Candidate 1: Obj = 111.2503
  BO Acqf Candidate 2: Obj = 110.9728
  BO Acqf Candidate 3: Obj = 108.3952
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 19 completed in 5.60 sec.

--- BO Iteration 20/20 (LS Iter 4) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 111.7671
  BO Acqf Candidate 2: Obj = 112.6365
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 20 completed in 4.29 sec.

Finished BO for LS Iteration 4.
BO did not find a U that improves upon current_X_ls (baseline: 102.6609, BO best for X: 102.6609).


========== LOCAL SEARCH ITERATION 5/10 ==========
Current X for this LS iteration (Obj: 102.6609)
  Baseline objective to beat for current X: 102.6609

--- BO Iteration 1/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 1 completed in 3.47 sec.

--- BO Iteration 2/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 110.8983
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 2 completed in 3.18 sec.

--- BO Iteration 3/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 109.2783
  BO Acqf Candidate 1: Obj = 105.1036
  BO Acqf Candidate 2: Obj = 104.3157
  BO Acqf Candidate 3: Obj = 104.0750
  BO Acqf Candidate 4: Obj = 103.8882
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 3 completed in 3.66 sec.

--- BO Iteration 4/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 111.1134
  BO Acqf Candidate 4: Obj = 108.4437
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 4 completed in 3.39 sec.

--- BO Iteration 5/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 109.2427
  BO Acqf Candidate 2: Obj = 105.5036
  BO Acqf Candidate 3: Obj = 106.1577
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 5 completed in 4.03 sec.

--- BO Iteration 6/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 110.1253
  BO Acqf Candidate 2: Obj = 107.0152
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 109.9123
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 6 completed in 3.96 sec.

--- BO Iteration 7/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 105.8067
  BO Acqf Candidate 2: Obj = 109.1006
  BO Acqf Candidate 3: Obj = 110.5313
  BO Acqf Candidate 4: Obj = 109.7070
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 7 completed in 3.66 sec.

--- BO Iteration 8/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 105.2977
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 105.3212
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 108.9834
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 8 completed in 3.95 sec.

--- BO Iteration 9/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 108.8243
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 110.6352
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 9 completed in 3.90 sec.

--- BO Iteration 10/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 106.1093
  BO Acqf Candidate 2: Obj = 108.2037
  BO Acqf Candidate 3: Obj = 105.4433
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 10 completed in 4.17 sec.

--- BO Iteration 11/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 106.0049
  BO Acqf Candidate 1: Obj = 106.1052
  BO Acqf Candidate 2: Obj = 107.5113
  BO Acqf Candidate 3: Obj = 105.2601
  BO Acqf Candidate 4: Obj = 107.9956
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 11 completed in 4.37 sec.

--- BO Iteration 12/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 109.3751
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 111.5237
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 102.6609
  BO Iteration 12 completed in 3.41 sec.

--- BO Iteration 13/20 (LS Iter 5) ---
  BO Acqf Candidate 0: Obj = 101.3942
    BO Acqf found immediate improver U=[0 0 0 0 1 0 1 1 0 1 0 0 0 1 1 1 1 0 0 1], Obj=101.3942 (beats 102.6609)
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 13 completed in 4.95 sec.

Finished BO for LS Iteration 5.
BO found an improving U: [0 0 0 0 1 0 1 1 0 1 0 0 0 1 1 1 1 0 0 1], Obj: 101.3942
  Improvement accepted. Moving to new state Y: (Obj of Y state: 101.3942)
    New OVERALL best state found. Obj of new X: 101.3942


========== LOCAL SEARCH ITERATION 6/10 ==========
Current X for this LS iteration (Obj: 101.3942)
  Baseline objective to beat for current X: 101.3942

--- BO Iteration 1/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 105.3455
  BO Acqf Candidate 1: Obj = 105.7236
  BO Acqf Candidate 2: Obj = 107.6003
  BO Acqf Candidate 3: Obj = 105.2745
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 1 completed in 2.94 sec.

--- BO Iteration 2/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 2 completed in 3.31 sec.

--- BO Iteration 3/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 108.8063
  BO Acqf Candidate 1: Obj = 111.0229
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 106.3971
  BO Acqf Candidate 4: Obj = 108.8082
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 3 completed in 3.50 sec.

--- BO Iteration 4/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 107.5077
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 106.3616
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 4 completed in 3.81 sec.

--- BO Iteration 5/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 104.6847
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 5 completed in 4.23 sec.

--- BO Iteration 6/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 102.7381
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 105.6268
  BO Acqf Candidate 4: Obj = 105.6268
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 6 completed in 3.74 sec.

--- BO Iteration 7/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 107.6280
  BO Acqf Candidate 3: Obj = 103.8723
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 7 completed in 4.16 sec.

--- BO Iteration 8/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 108.4618
  BO Acqf Candidate 1: Obj = 103.3545
  BO Acqf Candidate 2: Obj = 103.3545
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 101.4462
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 8 completed in 3.57 sec.

--- BO Iteration 9/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 107.9689
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 106.9293
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 9 completed in 3.75 sec.

--- BO Iteration 10/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 109.5237
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 106.6592
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 10 completed in 4.15 sec.

--- BO Iteration 11/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 108.2420
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 106.9212
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 108.8673
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 11 completed in 4.39 sec.

--- BO Iteration 12/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 103.5989
  BO Acqf Candidate 1: Obj = 106.9111
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 103.0860
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 12 completed in 5.08 sec.

--- BO Iteration 13/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 105.8329
  BO Acqf Candidate 1: Obj = 108.2549
  BO Acqf Candidate 2: Obj = 104.5124
  BO Acqf Candidate 3: Obj = 107.3723
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.3942
  BO Iteration 13 completed in 6.04 sec.

--- BO Iteration 14/20 (LS Iter 6) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 101.0668
    BO Acqf found immediate improver U=[1 0 1 1 0 1 1 1 1 0 1 0 1 0 0 1 0 1 1 0], Obj=101.0668 (beats 101.3942)
  Best obj for current X in this BO run so far: 101.0668
  BO Iteration 14 completed in 4.91 sec.

Finished BO for LS Iteration 6.
BO found an improving U: [1 0 1 1 0 1 1 1 1 0 1 0 1 0 0 1 0 1 1 0], Obj: 101.0668
  Improvement accepted. Moving to new state Y: (Obj of Y state: 101.0668)
    New OVERALL best state found. Obj of new X: 101.0668


========== LOCAL SEARCH ITERATION 7/10 ==========
Current X for this LS iteration (Obj: 101.0668)
  Baseline objective to beat for current X: 101.0668

--- BO Iteration 1/20 (LS Iter 7) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 102.5915
  BO Acqf Candidate 2: Obj = 107.7616
  BO Acqf Candidate 3: Obj = 106.3599
  BO Acqf Candidate 4: Obj = 108.7667
  Best obj for current X in this BO run so far: 101.0668
  BO Iteration 1 completed in 3.62 sec.

--- BO Iteration 2/20 (LS Iter 7) ---
  BO Acqf Candidate 0: Obj = 101.7669
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 106.4624
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 108.3025
  Best obj for current X in this BO run so far: 101.0668
  BO Iteration 2 completed in 3.44 sec.

--- BO Iteration 3/20 (LS Iter 7) ---
  BO Acqf Candidate 0: Obj = 105.8244
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 104.6796
  BO Acqf Candidate 3: Obj = 109.6311
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.0668
  BO Iteration 3 completed in 3.09 sec.

--- BO Iteration 4/20 (LS Iter 7) ---
  BO Acqf Candidate 0: Obj = 102.4918
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 108.1941
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.0668
  BO Iteration 4 completed in 3.75 sec.

--- BO Iteration 5/20 (LS Iter 7) ---
  BO Acqf Candidate 0: Obj = 109.5799
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.0668
  BO Iteration 5 completed in 3.29 sec.

--- BO Iteration 6/20 (LS Iter 7) ---
  BO Acqf Candidate 0: Obj = 109.1592
  BO Acqf Candidate 1: Obj = 102.1351
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 103.2646
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 101.0668
  BO Iteration 6 completed in 3.99 sec.

--- BO Iteration 7/20 (LS Iter 7) ---
  BO Acqf Candidate 0: Obj = 109.3080
  BO Acqf Candidate 1: Obj = 106.9717
  BO Acqf Candidate 2: Obj = 100.7813
    BO Acqf found immediate improver U=[0 1 0 1 0 1 0 1 0 0 0 1 0 1 1 0 1 1 1 1], Obj=100.7813 (beats 101.0668)
  Best obj for current X in this BO run so far: 100.7813
  BO Iteration 7 completed in 3.46 sec.

Finished BO for LS Iteration 7.
BO found an improving U: [0 1 0 1 0 1 0 1 0 0 0 1 0 1 1 0 1 1 1 1], Obj: 100.7813
  Improvement accepted. Moving to new state Y: (Obj of Y state: 100.7813)
    New OVERALL best state found. Obj of new X: 100.7813


========== LOCAL SEARCH ITERATION 8/10 ==========
Current X for this LS iteration (Obj: 100.7813)
  Baseline objective to beat for current X: 100.7813
  BO Init found immediate improver U=[1 0 1 0 0 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1], Obj=100.3446 (beats 100.7813)

Finished BO for LS Iteration 8.
BO found an improving U: [1 0 1 0 0 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1], Obj: 100.3446
  Improvement accepted. Moving to new state Y: (Obj of Y state: 100.3446)
    New OVERALL best state found. Obj of new X: 100.3446


========== LOCAL SEARCH ITERATION 9/10 ==========
Current X for this LS iteration (Obj: 100.3446)
  Baseline objective to beat for current X: 100.3446
  BO Init found immediate improver U=[0 0 0 0 1 1 1 0 0 1 0 0 1 1 1 1 0 1 0 1], Obj=100.1586 (beats 100.3446)

Finished BO for LS Iteration 9.
BO found an improving U: [0 0 0 0 1 1 1 0 0 1 0 0 1 1 1 1 0 1 0 1], Obj: 100.1586
  Improvement accepted. Moving to new state Y: (Obj of Y state: 100.1586)
    New OVERALL best state found. Obj of new X: 100.1586


========== LOCAL SEARCH ITERATION 10/10 ==========
Current X for this LS iteration (Obj: 100.1586)
  Baseline objective to beat for current X: 100.1586

--- BO Iteration 1/20 (LS Iter 10) ---
  BO Acqf Candidate 0: Obj = 100.5558
  BO Acqf Candidate 1: Obj = 103.2883
  BO Acqf Candidate 2: Obj = 102.6787
  BO Acqf Candidate 3: Obj = 104.4149
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 100.1586
  BO Iteration 1 completed in 3.88 sec.

--- BO Iteration 2/20 (LS Iter 10) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 100.1586
  BO Iteration 2 completed in 3.18 sec.

--- BO Iteration 3/20 (LS Iter 10) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 104.4090
  BO Acqf Candidate 3: Obj = 104.4557
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 100.1586
  BO Iteration 3 completed in 3.46 sec.

--- BO Iteration 4/20 (LS Iter 10) ---
  BO Acqf Candidate 0: Obj = 103.6293
  BO Acqf Candidate 1: Obj = 103.3773
  BO Acqf Candidate 2: Obj = 103.7902
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 105.0787
  Best obj for current X in this BO run so far: 100.1586
  BO Iteration 4 completed in 3.34 sec.

--- BO Iteration 5/20 (LS Iter 10) ---
  BO Acqf Candidate 0: Obj = 10000000000.0000
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 106.6304
  BO Acqf Candidate 3: Obj = 107.8427
  BO Acqf Candidate 4: Obj = 10000000000.0000
  Best obj for current X in this BO run so far: 100.1586
  BO Iteration 5 completed in 3.76 sec.

--- BO Iteration 6/20 (LS Iter 10) ---
  BO Acqf Candidate 0: Obj = 103.5253
  BO Acqf Candidate 1: Obj = 10000000000.0000
  BO Acqf Candidate 2: Obj = 10000000000.0000
  BO Acqf Candidate 3: Obj = 10000000000.0000
  BO Acqf Candidate 4: Obj = 103.7441
  Best obj for current X in this BO run so far: 100.1586
  BO Iteration 6 completed in 3.79 sec.

--- BO Iteration 7/20 (LS Iter 10) ---
  BO Acqf Candidate 0: Obj = 103.1994
  BO Acqf Candidate 1: Obj = 102.4237
  BO Acqf Candidate 2: Obj = 103.1080
  BO Acqf Candidate 3: Obj = 102.7806
  BO Acqf Candidate 4: Obj = 98.3424
    BO Acqf found immediate improver U=[1 1 1 1 1 0 0 1 1 0 0 0 0 0 1 0 1 0 1 1], Obj=98.3424 (beats 100.1586)
  Best obj for current X in this BO run so far: 98.3424
  BO Iteration 7 completed in 3.32 sec.

Finished BO for LS Iteration 10.
BO found an improving U: [1 1 1 1 1 0 0 1 1 0 0 0 0 0 1 0 1 0 1 1], Obj: 98.3424
  Improvement accepted. Moving to new state Y: (Obj of Y state: 98.3424)
    New OVERALL best state found. Obj of new X: 98.3424


========== LOCAL SEARCH FINISHED ==========
Best Overall Objective (of the final X state): 98.3424
Best Overall Y (final state vector): [2 1 1 1 2 0 1 1 0 1 1 1 2 1 0 1 1 1 2 4]

--- Verification of Final Best Local Search State ---
Is the best Y_ls feasible (according to its obj value &lt; LARGE_PENALTY)? True
Objective value of best Y_ls (recalculated from state): 98.3424
Total time taken for Local Search: 241.58 seconds</code></pre>
</div>
</div>
</section>
<section id="experiment-3" class="level4">
<h4 class="anchored" data-anchor-id="experiment-3">6. Experiment 3:</h4>
<pre><code></code></pre>
</section>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="experiment-1" class="level3">
<h3 class="anchored" data-anchor-id="experiment-1">Experiment 1:</h3>
</section>
<section id="experiment-2-1" class="level3">
<h3 class="anchored" data-anchor-id="experiment-2-1">Experiment 2:</h3>
</section>
<section id="summary-of-best-objectivesdiscussion" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-best-objectivesdiscussion">Summary of Best ObjectivesDiscussion</h3>
<ol type="1">
<li><p><strong>Performance Comparison</strong>:</p></li>
<li><p><strong>Hypothesis Evaluation</strong>:</p>
<ul>
<li>Hypothesis 1</li>
<li>Hypothesis 2</li>
</ul></li>
<li><p><strong>Exploration vs.&nbsp;Exploitation</strong>:</p></li>
<li><p><strong>Computational Effort</strong>:</p></li>
<li><p><strong>Limitations and Future Work</strong>:</p>
<ul>
<li>The optimality guarantee mentioned by <span class="citation" data-cites="kaandorp_optimal_2007">@kaandorp_optimal_2007</span> applies to their specific local search algorithm operating directly on the schedule space <span class="math inline">\(\mathcal{F}\)</span>, leveraging multimodularity. Our BO approach operates on the perturbation vector space <span class="math inline">\(\mathbf{U}\)</span> via HED embeddings. While BO aims for global optimization, it doesn’t inherit the same theoretical guarantee of finding the global optimum as the original local search, especially given the stochastic nature of GP modeling and acquisition function optimization.</li>
<li>The performance is likely sensitive to BO hyperparameters (dictionary size <span class="math inline">\(m\)</span>, <span class="math inline">\(\kappa\)</span> values, number of candidates for acquisition optimization).</li>
<li>Further investigation into different dictionary construction methods (e.g., binary wavelets as mentioned in Deshwal et al., 2023) or adaptive <span class="math inline">\(\kappa\)</span> schedules could be beneficial.</li>
</ul></li>
</ol>
</section>
</section>
<section id="timeline" class="level2">
<h2 class="anchored" data-anchor-id="timeline">Timeline</h2>
<ul>
<li><strong>Experiment Setup and Code Implementation</strong>: 09-05-2025</li>
<li><strong>Results Analysis and Report Compilation</strong>:</li>
</ul>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div id="refs" role="list">

</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>