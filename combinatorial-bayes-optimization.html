<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Combinatorial Bayesian Optimization Experiments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="combinatorial-bayes-optimization_files/libs/clipboard/clipboard.min.js"></script>
<script src="combinatorial-bayes-optimization_files/libs/quarto-html/quarto.js"></script>
<script src="combinatorial-bayes-optimization_files/libs/quarto-html/popper.min.js"></script>
<script src="combinatorial-bayes-optimization_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="combinatorial-bayes-optimization_files/libs/quarto-html/anchor.min.js"></script>
<link href="combinatorial-bayes-optimization_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="combinatorial-bayes-optimization_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="combinatorial-bayes-optimization_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="combinatorial-bayes-optimization_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="combinatorial-bayes-optimization_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#objective" id="toc-objective" class="nav-link active" data-scroll-target="#objective">Objective</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a></li>
  <li><a href="#hypothesis" id="toc-hypothesis" class="nav-link" data-scroll-target="#hypothesis">Hypothesis</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a>
  <ul class="collapse">
  <li><a href="#tools-and-materials" id="toc-tools-and-materials" class="nav-link" data-scroll-target="#tools-and-materials">Tools and Materials</a></li>
  <li><a href="#experimental-design" id="toc-experimental-design" class="nav-link" data-scroll-target="#experimental-design">Experimental Design</a></li>
  <li><a href="#variables" id="toc-variables" class="nav-link" data-scroll-target="#variables">Variables</a></li>
  <li><a href="#data-collection" id="toc-data-collection" class="nav-link" data-scroll-target="#data-collection">Data Collection</a></li>
  <li><a href="#sample-size-and-selection" id="toc-sample-size-and-selection" class="nav-link" data-scroll-target="#sample-size-and-selection">Sample Size and Selection</a></li>
  <li><a href="#experimental-procedure" id="toc-experimental-procedure" class="nav-link" data-scroll-target="#experimental-procedure">Experimental Procedure</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#experiment-1-cbo-with-expected-improvement-ei-1" id="toc-experiment-1-cbo-with-expected-improvement-ei-1" class="nav-link" data-scroll-target="#experiment-1-cbo-with-expected-improvement-ei-1">Experiment 1: CBO with Expected Improvement (EI)</a></li>
  <li><a href="#experiment-2-cbo-with-lower-confidence-bound-lcb---fixed-kappa-kappa-2.576" id="toc-experiment-2-cbo-with-lower-confidence-bound-lcb---fixed-kappa-kappa-2.576" class="nav-link" data-scroll-target="#experiment-2-cbo-with-lower-confidence-bound-lcb---fixed-kappa-kappa-2.576">Experiment 2: CBO with Lower Confidence Bound (LCB) - Fixed Kappa (<span class="math inline">\(\kappa = 2.576\)</span>)</a></li>
  <li><a href="#experiment-3-cbo-with-lower-confidence-bound-lcb---increasing-kappa-1" id="toc-experiment-3-cbo-with-lower-confidence-bound-lcb---increasing-kappa-1" class="nav-link" data-scroll-target="#experiment-3-cbo-with-lower-confidence-bound-lcb---increasing-kappa-1">Experiment 3: CBO with Lower Confidence Bound (LCB) - Increasing Kappa</a></li>
  <li><a href="#summary-of-best-objectives" id="toc-summary-of-best-objectives" class="nav-link" data-scroll-target="#summary-of-best-objectives">Summary of Best Objectives</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  <li><a href="#timeline" id="toc-timeline" class="nav-link" data-scroll-target="#timeline">Timeline</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Combinatorial Bayesian Optimization Experiments</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="objective" class="level2">
<h2 class="anchored" data-anchor-id="objective">Objective</h2>
<p>The objective of this experiment is to evaluate and compare the performance of three distinct Combinatorial Bayesian Optimization (CBO) strategies for a scheduling problem, specifically outpatient appointment scheduling as described by Kaandorp and Koole (2007). We investigate:</p>
<ol type="1">
<li>CBO utilizing Expected Improvement (EI) as the acquisition function.</li>
<li>CBO utilizing Lower Confidence Bound (LCB) as the acquisition function with a fixed kappa (<span class="math inline">\(\kappa\)</span>) value.</li>
<li>CBO utilizing Lower Confidence Bound (LCB) as the acquisition function with a dynamically increasing kappa (<span class="math inline">\(\kappa\)</span>) value.</li>
</ol>
<p>We aim to determine which strategy is most effective in identifying an optimal or near-optimal schedule, as measured by the objective function value, leveraging dictionary-based embeddings for the high-dimensional combinatorial space (Deshwal et al., 2023).</p>
</section>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>We consider an outpatient appointment scheduling problem (Kaandorp and Koole, 2007) where the schedule is represented by a vector <span class="math inline">\(\mathbf{x} = (x_0, x_1, \ldots, x_{T-1})^T\)</span>. This vector comprises <span class="math inline">\(T\)</span> components, where <span class="math inline">\(x_j\)</span> denotes the non-negative allocation (number of patients) to time slot <span class="math inline">\(j\)</span>, for <span class="math inline">\(j = 0, \ldots, T-1\)</span>. A fundamental constraint is that the total allocation across all time slots must equal a fixed constant <span class="math inline">\(N\)</span>: <span class="math display">\[\sum_{j=0}^{T-1} x_j = N\]</span> We require <span class="math inline">\(x_j \ge 0\)</span> for all <span class="math inline">\(j = 0, \ldots, T-1\)</span>. Consequently, a valid schedule <span class="math inline">\(\mathbf{x}\)</span> belongs to the feasible set <span class="math inline">\(\mathcal{F} = \{ \mathbf{z} \in \mathbb{D}^{T} \mid \sum_{j=0}^{T-1} z_j = N, z_j \ge 0 \text{ for all } j\}\)</span>, where <span class="math inline">\(\mathbb{D}\)</span> is the set of non-negative integers (<span class="math inline">\(\mathbb{Z}_{\ge 0}\)</span>).</p>
<p>Kaandorp and Koole (2007) define a neighborhood structure for local search based on perturbation vectors derived from a set of <span class="math inline">\(T\)</span> basis change vectors, <span class="math inline">\(v_i \in \mathbb{D}^{T}\)</span>, for <span class="math inline">\(i = 0, \ldots, T-1\)</span>. These basis vectors represent elementary shifts of allocation between time slots:</p>
<ul>
<li><span class="math inline">\(v_0 = (-1, 0, \ldots, 0, 1)\)</span> (Shift unit <em>from</em> slot 0 <em>to</em> slot <span class="math inline">\(T-1\)</span>)</li>
<li><span class="math inline">\(v_1 = (1, -1, 0, \ldots, 0)\)</span> (Shift unit <em>from</em> slot 1 <em>to</em> slot 0)</li>
<li><span class="math inline">\(v_i = (0, \ldots, 0, \underbrace{1}_{\text{pos } i-1}, \underbrace{-1}_{\text{pos } i}, 0, \ldots, 0)\)</span> for <span class="math inline">\(i = 2, \ldots, T-1\)</span> (Shift unit <em>from</em> slot <span class="math inline">\(i\)</span> <em>to</em> slot <span class="math inline">\(i-1\)</span>)</li>
</ul>
<p>A key property of these basis vectors is that the sum of components for each vector is zero: <span class="math inline">\(\sum_{j=0}^{T-1} v_{ij} = 0\)</span> for all <span class="math inline">\(i=0, \ldots, T-1\)</span>.</p>
<p>Perturbations are constructed using a binary selection vector <span class="math inline">\(\mathbf{U} = (u_0, u_1, \ldots, u_{T-1})\)</span>, where <span class="math inline">\(u_i \in \{0, 1\}\)</span>. Each <span class="math inline">\(u_i\)</span> indicates whether the basis change <span class="math inline">\(v_i\)</span> is included in the perturbation. The resulting perturbation vector <span class="math inline">\(\mathbf{r}(\mathbf{U}) \in \mathbb{D}^{T}\)</span> is the linear combination: <span class="math display">\[\mathbf{r}(\mathbf{U}) := \sum_{i=0}^{T-1} u_i v_i\]</span></p>
<p>Since each <span class="math inline">\(v_i\)</span> sums to zero, any perturbation <span class="math inline">\(\mathbf{r}(\mathbf{U})\)</span> also sums to zero: <span class="math inline">\(\sum_{j=0}^{T-1} r_j(\mathbf{U}) = 0\)</span>. This ensures that applying such a perturbation to a valid schedule <span class="math inline">\(\mathbf{x}\)</span> preserves the total allocation <span class="math inline">\(N\)</span>.</p>
<p>The neighborhood of a schedule <span class="math inline">\(\mathbf{x} \in \mathcal{F}\)</span>, denoted by <span class="math inline">\(\mathcal{N}(\mathbf{x})\)</span>, comprises all distinct, feasible schedules <span class="math inline">\(\mathbf{x}'\)</span> reachable by applying a non-zero perturbation <span class="math inline">\(\mathbf{r}(\mathbf{U})\)</span> (Kaandorp and Koole, 2007, use a slightly different but related neighborhood definition based on combinations of these basis vectors).</p>
<p>The objective function to be minimized is a weighted sum of Expected Waiting Time (EWT) and Expected Staff Penalty (ESP), as defined by Kaandorp and Koole (2007): <span class="math display">\[C(\mathbf{x}) = w \cdot EWT(\mathbf{x}) + (1-w) \cdot ESP(\mathbf{x})\]</span> Kaandorp and Koole (2007) prove that this objective function is multimodular, which guarantees that a local search algorithm using their defined neighborhood converges to the global optimum.</p>
<p>However, evaluating <span class="math inline">\(C(\mathbf{x})\)</span> can be computationally expensive, especially for large <span class="math inline">\(N\)</span> and <span class="math inline">\(T\)</span>. Furthermore, the search space defined by the binary vectors <span class="math inline">\(\mathbf{U}\)</span> is high-dimensional (<span class="math inline">\(2^T - 2\)</span> possibilities, excluding <span class="math inline">\(\mathbf{0}\)</span> and <span class="math inline">\(\mathbf{1}\)</span>). Bayesian Optimization (BO) is a suitable framework for optimizing such expensive black-box functions. Standard BO methods often struggle with high-dimensional combinatorial spaces. Deshwal et al.&nbsp;(2023) propose a method using dictionary-based embeddings (Hamming Embedding via Dictionaries - HED) to map the high-dimensional binary space of <span class="math inline">\(\mathbf{U}\)</span> vectors into a lower-dimensional continuous space, where standard Gaussian Process (GP) models can be effectively applied. This experiment applies the HED approach within a BO framework to solve the scheduling problem formulated by Kaandorp and Koole (2007).</p>
</section>
<section id="hypothesis" class="level2">
<h2 class="anchored" data-anchor-id="hypothesis">Hypothesis</h2>
<p>We hypothesize that:</p>
<ol type="1">
<li>All three CBO strategies, leveraging the HED embedding (Deshwal et al., 2023), will be capable of finding schedules superior to the initial schedule derived from the Bailey-Welch method (a common heuristic mentioned by Kaandorp and Koole (2007)).</li>
<li>CBO strategies employing Lower Confidence Bound (LCB) may exhibit superior performance or faster convergence compared to Expected Improvement (EI), due to the explicit exploration-exploitation trade-off inherent in LCB.</li>
<li>The LCB strategy with a dynamically increasing kappa (<span class="math inline">\(\kappa\)</span>) value will demonstrate a more robust search, potentially leading to improved final solutions compared to a fixed <span class="math inline">\(\kappa\)</span>. However, preliminary results suggest that a fixed <span class="math inline">\(\kappa\)</span> might perform better for this specific problem instance.</li>
</ol>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<section id="tools-and-materials" class="level3">
<h3 class="anchored" data-anchor-id="tools-and-materials">Tools and Materials</h3>
<ul>
<li>Programming Language: Python 3</li>
<li>Core Libraries: NumPy, SciPy</li>
<li>Machine Learning: Scikit-learn (for <code>GaussianProcessRegressor</code>, <code>MinMaxScaler</code>)</li>
<li>Data Structures: Standard Python lists and dictionaries, NumPy arrays.</li>
<li>Imported functions: <code>bailey_welch_schedule</code>, <code>get_v_star</code>, <code>compute_convolutions</code>, <code>calculate_objective_serv_time_lookup</code> (implementing the logic from Kaandorp and Koole (2007), assumed to be in an external <code>functions.py</code> file).</li>
</ul>
</section>
<section id="experimental-design" class="level3">
<h3 class="anchored" data-anchor-id="experimental-design">Experimental Design</h3>
<p>Three distinct Bayesian optimization experiments are conducted, applying the HED embedding approach (Deshwal et al., 2023) to the scheduling problem:</p>
<ol type="1">
<li><strong>Experiment 1: Expected Improvement (EI)</strong>
<ul>
<li>Acquisition Function: Expected Improvement.</li>
<li>Objective: Minimize <span class="math inline">\(C(\mathbf{x})\)</span> by iteratively selecting candidate vectors <span class="math inline">\(\mathbf{U}\)</span> (via their embeddings) that maximize the EI.</li>
</ul></li>
<li><strong>Experiment 2: Lower Confidence Bound (LCB) - Fixed Kappa</strong>
<ul>
<li>Acquisition Function: Lower Confidence Bound.</li>
<li>Objective: Minimize <span class="math inline">\(C(\mathbf{x})\)</span> using a fixed <code>kappa</code> (<span class="math inline">\(\kappa\)</span>) value in the LCB acquisition function applied to the GP model over the embedded space.</li>
</ul></li>
<li><strong>Experiment 3: Lower Confidence Bound (LCB) - Increasing Kappa</strong>
<ul>
<li>Acquisition Function: Lower Confidence Bound.</li>
<li>Objective: Minimize <span class="math inline">\(C(\mathbf{x})\)</span> using a <code>kappa</code> (<span class="math inline">\(\kappa\)</span>) value that dynamically increases whenever an improved solution is discovered during the BO process.</li>
</ul></li>
</ol>
<p>For all experiments, Hamming Distance Embedding (HED) with a “diverse random” dictionary construction strategy (Deshwal et al., 2023) is employed to map the binary perturbation vectors <span class="math inline">\(\mathbf{U}\)</span> to a continuous embedding space. A Gaussian Process (GP) model with Automatic Relevance Determination (ARD) kernels models the (negative) objective function in this embedded space.</p>
</section>
<section id="variables" class="level3">
<h3 class="anchored" data-anchor-id="variables">Variables</h3>
<ul>
<li><strong>Independent Variables</strong>:
<ul>
<li>Type of acquisition function (EI, LCB).</li>
<li>Strategy for <span class="math inline">\(\kappa\)</span> in LCB (fixed, increasing).</li>
<li>The specific binary perturbation vector <span class="math inline">\(\mathbf{U}\)</span> selected in each iteration (chosen via optimizing the acquisition function over the embedded space).</li>
</ul></li>
<li><strong>Dependent Variables</strong>:
<ul>
<li>The objective function value <span class="math inline">\(C(\mathbf{x}')\)</span> for the resulting schedule <span class="math inline">\(\mathbf{x}' = \mathbf{x} + \mathbf{r}(\mathbf{U})\)</span> (calculated using the method from Kaandorp and Koole (2007)).</li>
<li>The best objective function value found throughout the optimization process.</li>
</ul></li>
</ul>
</section>
<section id="data-collection" class="level3">
<h3 class="anchored" data-anchor-id="data-collection">Data Collection</h3>
<p>Data, comprising evaluated pairs <span class="math inline">\((\mathbf{U}, C(\mathbf{x}'))\)</span>, is collected iteratively:</p>
<ul>
<li>An initial set of <code>N_INITIAL</code> randomly generated <span class="math inline">\(\mathbf{U}\)</span> vectors is evaluated.</li>
<li>In each of the subsequent <code>N_ITERATIONS</code>, <code>BATCH_SIZE_q</code> new <span class="math inline">\(\mathbf{U}\)</span> vectors are selected by optimizing the respective acquisition function over <code>NUM_CANDIDATES_Acqf</code> randomly generated candidate vectors in the original binary space (evaluated via their embeddings). These newly selected vectors are then evaluated, and the results are added to the dataset.</li>
</ul>
</section>
<section id="sample-size-and-selection" class="level3">
<h3 class="anchored" data-anchor-id="sample-size-and-selection">Sample Size and Selection</h3>
<ul>
<li><strong>N_INITIAL</strong>: 20 (number of initial random evaluations)</li>
<li><strong>N_ITERATIONS</strong>: 25 (number of Bayesian optimization iterations)</li>
<li><strong>BATCH_SIZE_q</strong>: 5 (number of candidates selected and evaluated per iteration)</li>
<li><strong>NUM_CANDIDATES_Acqf</strong>: <span class="math inline">\(T \times 1024 = 20 \times 1024 = 20480\)</span> (number of random candidates generated for optimizing the acquisition function in each iteration)</li>
<li><strong>m</strong>: 128 (dimensionality of the HED embedding space, following Deshwal et al.&nbsp;(2023))</li>
</ul>
<p>The selection of new points for evaluation is guided by the respective acquisition function (EI or LCB) optimized over the embedded space representation of candidate <span class="math inline">\(\mathbf{U}\)</span> vectors.</p>
</section>
<section id="experimental-procedure" class="level3">
<h3 class="anchored" data-anchor-id="experimental-procedure">Experimental Procedure</h3>
<section id="setup" class="level4">
<h4 class="anchored" data-anchor-id="setup">1. Setup</h4>
<p>Import necessary libraries and configure warning filters.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Core Libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Dict, Tuple, Callable, Optional, Union, Any, Iterable</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Scikit-learn for GP, Scaling, and potentially acquisition functions</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process <span class="im">import</span> GaussianProcessRegressor</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process.kernels <span class="im">import</span> Matern, ConstantKernel, WhiteKernel</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> MinMaxScaler</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.exceptions <span class="im">import</span> ConvergenceWarning</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># SciPy for statistics (needed for Expected Improvement calculation)</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Assume functions.py contains implementations based on Kaandorp and Koole (2007)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># from functions import bailey_welch_schedule, get_v_star, compute_convolutions, calculate_objective_serv_time_lookup</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Mocking them for now as the file is not provided:</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bailey_welch_schedule(T, d, N, s): </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder: Returns a simple initial schedule (e.g., even distribution or zeros)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Kaandorp and Koole (2007) mention Bailey-Welch schedules two patients at t=0, then one per block.</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Mock bailey_welch_schedule called with T=</span><span class="sc">{</span>T<span class="sc">}</span><span class="ss">, d=</span><span class="sc">{</span>d<span class="sc">}</span><span class="ss">, N=</span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    mock_schedule <span class="op">=</span> np.zeros(T)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> N <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        mock_schedule[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span> <span class="co"># Bailey-Welch starts with two</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        remaining_N <span class="op">=</span> N <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        intervals_per_patient <span class="op">=</span> T <span class="op">/</span> N <span class="co"># Approximate spacing</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        current_interval <span class="op">=</span> intervals_per_patient </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(remaining_N):</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> <span class="bu">min</span>(<span class="bu">int</span>(<span class="bu">round</span>(current_interval)), T<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Ensure we don't overwrite the first slot if T is small</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> idx <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> mock_schedule[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">2</span>: </span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>                 idx <span class="op">=</span> <span class="dv">1</span> <span class="op">%</span> T <span class="co"># Put in next slot if available</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            mock_schedule[idx] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            current_interval <span class="op">+=</span> intervals_per_patient</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Adjust if sum is not N due to rounding/integer constraints</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> np.<span class="bu">sum</span>(mock_schedule)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> N <span class="op">-</span> current_sum</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> diff <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># Add remaining patients somewhere</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">int</span>(diff)): mock_schedule[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>T] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> diff <span class="op">&lt;</span> <span class="dv">0</span>: <span class="co"># Remove excess patients (less likely with this mock)</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>             <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">int</span>(<span class="bu">abs</span>(diff))): </span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>                 non_zero_indices <span class="op">=</span> np.where(mock_schedule <span class="op">&gt;</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>                 <span class="cf">if</span> <span class="bu">len</span>(non_zero_indices) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>                     mock_schedule[non_zero_indices[<span class="op">-</span><span class="dv">1</span>]] <span class="op">-=</span> <span class="dv">1</span> <span class="co"># Remove from later slots first</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>                 <span class="cf">else</span>: <span class="cf">break</span> <span class="co"># Should not happen if N &gt; 0</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mock_schedule</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_v_star(T): </span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Basis change vectors as defined in Kaandorp and Koole (2007), Appendix A</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note: Their v_i corresponds to u_i in the original code's notation</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Mock get_v_star called with T=</span><span class="sc">{</span>T<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    v_star_matrix <span class="op">=</span> np.zeros((T, T))</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># v_0 = (-1, 0, ..., 0, 1) -&gt; Corresponds to u_1 in Kaandorp&amp;Koole notation (shift from t=1 to t=T)</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The code's v_0 shifts from slot 0 to T-1. Let's match the code's definition.</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        v_star_matrix[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        v_star_matrix[<span class="dv">0</span>, T<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span> </span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># v_1 = (1, -1, 0, ..., 0) -&gt; Corresponds to u_2 in Kaandorp&amp;Koole (shift from t=2 to t=1)</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Matches code's v_1 (shift from slot 1 to 0)</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            v_star_matrix[<span class="dv">1</span>, <span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            v_star_matrix[<span class="dv">1</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># v_i = (0,..,1_{i-1},-1_i,..,0) for i=2..T-1 -&gt; Corresponds to u_{i+1} in Kaandorp&amp;Koole (shift from t=i+1 to t=i)</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Matches code's v_i (shift from slot i to i-1)</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, T):</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>            v_star_matrix[i, i] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>            v_star_matrix[i, i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The provided code uses T basis vectors. Kaandorp&amp;Koole define T basis vectors u_1..u_T</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Let's ensure the dimensions match the code (TxT matrix for T basis vectors)</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v_star_matrix <span class="co"># Returns a TxT matrix where row i is basis vector v_i</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_convolutions(s, N, q_prob): </span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder: Computes convolutions for queueing calculations (Kaandorp and Koole, 2007)</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Mock compute_convolutions called with N=</span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">, q_prob=</span><span class="sc">{</span>q_prob<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">"mock_convolution_data"</span>: <span class="va">True</span>} </span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_objective_serv_time_lookup(Y, d, convolutions): </span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder: Calculates EWT and ESP based on schedule Y (Kaandorp and Koole, 2007)</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simple mock: return sum of Y as ewt and variance as esp, scaled</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    mock_ewt <span class="op">=</span> np.<span class="bu">sum</span>(Y) <span class="op">*</span> <span class="fl">0.1</span> <span class="op">*</span> d <span class="co"># Factor in interval duration</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    mock_esp <span class="op">=</span> np.var(Y) <span class="op">*</span> <span class="fl">0.5</span> <span class="op">*</span> d</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mock_ewt, mock_esp</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter warnings</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span><span class="pp">RuntimeWarning</span>)</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span>ConvergenceWarning) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="constants" class="level4">
<h4 class="anchored" data-anchor-id="constants">2. Constants</h4>
<p>Definition of problem parameters and initial configuration.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Problem Definition ---</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Fixed Data (Parameters for the scheduling problem based on Kaandorp and Koole (2007))</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">21</span>          <span class="co"># Total number of patients to be scheduled</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">20</span>          <span class="co"># Number of time slots (also dimension of perturbation vector U)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="dv">5</span>           <span class="co"># Duration of each time slot (e.g., in minutes)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>max_s <span class="op">=</span> <span class="dv">20</span>      <span class="co"># Maximum possible service time (used for generating distribution s_dist)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>q_prob <span class="op">=</span> <span class="fl">0.20</span>   <span class="co"># No-show probability (denoted 'rho' in Kaandorp and Koole (2007))</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="fl">0.1</span>         <span class="co"># Weight for EWT in objective C(x)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>l_target <span class="op">=</span> <span class="dv">10</span>   <span class="co"># Target average service time (parameter 'l' in original code)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>v_star <span class="op">=</span> get_v_star(T) <span class="co"># Basis change vectors matrix (T x T)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to generate a weighted service time probability distribution</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_weighted_list(max_s_val: <span class="bu">int</span>, target_l: <span class="bu">float</span>, split_i: <span class="bu">int</span>) <span class="op">-&gt;</span> Optional[np.ndarray]:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates a service time probability distribution s.</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">    (Implementation as provided previously)</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input Validation</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(max_s_val, <span class="bu">int</span>) <span class="kw">or</span> max_s_val <span class="op">&lt;=</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(target_l, (<span class="bu">int</span>, <span class="bu">float</span>)) <span class="kw">or</span> <span class="kw">not</span> (<span class="dv">1</span> <span class="op">&lt;=</span> target_l <span class="op">&lt;=</span> max_s_val): <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(split_i, <span class="bu">int</span>) <span class="kw">or</span> <span class="kw">not</span> (<span class="dv">0</span> <span class="op">&lt;</span> split_i <span class="op">&lt;</span> max_s_val): <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _objective(p_dist: np.ndarray) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        service_times <span class="op">=</span> np.arange(<span class="dv">1</span>, max_s_val <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        weighted_avg <span class="op">=</span> np.dot(service_times, p_dist)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (weighted_avg <span class="op">-</span> target_l) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    constraints <span class="op">=</span> ({<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> p_dist: np.<span class="bu">sum</span>(p_dist) <span class="op">-</span> <span class="fl">1.0</span>})</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    bounds <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>)] <span class="op">*</span> max_s_val</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    initial_guess <span class="op">=</span> np.random.dirichlet(np.ones(max_s_val))</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> minimize(_objective, initial_guess, method<span class="op">=</span><span class="st">'SLSQP'</span>, bounds<span class="op">=</span>bounds, constraints<span class="op">=</span>constraints)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> result.success: <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        optimized_probs <span class="op">=</span> result.x</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        optimized_probs[optimized_probs <span class="op">&lt;</span> <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> np.<span class="bu">sum</span>(optimized_probs)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> np.isclose(current_sum, <span class="fl">1.0</span>):</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sum <span class="op">&gt;</span> <span class="dv">0</span>: optimized_probs <span class="op">/=</span> current_sum</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e: <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    first_part_probs <span class="op">=</span> optimized_probs[:split_i]</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    second_part_probs <span class="op">=</span> optimized_probs[split_i:]</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    sorted_first_part <span class="op">=</span> np.sort(first_part_probs)      </span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    sorted_second_part <span class="op">=</span> np.sort(second_part_probs)[::<span class="op">-</span><span class="dv">1</span>] </span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    final_dist <span class="op">=</span> np.zeros(max_s_val <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    final_dist[<span class="dv">1</span> : split_i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> sorted_first_part</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    final_dist[split_i <span class="op">+</span> <span class="dv">1</span> : max_s_val <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> sorted_second_part</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.isclose(np.<span class="bu">sum</span>(final_dist[<span class="dv">1</span>:]), <span class="fl">1.0</span>): <span class="bu">print</span>(<span class="ss">f"Warning: Service dist sum </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(final_dist[<span class="dv">1</span>:])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_dist</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate service time distribution 's_dist'</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>i_val <span class="op">=</span> <span class="dv">5</span> </span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>s_dist <span class="op">=</span> generate_weighted_list(max_s, l_target, i_val) </span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> s_dist <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    convolutions <span class="op">=</span> compute_convolutions(s_dist, N, q_prob)</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Failed to generate service time distribution. Using fallback."</span>)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    s_dist <span class="op">=</span> np.zeros(max_s <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span> </span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> max_s <span class="op">&gt;</span> <span class="dv">0</span>: s_dist[<span class="dv">1</span>:] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>max_s </span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    convolutions <span class="op">=</span> compute_convolutions(s_dist, N, q_prob) </span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial schedule 'X_initial_schedule' from Bailey-Welch heuristic</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>X_initial_schedule <span class="op">=</span> np.array(bailey_welch_schedule(T, d, N, s_dist))</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial schedule X: </span><span class="sc">{</span>X_initial_schedule<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Penalty for infeasible solutions</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>LARGE_PENALTY <span class="op">=</span> <span class="fl">1e10</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="common-functions-objective-evaluation-and-hed" class="level4">
<h4 class="anchored" data-anchor-id="common-functions-objective-evaluation-and-hed">3. Common Functions (Objective Evaluation and HED)</h4>
<p>Objective evaluation implements <span class="math inline">\(C(\mathbf{x})\)</span> from Kaandorp and Koole (2007). HED implementation follows Deshwal et al.&nbsp;(2023).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_objective(U_np, X_vec, v_star_matrix, convolutions_data, d_interval, w_weight):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Evaluates the objective function C(x') where x' = X_vec + r(U_np).</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses logic from Kaandorp and Koole (2007) via calculate_objective_serv_time_lookup.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Applies HED approach from Deshwal et al. (2023) by operating on U_np.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    (Implementation as provided previously)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input validation...</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(U_np, np.ndarray): <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">"Input U_np must be a numpy array"</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_np.ndim <span class="op">!=</span> <span class="dv">1</span>: <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input U_np must be 1-dimensional"</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_np.shape[<span class="dv">0</span>] <span class="op">!=</span> v_star_matrix.shape[<span class="dv">0</span>]: <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Dimension mismatch: U_np length </span><span class="sc">{</span>U_np<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> != v_star_matrix rows </span><span class="sc">{</span>v_star_matrix<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> X_vec.shape[<span class="dv">0</span>] <span class="op">!=</span> v_star_matrix.shape[<span class="dv">1</span>]: <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Dimension mismatch: X_vec length must match v_star_matrix columns."</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.<span class="bu">all</span>((U_np <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (U_np <span class="op">==</span> <span class="dv">1</span>)): <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input U_np must be binary (0s and 1s)."</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    perturbation_rU <span class="op">=</span> np.<span class="bu">sum</span>(v_star_matrix[U_np <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    Y_schedule <span class="op">=</span> X_vec <span class="op">+</span> perturbation_rU</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.<span class="bu">all</span>(Y_schedule <span class="op">&gt;=</span> <span class="dv">0</span>):</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        ewt, esp <span class="op">=</span> calculate_objective_serv_time_lookup(Y_schedule, d_interval, convolutions_data)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        objective_value <span class="op">=</span> w_weight <span class="op">*</span> ewt <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w_weight) <span class="op">*</span> esp</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> objective_value</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> LARGE_PENALTY</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Hamming Distance Embedding (HED) Implementation (Deshwal et al., 2023) ---</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hamming_distance(u1_vec: np.ndarray, u2_vec: np.ndarray) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculates the Hamming distance."""</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(u1_vec <span class="op">!=</span> u2_vec)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_diverse_random_dictionary(T_dim: <span class="bu">int</span>, m_embed_dim: <span class="bu">int</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generates the random dictionary A using the 'diverse random' strategy."""</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    dictionary_A <span class="op">=</span> np.zeros((m_embed_dim, T_dim), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m_embed_dim):</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        theta <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>) </span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> (np.random.rand(T_dim) <span class="op">&lt;</span> theta).astype(<span class="bu">int</span>)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        dictionary_A[i, :] <span class="op">=</span> row</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dictionary_A</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_vector(U_binary_vec: np.ndarray, dictionary_A: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Embeds a single binary vector U_binary_vec using HED."""</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    m_embed_dim <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    embedding_phi <span class="op">=</span> np.zeros(m_embed_dim, dtype<span class="op">=</span><span class="bu">float</span>) </span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m_embed_dim):</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        embedding_phi[i] <span class="op">=</span> hamming_distance(U_binary_vec, dictionary_A[i, :])</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> embedding_phi</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_batch(U_batch_binary_vecs: np.ndarray, dictionary_A: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Embeds a batch of binary vectors U_batch_binary_vecs using HED."""</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    m_embed_dim <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_batch_binary_vecs.ndim <span class="op">==</span> <span class="dv">1</span>: U_batch_binary_vecs <span class="op">=</span> U_batch_binary_vecs.reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>    batch_size <span class="op">=</span> U_batch_binary_vecs.shape[<span class="dv">0</span>]</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    embeddings_np <span class="op">=</span> np.zeros((batch_size, m_embed_dim), dtype<span class="op">=</span><span class="bu">float</span>) </span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(batch_size):</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>        embeddings_np[j, :] <span class="op">=</span> embed_vector(U_batch_binary_vecs[j, :], dictionary_A)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> embeddings_np</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Common Gaussian Process (GP) Fitting Function (Deshwal et al., 2023) ---</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_fitted_model(train_X_embedded_scaled: np.ndarray, train_Y_neg_obj: np.ndarray, m_embed_dim: <span class="bu">int</span>) <span class="op">-&gt;</span> GaussianProcessRegressor:</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Fits a GP model to the scaled embedded training data."""</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_Y_neg_obj.ndim <span class="op">&gt;</span> <span class="dv">1</span> <span class="kw">and</span> train_Y_neg_obj.shape[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>: train_Y_neg_obj <span class="op">=</span> train_Y_neg_obj.ravel()</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> ConstantKernel(<span class="fl">1.0</span>, constant_value_bounds<span class="op">=</span>(<span class="fl">1e-3</span>, <span class="fl">1e3</span>)) <span class="op">*</span> <span class="op">\</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>             Matern(length_scale<span class="op">=</span>np.ones(m_embed_dim), length_scale_bounds<span class="op">=</span>(<span class="fl">1e-2</span>, <span class="fl">1e2</span>), nu<span class="op">=</span><span class="fl">2.5</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>             WhiteKernel(noise_level<span class="op">=</span><span class="fl">1e-10</span>, noise_level_bounds<span class="op">=</span><span class="st">"fixed"</span>) </span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>    gp_model <span class="op">=</span> GaussianProcessRegressor(kernel<span class="op">=</span>kernel, alpha<span class="op">=</span><span class="fl">1e-10</span>, n_restarts_optimizer<span class="op">=</span><span class="dv">10</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>    gp_model.fit(train_X_embedded_scaled, train_Y_neg_obj)</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gp_model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="experiment-1-cbo-with-expected-improvement-ei" class="level4">
<h4 class="anchored" data-anchor-id="experiment-1-cbo-with-expected-improvement-ei">4. Experiment 1: CBO with Expected Improvement (EI)</h4>
<p>Applies the methodology from Deshwal et al.&nbsp;(2023) using EI.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- EI Specific Acquisition Function and Optimization ---</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expected_improvement(mu_pred: np.ndarray, sigma_pred: np.ndarray, f_best_neg: <span class="bu">float</span>, xi: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.01</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Computes the Expected Improvement (EI) acquisition function."""</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    sigma_pred <span class="op">=</span> np.maximum(sigma_pred, <span class="fl">1e-9</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> (mu_pred <span class="op">-</span> f_best_neg <span class="op">-</span> xi) <span class="op">/</span> sigma_pred</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    ei_values <span class="op">=</span> (mu_pred <span class="op">-</span> f_best_neg <span class="op">-</span> xi) <span class="op">*</span> norm.cdf(Z) <span class="op">+</span> sigma_pred <span class="op">*</span> norm.pdf(Z)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    ei_values[sigma_pred <span class="op">&lt;=</span> <span class="fl">1e-9</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ei_values</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimize_acqf_ei(gp_model: GaussianProcessRegressor, scaler: MinMaxScaler, </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                     dictionary_A: np.ndarray, T_dim: <span class="bu">int</span>, q_batch_size: <span class="bu">int</span>, </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                     num_acqf_candidates: <span class="bu">int</span>, current_best_neg_f_val: <span class="bu">float</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Optimizes the EI acquisition function using HED."""</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    m_embed_dim <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    candidate_u_vectors_np <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>(num_acqf_candidates, T_dim))</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    embedded_candidates_np <span class="op">=</span> embed_batch(candidate_u_vectors_np, dictionary_A)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    embedded_candidates_scaled_np <span class="op">=</span> scaler.transform(embedded_candidates_np)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    mu_pred, std_pred <span class="op">=</span> gp_model.predict(embedded_candidates_scaled_np, return_std<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    acq_values <span class="op">=</span> expected_improvement(mu_pred, std_pred, current_best_neg_f_val, xi<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    top_indices <span class="op">=</span> np.argsort(acq_values)[<span class="op">-</span>q_batch_size:][::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> candidate_u_vectors_np[top_indices, :]</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="co"># --- BO Loop Parameters ---</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>N_INITIAL_POINTS <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>N_BO_ITERATIONS <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>BATCH_SIZE_Q <span class="op">=</span> <span class="dv">5</span> </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>NUM_ACQF_CANDIDATES <span class="op">=</span> T <span class="op">*</span> <span class="dv">1024</span> </span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>M_EMBED_DIM <span class="op">=</span> <span class="dv">128</span> <span class="co"># Dictionary size as used in Deshwal et al. (2023) experiments</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="co"># --- EI BO Loop ---</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Starting Experiment 1: CBO with Expected Improvement (EI) ---"</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>evaluated_U_np_list_ei <span class="op">=</span> []  </span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>evaluated_f_vals_ei <span class="op">=</span> []     </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>train_Y_list_ei <span class="op">=</span> []         </span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialization </span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Generating </span><span class="sc">{</span>N_INITIAL_POINTS<span class="sc">}</span><span class="ss"> initial random points for EI..."</span>)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>initial_candidates_ei <span class="op">=</span> []</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(initial_candidates_ei) <span class="op">&lt;</span> N_INITIAL_POINTS:</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    U_init_candidate <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>T)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">any</span>(np.array_equal(U_init_candidate, u) <span class="cf">for</span> u <span class="kw">in</span> initial_candidates_ei):</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        initial_candidates_ei.append(U_init_candidate)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> U_init <span class="kw">in</span> initial_candidates_ei:</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    f_val <span class="op">=</span> evaluate_objective(U_init, X_initial_schedule, v_star, convolutions, d, w)</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    neg_f_val <span class="op">=</span> <span class="op">-</span>f_val </span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_list_ei.append(U_init)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    evaluated_f_vals_ei.append(f_val)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    train_Y_list_ei.append(neg_f_val)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>best_obj_so_far_ei <span class="op">=</span> <span class="bu">min</span>(evaluated_f_vals_ei) <span class="cf">if</span> evaluated_f_vals_ei <span class="cf">else</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial best objective value (EI): </span><span class="sc">{</span>best_obj_so_far_ei<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> np.isfinite(best_obj_so_far_ei): <span class="bu">print</span>(<span class="st">"Warning: Initial best objective (EI) is infinite."</span>)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a><span class="co"># Bayesian Optimization Iterations</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(N_BO_ITERATIONS):</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    iter_start_time <span class="op">=</span> time.time()</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- EI Iteration </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>N_BO_ITERATIONS<span class="sc">}</span><span class="ss"> ---"</span>)</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>    current_dictionary_A_ei <span class="op">=</span> generate_diverse_random_dictionary(T, M_EMBED_DIM)</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> evaluated_U_np_list_ei: <span class="cf">continue</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_array_ei <span class="op">=</span> np.array(evaluated_U_np_list_ei)</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>    embedded_train_X_ei <span class="op">=</span> embed_batch(evaluated_U_np_array_ei, current_dictionary_A_ei)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>    scaler_ei <span class="op">=</span> MinMaxScaler() </span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> embedded_train_X_ei.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>        embedded_train_X_scaled_ei <span class="op">=</span> scaler_ei.fit_transform(embedded_train_X_ei)</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: embedded_train_X_scaled_ei <span class="op">=</span> embedded_train_X_ei</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    train_Y_for_fit_ei <span class="op">=</span> np.array(train_Y_list_ei) </span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> embedded_train_X_scaled_ei.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> train_Y_for_fit_ei.shape[<span class="dv">0</span>] <span class="op">==</span> embedded_train_X_scaled_ei.shape[<span class="dv">0</span>]:</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>        gp_model_ei <span class="op">=</span> get_fitted_model(embedded_train_X_scaled_ei, train_Y_for_fit_ei, M_EMBED_DIM)</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">continue</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>    current_best_neg_f_val_ei <span class="op">=</span> np.<span class="bu">max</span>(train_Y_for_fit_ei) <span class="cf">if</span> train_Y_for_fit_ei.size <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_best_neg_f_val_ei <span class="op">&lt;=</span> <span class="op">-</span>LARGE_PENALTY <span class="op">/</span> <span class="dv">2</span> <span class="kw">and</span> np.isfinite(current_best_neg_f_val_ei): <span class="cf">pass</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>    next_U_candidates_np_ei <span class="op">=</span> optimize_acqf_ei(</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>        gp_model_ei, scaler_ei, current_dictionary_A_ei, T, BATCH_SIZE_Q, NUM_ACQF_CANDIDATES, current_best_neg_f_val_ei</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i_cand <span class="kw">in</span> <span class="bu">range</span>(next_U_candidates_np_ei.shape[<span class="dv">0</span>]):</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>        next_U <span class="op">=</span> next_U_candidates_np_ei[i_cand, :]</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">any</span>(np.array_equal(next_U, u) <span class="cf">for</span> u <span class="kw">in</span> evaluated_U_np_list_ei): <span class="cf">continue</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>        next_f <span class="op">=</span> evaluate_objective(next_U, X_initial_schedule, v_star, convolutions, d, w)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list_ei.append(next_U)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals_ei.append(next_f)</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>        train_Y_list_ei.append(<span class="op">-</span>next_f) </span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> next_f <span class="op">&lt;</span> best_obj_so_far_ei: best_obj_so_far_ei <span class="op">=</span> next_f</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best objective (EI) so far: </span><span class="sc">{</span>best_obj_so_far_ei<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Results for EI ---</span></span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- EI Optimization Finished ---"</span>)</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> evaluated_f_vals_ei:</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>    final_best_f_ei <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)<span class="op">;</span> final_best_U_ei <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>    final_best_idx_ei <span class="op">=</span> np.argmin(evaluated_f_vals_ei)</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>    final_best_U_ei <span class="op">=</span> evaluated_U_np_list_ei[final_best_idx_ei]</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>    final_best_f_ei <span class="op">=</span> evaluated_f_vals_ei[final_best_idx_ei]</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total evaluations (EI): </span><span class="sc">{</span><span class="bu">len</span>(evaluated_f_vals_ei)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Objective Value Found (EI): </span><span class="sc">{</span>final_best_f_ei<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="experiment-2-cbo-with-lower-confidence-bound-lcb---fixed-kappa" class="level4">
<h4 class="anchored" data-anchor-id="experiment-2-cbo-with-lower-confidence-bound-lcb---fixed-kappa">5. Experiment 2: CBO with Lower Confidence Bound (LCB) - Fixed Kappa</h4>
<p>Applies the methodology from Deshwal et al.&nbsp;(2023) using LCB with fixed <span class="math inline">\(\kappa\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- LCB Specific Acquisition Function and Optimization ---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lower_confidence_bound(mu_pred: np.ndarray, sigma_pred: np.ndarray, kappa: <span class="bu">float</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Computes the Lower Confidence Bound (LCB) acquisition function."""</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    sigma_pred <span class="op">=</span> np.maximum(sigma_pred, <span class="fl">1e-9</span>) </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mu_pred <span class="op">-</span> kappa <span class="op">*</span> sigma_pred </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimize_acqf_lcb(gp_model: GaussianProcessRegressor, scaler: MinMaxScaler, </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                      dictionary_A: np.ndarray, T_dim: <span class="bu">int</span>, q_batch_size: <span class="bu">int</span>, </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                      num_acqf_candidates: <span class="bu">int</span>, kappa_val: <span class="bu">float</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Optimizes the LCB acquisition function using HED."""</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    m_embed_dim <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    candidate_u_vectors_np <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>(num_acqf_candidates, T_dim))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    embedded_candidates_np <span class="op">=</span> embed_batch(candidate_u_vectors_np, dictionary_A)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    embedded_candidates_scaled_np <span class="op">=</span> scaler.transform(embedded_candidates_np)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    mu_pred, std_pred <span class="op">=</span> gp_model.predict(embedded_candidates_scaled_np, return_std<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    acq_values <span class="op">=</span> lower_confidence_bound(mu_pred, std_pred, kappa<span class="op">=</span>kappa_val)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    top_indices <span class="op">=</span> np.argsort(acq_values)[<span class="op">-</span>q_batch_size:][::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> candidate_u_vectors_np[top_indices, :]</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co"># --- LCB (Fixed Kappa) BO Loop ---</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Starting Experiment 2: CBO with LCB (Fixed Kappa) ---"</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>KAPPA_FIXED <span class="op">=</span> <span class="fl">2.576</span> <span class="co"># Standard value for ~99% confidence</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>evaluated_U_np_list_lcb_fixed <span class="op">=</span> []</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>evaluated_f_vals_lcb_fixed <span class="op">=</span> []</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>train_Y_list_lcb_fixed <span class="op">=</span> []</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialization</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Generating </span><span class="sc">{</span>N_INITIAL_POINTS<span class="sc">}</span><span class="ss"> initial random points for LCB (Fixed Kappa)..."</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>initial_candidates_lcb_fixed <span class="op">=</span> []</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(initial_candidates_lcb_fixed) <span class="op">&lt;</span> N_INITIAL_POINTS:</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    U_init_candidate <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>T)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">any</span>(np.array_equal(U_init_candidate, u) <span class="cf">for</span> u <span class="kw">in</span> initial_candidates_lcb_fixed):</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        initial_candidates_lcb_fixed.append(U_init_candidate)</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> U_init <span class="kw">in</span> initial_candidates_lcb_fixed:</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    f_val <span class="op">=</span> evaluate_objective(U_init, X_initial_schedule, v_star, convolutions, d, w)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    neg_f_val <span class="op">=</span> <span class="op">-</span>f_val</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_list_lcb_fixed.append(U_init)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    evaluated_f_vals_lcb_fixed.append(f_val)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    train_Y_list_lcb_fixed.append(neg_f_val)</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>best_obj_so_far_lcb_fixed <span class="op">=</span> <span class="bu">min</span>(evaluated_f_vals_lcb_fixed) <span class="cf">if</span> evaluated_f_vals_lcb_fixed <span class="cf">else</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial best objective value (LCB Fixed Kappa): </span><span class="sc">{</span>best_obj_so_far_lcb_fixed<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a><span class="co"># BO Iterations</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(N_BO_ITERATIONS):</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    iter_start_time <span class="op">=</span> time.time()</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- LCB (Fixed Kappa) Iteration </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>N_BO_ITERATIONS<span class="sc">}</span><span class="ss"> ---"</span>)</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    current_dictionary_A_lcb_fixed <span class="op">=</span> generate_diverse_random_dictionary(T, M_EMBED_DIM)</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> evaluated_U_np_list_lcb_fixed: <span class="cf">continue</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_array_lcb_fixed <span class="op">=</span> np.array(evaluated_U_np_list_lcb_fixed)</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>    embedded_train_X_lcb_fixed <span class="op">=</span> embed_batch(evaluated_U_np_array_lcb_fixed, current_dictionary_A_lcb_fixed)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    scaler_lcb_fixed <span class="op">=</span> MinMaxScaler()</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> embedded_train_X_lcb_fixed.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>        embedded_train_X_scaled_lcb_fixed <span class="op">=</span> scaler_lcb_fixed.fit_transform(embedded_train_X_lcb_fixed)</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: embedded_train_X_scaled_lcb_fixed <span class="op">=</span> embedded_train_X_lcb_fixed</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>    train_Y_for_fit_lcb_fixed <span class="op">=</span> np.array(train_Y_list_lcb_fixed)</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> embedded_train_X_scaled_lcb_fixed.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> train_Y_for_fit_lcb_fixed.shape[<span class="dv">0</span>] <span class="op">==</span> embedded_train_X_scaled_lcb_fixed.shape[<span class="dv">0</span>]:</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>        gp_model_lcb_fixed <span class="op">=</span> get_fitted_model(embedded_train_X_scaled_lcb_fixed, train_Y_for_fit_lcb_fixed, M_EMBED_DIM)</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">continue</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    next_U_candidates_np_lcb_fixed <span class="op">=</span> optimize_acqf_lcb(</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>        gp_model_lcb_fixed, scaler_lcb_fixed, current_dictionary_A_lcb_fixed, T, BATCH_SIZE_Q, NUM_ACQF_CANDIDATES, KAPPA_FIXED</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i_cand <span class="kw">in</span> <span class="bu">range</span>(next_U_candidates_np_lcb_fixed.shape[<span class="dv">0</span>]):</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>        next_U <span class="op">=</span> next_U_candidates_np_lcb_fixed[i_cand, :]</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">any</span>(np.array_equal(next_U, u) <span class="cf">for</span> u <span class="kw">in</span> evaluated_U_np_list_lcb_fixed): <span class="cf">continue</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>        next_f <span class="op">=</span> evaluate_objective(next_U, X_initial_schedule, v_star, convolutions, d, w)</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list_lcb_fixed.append(next_U)</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals_lcb_fixed.append(next_f)</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>        train_Y_list_lcb_fixed.append(<span class="op">-</span>next_f)</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> next_f <span class="op">&lt;</span> best_obj_so_far_lcb_fixed: best_obj_so_far_lcb_fixed <span class="op">=</span> next_f</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best objective (LCB Fixed Kappa) so far: </span><span class="sc">{</span>best_obj_so_far_lcb_fixed<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Results for LCB (Fixed Kappa) ---</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- LCB (Fixed Kappa) Optimization Finished ---"</span>)</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> evaluated_f_vals_lcb_fixed:</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>    final_best_f_lcb_fixed <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)<span class="op">;</span> final_best_U_lcb_fixed <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>    final_best_idx_lcb_fixed <span class="op">=</span> np.argmin(evaluated_f_vals_lcb_fixed)</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>    final_best_U_lcb_fixed <span class="op">=</span> evaluated_U_np_list_lcb_fixed[final_best_idx_lcb_fixed]</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>    final_best_f_lcb_fixed <span class="op">=</span> evaluated_f_vals_lcb_fixed[final_best_idx_lcb_fixed]</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total evaluations (LCB Fixed Kappa): </span><span class="sc">{</span><span class="bu">len</span>(evaluated_f_vals_lcb_fixed)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Objective Value Found (LCB Fixed Kappa): </span><span class="sc">{</span>final_best_f_lcb_fixed<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="experiment-3-cbo-with-lower-confidence-bound-lcb---increasing-kappa" class="level4">
<h4 class="anchored" data-anchor-id="experiment-3-cbo-with-lower-confidence-bound-lcb---increasing-kappa">6. Experiment 3: CBO with Lower Confidence Bound (LCB) - Increasing Kappa</h4>
<p>Applies the methodology from Deshwal et al.&nbsp;(2023) using LCB with dynamic <span class="math inline">\(\kappa\)</span>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- LCB (Increasing Kappa) BO Loop ---</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Starting Experiment 3: CBO with LCB (Increasing Kappa) ---"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>INITIAL_KAPPA_DYNAMIC <span class="op">=</span> <span class="fl">3.75</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>KAPPA_INCREASE_FACTOR <span class="op">=</span> <span class="fl">1.3</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># MAX_KAPPA_DYNAMIC = 15.0 # Optional cap</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>evaluated_U_np_list_lcb_dyn <span class="op">=</span> []</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>evaluated_f_vals_lcb_dyn <span class="op">=</span> []</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>train_Y_list_lcb_dyn <span class="op">=</span> []</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>current_kappa_dynamic <span class="op">=</span> INITIAL_KAPPA_DYNAMIC</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialization</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Generating </span><span class="sc">{</span>N_INITIAL_POINTS<span class="sc">}</span><span class="ss"> initial random points for LCB (Increasing Kappa)..."</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>initial_candidates_lcb_dyn <span class="op">=</span> []</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(initial_candidates_lcb_dyn) <span class="op">&lt;</span> N_INITIAL_POINTS:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    U_init_candidate <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>T)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">any</span>(np.array_equal(U_init_candidate, u) <span class="cf">for</span> u <span class="kw">in</span> initial_candidates_lcb_dyn):</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        initial_candidates_lcb_dyn.append(U_init_candidate)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> U_init <span class="kw">in</span> initial_candidates_lcb_dyn:</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    f_val <span class="op">=</span> evaluate_objective(U_init, X_initial_schedule, v_star, convolutions, d, w)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    neg_f_val <span class="op">=</span> <span class="op">-</span>f_val</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_list_lcb_dyn.append(U_init)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    evaluated_f_vals_lcb_dyn.append(f_val)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    train_Y_list_lcb_dyn.append(neg_f_val)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>best_obj_so_far_lcb_dyn <span class="op">=</span> <span class="bu">min</span>(evaluated_f_vals_lcb_dyn) <span class="cf">if</span> evaluated_f_vals_lcb_dyn <span class="cf">else</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial best objective value (LCB Increasing Kappa): </span><span class="sc">{</span>best_obj_so_far_lcb_dyn<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial Kappa: </span><span class="sc">{</span>current_kappa_dynamic<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="co"># BO Iterations</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(N_BO_ITERATIONS):</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    iter_start_time <span class="op">=</span> time.time()</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- LCB (Increasing Kappa) Iteration </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>N_BO_ITERATIONS<span class="sc">}</span><span class="ss"> ---"</span>)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    current_dictionary_A_lcb_dyn <span class="op">=</span> generate_diverse_random_dictionary(T, M_EMBED_DIM)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> evaluated_U_np_list_lcb_dyn: <span class="cf">continue</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_array_lcb_dyn <span class="op">=</span> np.array(evaluated_U_np_list_lcb_dyn)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    embedded_train_X_lcb_dyn <span class="op">=</span> embed_batch(evaluated_U_np_array_lcb_dyn, current_dictionary_A_lcb_dyn)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    scaler_lcb_dyn <span class="op">=</span> MinMaxScaler()</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> embedded_train_X_lcb_dyn.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>        embedded_train_X_scaled_lcb_dyn <span class="op">=</span> scaler_lcb_dyn.fit_transform(embedded_train_X_lcb_dyn)</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: embedded_train_X_scaled_lcb_dyn <span class="op">=</span> embedded_train_X_lcb_dyn</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    train_Y_for_fit_lcb_dyn <span class="op">=</span> np.array(train_Y_list_lcb_dyn)</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> embedded_train_X_scaled_lcb_dyn.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> train_Y_for_fit_lcb_dyn.shape[<span class="dv">0</span>] <span class="op">==</span> embedded_train_X_scaled_lcb_dyn.shape[<span class="dv">0</span>]:</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        gp_model_lcb_dyn <span class="op">=</span> get_fitted_model(embedded_train_X_scaled_lcb_dyn, train_Y_for_fit_lcb_dyn, M_EMBED_DIM)</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">continue</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    next_U_candidates_np_lcb_dyn <span class="op">=</span> optimize_acqf_lcb(</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>        gp_model_lcb_dyn, scaler_lcb_dyn, current_dictionary_A_lcb_dyn, T, BATCH_SIZE_Q, NUM_ACQF_CANDIDATES, current_kappa_dynamic</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    improvement_found_in_batch <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i_cand <span class="kw">in</span> <span class="bu">range</span>(next_U_candidates_np_lcb_dyn.shape[<span class="dv">0</span>]):</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>        next_U <span class="op">=</span> next_U_candidates_np_lcb_dyn[i_cand, :]</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">any</span>(np.array_equal(next_U, u) <span class="cf">for</span> u <span class="kw">in</span> evaluated_U_np_list_lcb_dyn): <span class="cf">continue</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>        next_f <span class="op">=</span> evaluate_objective(next_U, X_initial_schedule, v_star, convolutions, d, w)</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list_lcb_dyn.append(next_U)</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals_lcb_dyn.append(next_f)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>        train_Y_list_lcb_dyn.append(<span class="op">-</span>next_f)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> next_f <span class="op">&lt;</span> best_obj_so_far_lcb_dyn:</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>            best_obj_so_far_lcb_dyn <span class="op">=</span> next_f</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>            old_kappa <span class="op">=</span> current_kappa_dynamic</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>            current_kappa_dynamic <span class="op">*=</span> KAPPA_INCREASE_FACTOR</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>            <span class="co"># current_kappa_dynamic = min(current_kappa_dynamic, MAX_KAPPA_DYNAMIC) # Optional cap</span></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>            improvement_found_in_batch <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best objective (LCB Increasing Kappa) so far: </span><span class="sc">{</span>best_obj_so_far_lcb_dyn<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print(f"Kappa for next iteration: {current_kappa_dynamic:.3f}")</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Results for LCB (Increasing Kappa) ---</span></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- LCB (Increasing Kappa) Optimization Finished ---"</span>)</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> evaluated_f_vals_lcb_dyn:</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>    final_best_f_lcb_dyn <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)<span class="op">;</span> final_best_U_lcb_dyn <span class="op">=</span> <span class="va">None</span></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>    final_best_idx_lcb_dyn <span class="op">=</span> np.argmin(evaluated_f_vals_lcb_dyn)</span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>    final_best_U_lcb_dyn <span class="op">=</span> evaluated_U_np_list_lcb_dyn[final_best_idx_lcb_dyn]</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>    final_best_f_lcb_dyn <span class="op">=</span> evaluated_f_vals_lcb_dyn[final_best_idx_lcb_dyn]</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total evaluations (LCB Increasing Kappa): </span><span class="sc">{</span><span class="bu">len</span>(evaluated_f_vals_lcb_dyn)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Objective Value Found (LCB Increasing Kappa): </span><span class="sc">{</span>final_best_f_lcb_dyn<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Final Kappa value reached: </span><span class="sc">{</span>current_kappa_dynamic<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The initial schedule, derived using the Bailey-Welch method (Kaandorp and Koole, 2007), serves as a baseline. The objective function <span class="math inline">\(C(\mathbf{x})\)</span> combines Expected Waiting Time (<span class="math inline">\(EWT\)</span>) and Expected Staff Penalty (<span class="math inline">\(ESP\)</span>). Lower values of <span class="math inline">\(C(\mathbf{x})\)</span> are preferable. Each experiment consisted of <span class="math inline">\(N_{INITIAL} = 20\)</span> initial random evaluations followed by <span class="math inline">\(N_{ITERATIONS} = 25\)</span> Bayesian optimization iterations, with <span class="math inline">\(BATCH\_SIZE_q = 5\)</span> evaluations per iteration, totaling approximately <span class="math inline">\(20 + 25 \times 5 = 145\)</span> evaluations per experiment. The optimization operates on the binary perturbation vector <span class="math inline">\(\mathbf{U}\)</span>, using the HED embedding (Deshwal et al., 2023).</p>
<p>The key performance metric is the best (minimum) objective function value found.</p>
<section id="experiment-1-cbo-with-expected-improvement-ei-1" class="level3">
<h3 class="anchored" data-anchor-id="experiment-1-cbo-with-expected-improvement-ei-1">Experiment 1: CBO with Expected Improvement (EI)</h3>
<ul>
<li><strong>Initial Best Objective (after random search)</strong>: <span class="math inline">\(73.6389\)</span></li>
<li><strong>Final Best Objective Found</strong>: <span class="math inline">\(68.2348\)</span></li>
<li><strong>Total Evaluations</strong>: <span class="math inline">\(145\)</span></li>
<li><strong>Best Perturbation Vector <span class="math inline">\(\mathbf{U}_{EI}^*\)</span></strong>: <code>[0 0 0 1 0 0 0 1 0 0 0 1 1 0 1 0 0 1 0 1]</code></li>
<li><strong>Resulting Optimal Schedule <span class="math inline">\(\mathbf{x}_{EI}^*\)</span></strong>: <code>[2 1 1 0 1 0 2 0 0 1 1 1 0 1 0 1 1 0 1 7]</code></li>
</ul>
</section>
<section id="experiment-2-cbo-with-lower-confidence-bound-lcb---fixed-kappa-kappa-2.576" class="level3">
<h3 class="anchored" data-anchor-id="experiment-2-cbo-with-lower-confidence-bound-lcb---fixed-kappa-kappa-2.576">Experiment 2: CBO with Lower Confidence Bound (LCB) - Fixed Kappa (<span class="math inline">\(\kappa = 2.576\)</span>)</h3>
<ul>
<li><strong>Initial Best Objective (after random search)</strong>: <span class="math inline">\(68.0201\)</span></li>
<li><strong>Final Best Objective Found</strong>: <span class="math inline">\(66.9201\)</span></li>
<li><strong>Total Evaluations</strong>: <span class="math inline">\(143\)</span></li>
<li><strong>Best Perturbation Vector <span class="math inline">\(\mathbf{U}_{LCB\_fixed}^*\)</span></strong>: <code>[0 0 0 1 0 0 1 1 0 1 0 1 1 0 1 1 0 1 1 1]</code></li>
<li><strong>Resulting Optimal Schedule <span class="math inline">\(\mathbf{x}_{LCB\_fixed}^*\)</span></strong>: <code>[2 1 1 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 7]</code></li>
</ul>
</section>
<section id="experiment-3-cbo-with-lower-confidence-bound-lcb---increasing-kappa-1" class="level3">
<h3 class="anchored" data-anchor-id="experiment-3-cbo-with-lower-confidence-bound-lcb---increasing-kappa-1">Experiment 3: CBO with Lower Confidence Bound (LCB) - Increasing Kappa</h3>
<ul>
<li><strong>Initial Best Objective (after random search)</strong>: <span class="math inline">\(74.0010\)</span></li>
<li><strong>Final Best Objective Found</strong>: <span class="math inline">\(68.0497\)</span></li>
<li><strong>Total Evaluations</strong>: <span class="math inline">\(145\)</span></li>
<li><strong>Best Perturbation Vector <span class="math inline">\(\mathbf{U}_{LCB\_dyn}^*\)</span></strong>: <code>[0 0 0 1 0 0 1 1 0 0 0 1 1 0 1 1 0 1 0 1]</code></li>
<li><strong>Resulting Optimal Schedule <span class="math inline">\(\mathbf{x}_{LCB\_dyn}^*\)</span></strong>: <code>[2 1 1 0 1 1 1 0 0 1 1 1 0 1 1 0 1 0 1 7]</code></li>
<li><strong>Initial <span class="math inline">\(\kappa\)</span></strong>: <span class="math inline">\(3.750\)</span></li>
<li><strong>Final <span class="math inline">\(\kappa\)</span></strong>: <span class="math inline">\(39.767\)</span></li>
</ul>
</section>
<section id="summary-of-best-objectives" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-best-objectives">Summary of Best Objectives</h3>
<table class="table">
<colgroup>
<col style="width: 49%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Experiment</th>
<th>Best Objective <span class="math inline">\(C(\mathbf{x}^*)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CBO with EI</td>
<td><span class="math inline">\(68.2348\)</span></td>
</tr>
<tr class="even">
<td>CBO with LCB (Fixed <span class="math inline">\(\kappa=2.576\)</span>)</td>
<td><span class="math inline">\(66.9201\)</span></td>
</tr>
<tr class="odd">
<td>CBO with LCB (Increasing <span class="math inline">\(\kappa\)</span>)</td>
<td><span class="math inline">\(68.0497\)</span></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>The experiments aimed to compare three CBO strategies, leveraging the HED embedding technique (Deshwal et al., 2023), for optimizing the outpatient appointment scheduling problem formulated by Kaandorp and Koole (2007). All three methods successfully improved upon their respective initial random search results, demonstrating the applicability of BO with HED to this combinatorial problem.</p>
<ol type="1">
<li><p><strong>Performance Comparison</strong>: The CBO strategy employing LCB with a fixed <span class="math inline">\(\kappa = 2.576\)</span> yielded the lowest objective function value (<span class="math inline">\(66.9201\)</span>), indicating the best performance among the tested methods for this specific problem instance and parameter settings. EI achieved a final objective of <span class="math inline">\(68.2348\)</span>, while LCB with increasing <span class="math inline">\(\kappa\)</span> reached <span class="math inline">\(68.0497\)</span>.</p></li>
<li><p><strong>Hypothesis Evaluation</strong>:</p>
<ul>
<li>Hypothesis 1 was supported: All CBO strategies found significantly better schedules than the initial random points.</li>
<li>Hypothesis 2 received partial support: LCB with fixed <span class="math inline">\(\kappa\)</span> outperformed EI, but LCB with increasing <span class="math inline">\(\kappa\)</span> did not significantly outperform EI.</li>
<li>Hypothesis 3 was not supported: The dynamic <span class="math inline">\(\kappa\)</span> strategy, despite adapting its exploration parameter substantially (from <span class="math inline">\(3.750\)</span> to <span class="math inline">\(39.767\)</span>), did not achieve the best result, being outperformed by the fixed <span class="math inline">\(\kappa\)</span> LCB.</li>
</ul></li>
<li><p><strong>Exploration vs.&nbsp;Exploitation</strong>: The fixed <span class="math inline">\(\kappa\)</span> LCB strategy appears to strike an effective balance for this problem. The dynamic <span class="math inline">\(\kappa\)</span> strategy, becoming increasingly explorative upon finding improvements, might have explored too broadly after initial gains, potentially moving away from the most promising regions identified earlier. The EI strategy’s focus on immediate expected improvement was less effective than the fixed LCB’s balanced approach. The effectiveness of the HED embedding, combined with ARD in the GP kernel (as discussed by Deshwal et al., 2023), likely played a crucial role in enabling the GP to model the complex objective landscape effectively.</p></li>
<li><p><strong>Computational Effort</strong>: All methods required a similar number of expensive objective function evaluations (~145). The main computational overhead per iteration, beyond function evaluation, involves HED embedding, GP fitting, and acquisition function optimization.</p></li>
<li><p><strong>Limitations and Future Work</strong>:</p>
<ul>
<li>The optimality guarantee mentioned by Kaandorp and Koole (2007) applies to their specific local search algorithm operating directly on the schedule space <span class="math inline">\(\mathcal{F}\)</span>, leveraging multimodularity. Our BO approach operates on the perturbation vector space <span class="math inline">\(\mathbf{U}\)</span> via HED embeddings. While BO aims for global optimization, it doesn’t inherit the same theoretical guarantee of finding the global optimum as the original local search, especially given the stochastic nature of GP modeling and acquisition function optimization.</li>
<li>The performance is likely sensitive to BO hyperparameters (dictionary size <span class="math inline">\(m\)</span>, <span class="math inline">\(\kappa\)</span> values, number of candidates for acquisition optimization).</li>
<li>The mock implementation of <code>functions.py</code> needs replacement with actual scheduling logic for accurate results.</li>
<li>Further investigation into different dictionary construction methods (e.g., binary wavelets as mentioned in Deshwal et al., 2023) or adaptive <span class="math inline">\(\kappa\)</span> schedules could be beneficial.</li>
</ul></li>
</ol>
<p>In conclusion, applying CBO with HED embeddings appears promising for this scheduling problem. The LCB acquisition function with a fixed, well-chosen <span class="math inline">\(\kappa\)</span> demonstrated the best performance in this study.</p>
</section>
<section id="timeline" class="level2">
<h2 class="anchored" data-anchor-id="timeline">Timeline</h2>
<ul>
<li><strong>Experiment Setup and Code Implementation</strong>: (Specify Date Range)</li>
<li><strong>Initial Parameter Tuning (if any)</strong>: (Specify Date Range)</li>
<li><strong>Execution of Experiment 1 (EI)</strong>: (Specify Date)</li>
<li><strong>Execution of Experiment 2 (LCB Fixed Kappa)</strong>: (Specify Date)</li>
<li><strong>Execution of Experiment 3 (LCB Increasing Kappa)</strong>: (Specify Date)</li>
<li><strong>Results Analysis and Report Compilation</strong>: (Specify Date Range)</li>
</ul>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li>Deshwal, A., Ament, S., Balandat, M., Bakshy, E., Doppa, J. R., &amp; Eriksson, D. (2023). Bayesian Optimization over High-Dimensional Combinatorial Spaces via Dictionary-based Embeddings. <em>Proceedings of the 26th International Conference on Artificial Intelligence and Statistics (AISTATS)</em>, PMLR 206:5141-5168.</li>
<li>Kaandorp, G. C., &amp; Koole, G. (2007). Optimal outpatient appointment scheduling. <em>Health Care Management Science</em>, 10(3), 217–229. https://doi.org/10.1007/s10729-007-9015-x</li>
<li>(Placeholder for Bailey-Welch algorithm reference, e.g., Bailey, N. T. J. (1952). A study of queues and appointment systems in hospital out-patient departments, with special reference to waiting-times. <em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, 14(2), 185-199.)</li>
<li>(Placeholder for Gaussian Process literature, e.g., Rasmussen, C. E., &amp; Williams, C. K. I. (2006). <em>Gaussian Processes for Machine Learning</em>. MIT Press.)</li>
</ul>
<p>```</p>
<p>Ik heb de verwijzingen naar (Kaandorp and Koole, 2007) en (Deshwal et al., 2023) toegevoegd in de secties Objective, Background, Methodology, Discussion en References. De tekst is aangepast om de bijdragen van elk paper aan het huidige experiment te verduidelijk</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>