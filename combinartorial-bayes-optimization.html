<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Based on Experiment by Witek ten Hove">
<meta name="dcterms.date" content="2025-05-05">

<title>Combinatorial Bayesian Optimization for a Scheduling Problem</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="combinartorial-bayes-optimization_files/libs/clipboard/clipboard.min.js"></script>
<script src="combinartorial-bayes-optimization_files/libs/quarto-html/quarto.js"></script>
<script src="combinartorial-bayes-optimization_files/libs/quarto-html/popper.min.js"></script>
<script src="combinartorial-bayes-optimization_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="combinartorial-bayes-optimization_files/libs/quarto-html/anchor.min.js"></script>
<link href="combinartorial-bayes-optimization_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="combinartorial-bayes-optimization_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="combinartorial-bayes-optimization_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="combinartorial-bayes-optimization_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="combinartorial-bayes-optimization_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#objective" id="toc-objective" class="nav-link active" data-scroll-target="#objective">Objective</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a></li>
  <li><a href="#hypothesis" id="toc-hypothesis" class="nav-link" data-scroll-target="#hypothesis">Hypothesis</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a>
  <ul class="collapse">
  <li><a href="#tools-and-materials" id="toc-tools-and-materials" class="nav-link" data-scroll-target="#tools-and-materials">Tools and Materials</a></li>
  <li><a href="#experimental-design" id="toc-experimental-design" class="nav-link" data-scroll-target="#experimental-design">Experimental Design</a></li>
  <li><a href="#variables" id="toc-variables" class="nav-link" data-scroll-target="#variables">Variables</a></li>
  <li><a href="#data-collection" id="toc-data-collection" class="nav-link" data-scroll-target="#data-collection">Data Collection</a></li>
  <li><a href="#sample-size-and-selection" id="toc-sample-size-and-selection" class="nav-link" data-scroll-target="#sample-size-and-selection">Sample Size and Selection</a></li>
  <li><a href="#experimental-procedure" id="toc-experimental-procedure" class="nav-link" data-scroll-target="#experimental-procedure">Experimental Procedure</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  <li><a href="#timeline" id="toc-timeline" class="nav-link" data-scroll-target="#timeline">Timeline</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Combinatorial Bayesian Optimization for a Scheduling Problem</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Based on Experiment by Witek ten Hove </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="objective" class="level2">
<h2 class="anchored" data-anchor-id="objective">Objective</h2>
<p>This experiment aims to optimize a complex scheduling problem using Bayesian Optimization (BO). The schedule is represented by a high-dimensional vector subject to constraints, and the objective function balances conflicting criteria (e.g., waiting time and service provider productivity). Specifically, we explore the effectiveness of a BO approach tailored for high-dimensional combinatorial spaces, leveraging Hamming Embedding via Dictionaries (HED) as proposed by Deshwal et al.&nbsp;(2023), comparing different acquisition functions.</p>
</section>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>We address a scheduling problem where a schedule is defined by a vector <span class="math inline">\(x=(x_{0},x_{1},...,x_{T-1})^{T}\)</span>. Each component <span class="math inline">\(x_{j}\)</span> represents a non-negative integer allocation (e.g., number of patients) to time slot <span class="math inline">\(j\)</span>. The total allocation must sum to a fixed constant <span class="math inline">\(N\)</span>: <span class="math inline">\(\sum_{j=0}^{T-1}x_{j}=N\)</span>. The set of valid schedules is denoted by <span class="math inline">\(\mathcal{F}=\{z\in\mathbb{Z}_{\ge0}^{T}|\sum_{j=0}^{T-1}z_{j}=N, z_{j}\ge0~\forall j\}\)</span>.</p>
<p>Optimization within this space often involves local search. A neighborhood structure <span class="math inline">\(\mathcal{N}(x)\)</span> around a schedule <span class="math inline">\(x\)</span> is defined using perturbations <span class="math inline">\(r(U)\)</span>. These perturbations are generated by selecting a subset of <span class="math inline">\(T\)</span> basis change vectors <span class="math inline">\(v_i\)</span> using a binary selection vector <span class="math inline">\(U=(u_{0},...,u_{T-1}) \in \{0,1\}^{T}\)</span>, where <span class="math inline">\(r(U) = \sum_{i=0}^{T-1}u_{i}v_{i}\)</span>. Each <span class="math inline">\(v_i\)</span> represents an elementary shift between slots (e.g., <span class="math inline">\(v_1=(1,-1,0,...,0)\)</span> shifts one unit from slot 1 to slot 0) and sums to zero, ensuring that <span class="math inline">\(x' = x + r(U)\)</span> maintains the total allocation <span class="math inline">\(N\)</span>. The neighborhood <span class="math inline">\(\mathcal{N}(x)\)</span> contains all distinct, feasible schedules <span class="math inline">\(x'\)</span> reachable by applying a non-zero perturbation (<span class="math inline">\(r(U) \ne 0\)</span>, excluding <span class="math inline">\(U=0\)</span> and <span class="math inline">\(U=1\)</span>). The size of the neighborhood is bounded by <span class="math inline">\(|\mathcal{N}(x)|\le2^{T}-2\)</span>.</p>
<p>The goal is to minimize an objective function <span class="math inline">\(C(x)=w\cdot EWT(x)+(1-w)\cdot ESP(x)\)</span>, where <span class="math inline">\(EWT\)</span> might represent Expected Waiting Time and <span class="math inline">\(ESP\)</span> Expected Service Provider time, weighted by <span class="math inline">\(w \in [0,1]\)</span>. The parameters influencing <span class="math inline">\(C(x)\)</span> include the schedule <span class="math inline">\(x\)</span>, total allocation <span class="math inline">\(N\)</span>, number of slots <span class="math inline">\(T\)</span>, slot duration <span class="math inline">\(d\)</span>, service time distribution <span class="math inline">\(s\)</span>, and no-show probability <span class="math inline">\(q\)</span>.</p>
<p>Due to the high dimensionality (<span class="math inline">\(T\)</span>) and the potentially expensive evaluation of <span class="math inline">\(C(x)\)</span>, standard local search or exhaustive methods are infeasible. Bayesian Optimization (BO) is a suitable framework for optimizing such expensive black-box functions. However, applying BO directly to high-dimensional combinatorial spaces like the space of selection vectors <span class="math inline">\(U \in \{0,1\}^T\)</span> presents challenges.</p>
<p>This experiment adopts the Hamming Embedding via Dictionaries (HED) approach from Deshwal et al.&nbsp;(2023). HED embeds the high-dimensional binary vector <span class="math inline">\(U\)</span> into a lower-dimensional continuous space using Hamming distances to a set of ‘dictionary’ vectors. A Gaussian Process (GP) surrogate model is then built on this embedded space, allowing standard BO techniques (like Expected Improvement or Lower Confidence Bound acquisition functions) to be applied more effectively.</p>
</section>
<section id="hypothesis" class="level2">
<h2 class="anchored" data-anchor-id="hypothesis">Hypothesis</h2>
<p>Using Bayesian Optimization with Hamming Embedding via Dictionaries (HED) will efficiently identify near-optimal perturbation selection vectors <span class="math inline">\(U\)</span> (leading to improved schedules <span class="math inline">\(x' = x + r(U)\)</span>) for the defined scheduling problem. Comparing different acquisition functions within this framework—specifically Expected Improvement (EI), Lower Confidence Bound (LCB) with fixed exploration parameter (<span class="math inline">\(\kappa\)</span>), and LCB with dynamically increasing <span class="math inline">\(\kappa\)</span>—will reveal differences in convergence speed and the quality of the final solution found within a fixed budget of function evaluations. We expect LCB variants, particularly the adaptive one, might explore the complex space more effectively than EI.</p>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<section id="tools-and-materials" class="level3">
<h3 class="anchored" data-anchor-id="tools-and-materials">Tools and Materials</h3>
<ul>
<li><strong>Programming Language:</strong> Python 3</li>
<li><strong>Core Libraries:</strong>
<ul>
<li>NumPy: For numerical operations and array manipulation.</li>
<li>SciPy: For optimization (<code>minimize</code>) and statistics (<code>norm</code>).</li>
<li>Scikit-learn: For Gaussian Process Regression (<code>GaussianProcessRegressor</code>, <code>Matern</code>, <code>ConstantKernel</code>, <code>WhiteKernel</code>), data scaling (<code>MinMaxScaler</code>), and handling warnings.</li>
</ul></li>
<li><strong>Custom Functions:</strong>
<ul>
<li><code>bailey_welch_schedule</code>, <code>get_v_star</code>, <code>compute_convolutions</code>: Functions assumed to be available for calculating components of the objective function (details not provided in the source document).</li>
<li><code>generate_weighted_list</code>: Creates a service time probability distribution.</li>
<li><code>calculate_objective_serv_time_lookup</code>: Assumed function to calculate EWT and ESP based on a schedule Y, duration d, and precomputed convolutions.</li>
<li><code>evaluate_objective</code>: Calculates the objective function <span class="math inline">\(C(x)\)</span> for a given perturbation vector <span class="math inline">\(U\)</span>.</li>
<li><code>hamming_distance</code>, <code>generate_diverse_random_dictionary</code>, <code>embed_vector</code>, <code>embed_batch</code>: Implement the HED embedding based on Deshwal et al.&nbsp;(2023).</li>
<li><code>get_fitted_model</code>: Fits the GP surrogate model.</li>
<li><code>expected_improvement</code>, <code>lower_confidence_bound</code>: Acquisition functions.</li>
<li><code>optimize_acqf_discrete_via_embedding</code>: Optimizes the acquisition function over the discrete space of <span class="math inline">\(U\)</span> vectors using the embedding.</li>
</ul></li>
<li><strong>Dataset:</strong> The initial schedule <span class="math inline">\(X\)</span> is provided as fixed data. Objective function values are generated dynamically during the BO process.</li>
</ul>
</section>
<section id="experimental-design" class="level3">
<h3 class="anchored" data-anchor-id="experimental-design">Experimental Design</h3>
<p>The experiment employs a standard Bayesian Optimization loop adapted for the combinatorial space of perturbation selection vectors <span class="math inline">\(U \in \{0,1\}^T\)</span> using the HED methodology.</p>
<ol type="1">
<li><strong>Initialization:</strong> A set of <code>N_INITIAL</code> unique, randomly generated binary vectors <span class="math inline">\(U\)</span> are evaluated using <code>evaluate_objective</code>.</li>
<li><strong>Iteration Loop (N_ITERATIONS):</strong>
<ul>
<li><strong>Dictionary Generation:</strong> A new ‘diverse random’ dictionary <code>A</code> of size <code>m x T</code> is generated (Alg. 1, Deshwal et al.).</li>
<li><strong>Embedding:</strong> All previously evaluated <span class="math inline">\(U\)</span> vectors are embedded into an <code>m</code>-dimensional space using Hamming distances to the dictionary <code>A</code>.</li>
<li><strong>Scaling:</strong> The embedded vectors are scaled (e.g., using <code>MinMaxScaler</code>).</li>
<li><strong>GP Model Fitting:</strong> A Gaussian Process Regressor with a Matérn kernel (and ARD) is fitted to the scaled embedded vectors and their corresponding (negated) objective function values.</li>
<li><strong>Acquisition Function Optimization:</strong> The chosen acquisition function (EI or LCB) is optimized over the space of possible <span class="math inline">\(U\)</span> vectors. This involves generating <code>NUM_CANDIDATES_Acqf</code> random candidate <span class="math inline">\(U\)</span> vectors, embedding them, scaling them, predicting their mean and standard deviation with the GP, calculating the acquisition function value, and selecting the top <code>BATCH_SIZE_q</code> candidates with the highest acquisition values.</li>
<li><strong>Evaluation:</strong> The selected candidate <span class="math inline">\(U\)</span> vectors (if not already evaluated) are evaluated using <code>evaluate_objective</code>.</li>
<li><strong>Augmentation:</strong> The newly evaluated points <span class="math inline">\((U, C(x+r(U)))\)</span> are added to the dataset.</li>
<li><strong>Kappa Update (for LCB-IK):</strong> If an improvement in the best objective value is found, the <code>kappa</code> parameter for LCB is increased by <code>KAPPA_INCREASE_FACTOR</code>.</li>
</ul></li>
<li><strong>Termination:</strong> The loop runs for a fixed number of iterations (<code>N_ITERATIONS</code>).</li>
<li><strong>Comparison:</strong> Three separate runs are conducted, differing only in the acquisition function used:
<ul>
<li>Expected Improvement (EI)</li>
<li>Lower Confidence Bound (LCB) with fixed <code>kappa</code></li>
<li>Lower Confidence Bound (LCB) with initial <code>kappa</code> dynamically increased upon finding improvements (LCB-IK).</li>
</ul></li>
</ol>
</section>
<section id="variables" class="level3">
<h3 class="anchored" data-anchor-id="variables">Variables</h3>
<ul>
<li><strong>Independent Variables:</strong>
<ul>
<li>Acquisition Function Choice: EI, LCB (fixed <span class="math inline">\(\kappa\)</span>), LCB-IK (increasing <span class="math inline">\(\kappa\)</span>).</li>
<li>Binary Selection Vector (<span class="math inline">\(U \in \{0,1\}^T\)</span>): The primary variable being optimized.</li>
<li>BO Hyperparameters:
<ul>
<li><code>N_INITIAL</code>: Number of initial random samples (20).</li>
<li><code>N_ITERATIONS</code>: Number of BO iterations (20).</li>
<li><code>BATCH_SIZE_q</code>: Number of points selected per iteration (5).</li>
<li><code>NUM_CANDIDATES_Acqf</code>: Number of random candidates sampled for acquisition function optimization (<span class="math inline">\(T \times 1024\)</span>).</li>
<li><code>m</code>: Dimension of the HED embedding (64).</li>
<li><code>kappa</code> (for LCB): Exploration-exploitation trade-off parameter (fixed at 2.576 or starting at 3.75 and increasing by 1.3).</li>
</ul></li>
</ul></li>
<li><strong>Dependent Variables:</strong>
<ul>
<li>Objective Function Value (<span class="math inline">\(C(x+r(U))\)</span>): The value returned by <code>evaluate_objective</code> for a given <span class="math inline">\(U\)</span>.</li>
<li>Best Objective Value Found: The minimum objective value observed across all evaluations up to a given iteration.</li>
<li>Computation Time: Time taken per BO iteration.</li>
<li>Final Best <span class="math inline">\(U\)</span> Vector: The binary vector corresponding to the best objective value found.</li>
<li>Final Best Schedule (<span class="math inline">\(Y_{best}\)</span>): The resulting schedule <span class="math inline">\(X + r(U_{best})\)</span>.</li>
</ul></li>
</ul>
</section>
<section id="data-collection" class="level3">
<h3 class="anchored" data-anchor-id="data-collection">Data Collection</h3>
<p>Data consists of pairs <span class="math inline">\((U, C(x+r(U)))\)</span>, where <span class="math inline">\(U\)</span> is a binary selection vector and <span class="math inline">\(C(x+r(U))\)</span> is the corresponding objective function value. Initial data points (<code>N_INITIAL</code>) are generated using random <span class="math inline">\(U\)</span> vectors. Subsequent data points are generated iteratively by the BO loop, selecting <span class="math inline">\(U\)</span> vectors that maximize the chosen acquisition function based on the GP model learned from previous evaluations. The <code>evaluate_objective</code> function serves as the data generation oracle. Feasibility (<span class="math inline">\(x+r(U) \ge 0\)</span>) is checked within <code>evaluate_objective</code>; infeasible solutions are assigned a <code>LARGE_PENALTY</code>.</p>
</section>
<section id="sample-size-and-selection" class="level3">
<h3 class="anchored" data-anchor-id="sample-size-and-selection">Sample Size and Selection</h3>
<ul>
<li><strong>Sample Size:</strong> Each experimental run evaluates a total of <span class="math inline">\(N_{eval} = N_{INITIAL} + N_{ITERATIONS} \times BATCH_{SIZE}_q = 20 + 20 \times 5 = 120\)</span> points (approximately, as duplicates might be skipped).</li>
<li><strong>Sample Selection:</strong>
<ul>
<li>Initial samples (<code>N_INITIAL</code>) are chosen randomly and uniquely from the <span class="math inline">\(\{0,1\}^T\)</span> space.</li>
<li>Subsequent samples (<code>BATCH_SIZE_q</code> per iteration) are selected based on maximizing the acquisition function (EI or LCB). This selection process is guided by the GP surrogate model, which predicts the objective function and its uncertainty across the embedded space. The acquisition function balances exploiting promising regions (low predicted objective) and exploring uncertain regions (high variance), aiming for sample efficiency. The selection happens over <code>NUM_CANDIDATES_Acqf</code> randomly generated <span class="math inline">\(U\)</span> vectors within the <code>optimize_acqf_discrete_via_embedding</code> function.</li>
</ul></li>
</ul>
</section>
<section id="experimental-procedure" class="level3">
<h3 class="anchored" data-anchor-id="experimental-procedure">Experimental Procedure</h3>
<p>The core procedure involves setting up the problem parameters, defining the objective and helper functions, and running the Bayesian Optimization loop for each of the three acquisition function variants.</p>
<p><strong>1. Setup and Problem Definition:</strong></p>
<p>Define constants (<code>N</code>, <code>T</code>, <code>d</code>, <code>max_s</code>, <code>q</code>, <code>w</code>, <code>l</code>), load initial schedule <code>X</code>, generate <code>v_star</code> matrix, and create the service time distribution <code>s</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Core Libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Dict, Tuple, Callable, Optional, Union, Any, Iterable</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Scikit-learn for GP, Scaling, and potentially acquisition functions</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process <span class="im">import</span> GaussianProcessRegressor</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process.kernels <span class="im">import</span> Matern, ConstantKernel, WhiteKernel</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> MinMaxScaler</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.exceptions <span class="im">import</span> ConvergenceWarning</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># SciPy for statistics (needed for Expected Improvement calculation)</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Assume these functions are defined elsewhere or provided</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># from functions import bailey_welch_schedule, get_v_star, compute_convolutions, calculate_objective_serv_time_lookup</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Mock Function Definitions (Replace with actual implementations) ---</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_v_star(T):</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generates the T x T basis change matrix V*."""</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder implementation - use the actual logic</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    v_star <span class="op">=</span> np.zeros((T, T))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        v_star[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        v_star[<span class="dv">0</span>, T<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        v_star[<span class="dv">1</span>, <span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        v_star[<span class="dv">1</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, T):</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        v_star[i, i] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        v_star[i, i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v_star</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_convolutions(s, N, q):</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Computes convolutions needed for objective calculation."""</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder - use actual logic</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Warning: Using mock compute_convolutions."</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">"mock_data"</span>: np.random.rand(N <span class="op">+</span> <span class="dv">1</span>)}</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_objective_serv_time_lookup(Y, d, convolutions):</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculates EWT and ESP based on schedule Y."""</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder - use actual logic</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Returns mock EWT, ESP values</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Warning: Using mock calculate_objective_serv_time_lookup for Y=</span><span class="sc">{</span>Y<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate some dependency on Y to avoid constant output</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    mock_ewt <span class="op">=</span> np.<span class="bu">sum</span>(Y) <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> np.random.rand() <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    mock_esp <span class="op">=</span> (np.<span class="bu">max</span>(Y) <span class="cf">if</span> Y.size <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>) <span class="op">*</span> <span class="fl">2.0</span> <span class="op">+</span> np.random.rand() <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mock_ewt, mock_esp</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co"># --- End Mock Function Definitions ---</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter warnings</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span><span class="pp">RuntimeWarning</span>)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span>ConvergenceWarning) <span class="co"># GP fitting might not converge</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a><span class="co"># Problem Definition</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Fixed Data (Use your actual data from the PDF for each run)</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Example from EI run:</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array([<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">4</span>])</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Example from LCB run:</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="co"># X = np.array([2, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 4])</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Example from LCB-IK run:</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="co"># X = np.array([2, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 4])</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">int</span>(np.<span class="bu">sum</span>(X)) <span class="co"># Total number of patients/tasks</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> X.shape[<span class="dv">0</span>]   <span class="co"># Dimension of the binary vector U (number of time slots)</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="dv">5</span>            <span class="co"># Length of each interval</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>max_s <span class="op">=</span> <span class="dv">20</span>       <span class="co"># Maximum service time</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.20</span>         <span class="co"># Probability of a scheduled patient not showing up</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="fl">0.1</span>          <span class="co"># Weight for the waiting time in objective function</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="dv">10</span>           <span class="co"># Target average service time</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>v_star <span class="op">=</span> get_v_star(T) <span class="co"># Get the V matrix (T x T)</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="co"># Create service time distribution</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_weighted_list(max_s: <span class="bu">int</span>, l: <span class="bu">float</span>, i: <span class="bu">int</span>) <span class="op">-&gt;</span> Optional[np.ndarray]:</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates a service time probability distribution using optimization.</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a><span class="co">    This function creates a discrete probability distribution over max_s possible</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="co">    service times (from 1 to max_s). It uses optimization (SLSQP) to find a</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="co">    distribution whose weighted average service time is as close as possible</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="co">    to a target value 'l', subject to the constraint that the probabilities</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="co">    sum to 1 and each probability is between 0 and 1.</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a><span class="co">    After finding the distribution, it sorts the probabilities: the first 'i'</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a><span class="co">    probabilities (corresponding to service times 1 to i) are sorted in</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="co">    ascending order, and the remaining probabilities (service times i+1 to max_s)</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="co">    are sorted in descending order.</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="co">    Note: Requires NumPy and SciPy libraries (specifically scipy.optimize.minimize).</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a><span class="co">        max_s (int): Maximum service time parameter (number of probability bins).</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a><span class="co">                     Must be a positive integer.</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="co">        l (float): The target weighted average service time for the distribution.</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a><span class="co">                   Must be between 1 and max_s, inclusive.</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a><span class="co">        i (int): The index determining the sorting split point. Probabilities</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a><span class="co">                 for service times 1 to 'i' are sorted ascendingly, and</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a><span class="co">                 probabilities for service times 'i+1' to 'max_s' are sorted</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a><span class="co">                 descendingly. Must be between 1 and max_s-1 for meaningful sorting.</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="co">        numpy.ndarray: An array of size max_s+1. The first element (index 0) is 0.</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a><span class="co">                       Elements from index 1 to max_s represent the calculated</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="co">                       and sorted probability distribution, summing to 1.</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="co">                       Returns None if optimization fails or inputs are invalid.</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input Validation</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(max_s, <span class="bu">int</span>) <span class="kw">or</span> max_s <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error: max_s must be a positive integer, but got </span><span class="sc">{</span>max_s<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(l, (<span class="bu">int</span>, <span class="bu">float</span>)) <span class="kw">or</span> <span class="kw">not</span> (<span class="dv">1</span> <span class="op">&lt;=</span> l <span class="op">&lt;=</span> max_s):</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error: Target average 'l' (</span><span class="sc">{</span>l<span class="sc">}</span><span class="ss">) must be between 1 and max_s (</span><span class="sc">{</span>max_s<span class="sc">}</span><span class="ss">)."</span>)</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(i, <span class="bu">int</span>) <span class="kw">or</span> <span class="kw">not</span> (<span class="dv">0</span> <span class="op">&lt;</span> i <span class="op">&lt;</span> max_s):</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error: Sorting index 'i' (</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">) must be between 1 and max_s-1 (</span><span class="sc">{</span>max_s<span class="op">-</span><span class="dv">1</span><span class="sc">}</span><span class="ss">)."</span>)</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If clamping is desired instead of error:</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"Warning: Index 'i' ({i}) is outside the valid range (1 to max_s-1). Clamping.")</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>        <span class="co"># i = max(1, min(i, max_s - 1))</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span> <span class="co"># Strict check based on docstring requirement</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inner helper function for optimization</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> objective(x: np.ndarray) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Objective function: Squared difference between weighted average and target l."""</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>        <span class="co"># x represents probabilities P(1) to P(max_s)</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>        service_times <span class="op">=</span> np.arange(<span class="dv">1</span>, max_s <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>        weighted_avg <span class="op">=</span> np.dot(service_times, x) <span class="co"># Equivalent to sum(k*P(k) for k=1..max_s)</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (weighted_avg <span class="op">-</span> l) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Constraints for optimization</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Constraint 1: The sum of the probabilities must be 1</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>    constraints <span class="op">=</span> ({</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>        <span class="st">'type'</span>: <span class="st">'eq'</span>,</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>        <span class="st">'fun'</span>: <span class="kw">lambda</span> x: np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="fl">1.0</span> <span class="co"># Ensure float comparison</span></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bounds: Each probability value x[k] must be between 0 and 1</span></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Creates a list of max_s tuples, e.g., [(0, 1), (0, 1), ..., (0, 1)]</span></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>    bounds <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>)] <span class="op">*</span> max_s</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial guess: Use Dirichlet distribution to get a random distribution that sums to 1.</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Provides a starting point for the optimizer. np.ones(max_s) gives equal weights initially.</span></span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>    initial_guess <span class="op">=</span> np.random.dirichlet(np.ones(max_s))</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform Optimization</span></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> minimize(</span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>            objective,</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>            initial_guess,</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">'SLSQP'</span>,</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>            bounds<span class="op">=</span>bounds,</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>            constraints<span class="op">=</span>constraints,</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>            options<span class="op">=</span>{<span class="st">'disp'</span>: <span class="va">False</span>} <span class="co"># Set True for detailed optimizer output</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if optimization was successful</span></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> result.success:</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Warning: Optimization failed! Message: </span><span class="sc">{</span>result<span class="sc">.</span>message<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Optionally print result object for more details: print(result)</span></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span> <span class="co"># Indicate failure</span></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The optimized probabilities (P(1) to P(max_s))</span></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>        optimized_probs <span class="op">=</span> result.x</span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Post-process: Correct potential floating point inaccuracies</span></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ensure probabilities are non-negative and sum *exactly* to 1</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>        optimized_probs[optimized_probs <span class="op">&lt;</span> <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span> <span class="co"># Clamp small negatives to 0</span></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> np.<span class="bu">sum</span>(optimized_probs)</span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> np.isclose(current_sum, <span class="fl">1.0</span>):</span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sum <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># Avoid division by zero</span></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>                 optimized_probs <span class="op">/=</span> current_sum <span class="co"># Normalize to sum to 1</span></span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="st">"Warning: Optimization resulted in zero sum probabilities."</span>)</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a>                 <span class="co"># Handle this case maybe return uniform distribution or None</span></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>                 <span class="cf">return</span> <span class="va">None</span> <span class="co"># Or return uniform: np.ones(max_s) / max_s</span></span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"An error occurred during optimization: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reorder the probabilities based on the index 'i'</span></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Split the probabilities P(1)...P(i) and P(i+1)...P(max_s)</span></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note: Python slicing is exclusive of the end index, array indexing is 0-based.</span></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a>    <span class="co"># result.x[0] corresponds to P(1), result.x[i-1] to P(i).</span></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>    <span class="co"># result.x[i] corresponds to P(i+1), result.x[max_s-1] to P(max_s).</span></span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Probabilities P(1) to P(i)</span></span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a>    first_part_probs <span class="op">=</span> optimized_probs[:i]</span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Probabilities P(i+1) to P(max_s)</span></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a>    second_part_probs <span class="op">=</span> optimized_probs[i:]</span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort the first part ascending, the second part descending</span></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a>    sorted_first_part <span class="op">=</span> np.sort(first_part_probs)</span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>    sorted_second_part <span class="op">=</span> np.sort(second_part_probs)[::<span class="op">-</span><span class="dv">1</span>] <span class="co"># [::-1] reverses array</span></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create final output array</span></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Array of size max_s + 1, initialized to zeros. Index 0 unused.</span></span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> np.zeros(max_s <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign the sorted probabilities back into the correct slots (index 1 onwards)</span></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>    values[<span class="dv">1</span>:i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> sorted_first_part      <span class="co"># Assign P(1)...P(i)</span></span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>    values[i<span class="op">+</span><span class="dv">1</span>:max_s <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> sorted_second_part <span class="co"># Assign P(i+1)...P(max_s)</span></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Final check on sum after potential normalization/sorting</span></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.isclose(np.<span class="bu">sum</span>(values[<span class="dv">1</span>:]), <span class="fl">1.0</span>):</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a>         <span class="bu">print</span>(<span class="ss">f"Warning: Final distribution sum is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(values[<span class="dv">1</span>:])<span class="sc">}</span><span class="ss">, not 1.0."</span>)</span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the final array with the sorted probability distribution</span></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> values</span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">5</span> <span class="co"># First 5 highest values in ascending order, rest in descending order</span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> generate_weighted_list(max_s, l, i)</span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> s <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Failed to generate service time distribution."</span>)</span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>convolutions <span class="op">=</span> compute_convolutions(s, N, q)</span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a><span class="co"># Objective Function Calculation</span></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>LARGE_PENALTY <span class="op">=</span> <span class="fl">1e10</span> <span class="co"># Penalty for infeasible solutions</span></span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_objective(U_np, X_vec, v_star, convolutions, d, w):</span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a><span class="co">    Target function: Evaluates objective for a single binary numpy array U.</span></span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns a float. Checks feasibility (Y &gt;= 0).</span></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input validation</span></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(U_np, np.ndarray):</span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">"Input U must be a numpy array"</span>)</span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_np.ndim <span class="op">!=</span> <span class="dv">1</span>:</span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input U must be 1-dimensional"</span>)</span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_np.shape[<span class="dv">0</span>] <span class="op">!=</span> v_star.shape[<span class="dv">0</span>]: <span class="co"># T should match rows of v_star</span></span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Dimension mismatch: U length </span><span class="sc">{</span>U_np<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> != V* rows </span><span class="sc">{</span>v_star<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> X_vec.shape[<span class="dv">0</span>] <span class="op">!=</span> v_star.shape[<span class="dv">1</span>]: <span class="co"># T should match columns of v_star</span></span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Dimension mismatch: X length </span><span class="sc">{</span>X_vec<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> must match V* columns </span><span class="sc">{</span>v_star<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.<span class="bu">all</span>((U_np <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (U_np <span class="op">==</span> <span class="dv">1</span>)):</span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input U must be binary (0s and 1s)."</span>)</span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate perturbation r(U) = sum(u_i * v_i)</span></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is equivalent to summing rows of v_star where U_np is 1</span></span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a>    V_sum <span class="op">=</span> np.<span class="bu">sum</span>(v_star[U_np <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the potential new schedule Y = X + r(U)</span></span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> X_vec <span class="op">+</span> V_sum</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check feasibility (all elements of Y must be non-negative)</span></span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.<span class="bu">all</span>(Y <span class="op">&gt;=</span> <span class="dv">0</span>):</span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If feasible, calculate the actual objective</span></span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Ensure Y is integer type if required by the objective function</span></span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>            Y_int <span class="op">=</span> Y.astype(<span class="bu">int</span>)</span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>            ewt, esp <span class="op">=</span> calculate_objective_serv_time_lookup(Y_int, d, convolutions)</span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a>            objective_value <span class="op">=</span> w <span class="op">*</span> ewt <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> esp</span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print(f"  Feasible U: {U_np}, Y: {Y_int}, EWT: {ewt:.4f}, ESP: {esp:.4f}, Obj: {objective_value:.4f}") # Debug</span></span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> objective_value</span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Error during objective calculation for feasible Y=</span><span class="sc">{</span>Y<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> LARGE_PENALTY <span class="co"># Penalize if calculation fails unexpectedly</span></span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If infeasible, return a large penalty value</span></span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"  Infeasible U: {U_np}, Y: {Y}") # Debug</span></span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> LARGE_PENALTY</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>2. HED Implementation (Based on Deshwal et al., 2023):</strong></p>
<p>Define functions for Hamming distance, generating the diverse random dictionary, and embedding vectors.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># HED Implementation (Deshwal et al., 2023)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hamming_distance(u1, u2):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculates Hamming distance between two binary numpy arrays."""</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(u1 <span class="op">!=</span> u2)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_diverse_random_dictionary(T, m):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates the random dictionary A for HED using diverse sparsity.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    (Based on Algorithm 1 / Appendix G in Deshwal et al., 2023)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    dictionary_A <span class="op">=</span> np.zeros((m, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample theta for density of 1s in this dictionary vector</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        theta <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate row based on theta</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> (np.random.rand(T) <span class="op">&lt;</span> theta).astype(<span class="bu">int</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        dictionary_A[i, :] <span class="op">=</span> row</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dictionary_A</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_vector(U_np, dictionary_A):</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Embeds a single binary vector U using HED."""</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    embedding_phi <span class="op">=</span> np.zeros(m, dtype<span class="op">=</span><span class="bu">float</span>) <span class="co"># Use float for GP input</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        embedding_phi[i] <span class="op">=</span> hamming_distance(U_np, dictionary_A[i, :])</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> embedding_phi</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_batch(U_batch_np, dictionary_A):</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Embeds a batch of binary vectors U."""</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input U_batch_np is expected to be a NumPy array (n_samples x T)</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> U_batch_np.ndim <span class="op">==</span> <span class="dv">1</span>: <span class="co"># Handle single vector case</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        U_batch_np <span class="op">=</span> U_batch_np.reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    batch_size <span class="op">=</span> U_batch_np.shape[<span class="dv">0</span>]</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    embeddings_np <span class="op">=</span> np.zeros((batch_size, m), dtype<span class="op">=</span><span class="bu">float</span>) <span class="co"># Use float for GP</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(batch_size):</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        embeddings_np[j, :] <span class="op">=</span> embed_vector(U_batch_np[j, :], dictionary_A)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return NumPy array directly</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> embeddings_np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>3. BO Helper Functions:</strong></p>
<p>Define functions for fitting the GP model and calculating acquisition functions (EI and LCB).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># BO Helper Functions</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_fitted_model(train_X_embedded_scaled, train_Y, m):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Fits a Gaussian Process Regressor model to the SCALED embedded data.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes train_Y contains negative objective values (for maximization).</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    'm' is the embedding dimension.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_Y.ndim <span class="op">&gt;</span> <span class="dv">1</span> <span class="kw">and</span> train_Y.shape[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        train_Y <span class="op">=</span> train_Y.ravel() <span class="co"># sklearn GP expects 1D target array</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_X_embedded_scaled.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> train_Y.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>         <span class="bu">print</span>(<span class="st">"Warning: Cannot fit GP model with no data."</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_X_embedded_scaled.shape[<span class="dv">0</span>] <span class="op">!=</span> train_Y.shape[<span class="dv">0</span>]:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Warning: Mismatch between train_X (</span><span class="sc">{</span>train_X_embedded_scaled<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">) and train_Y (</span><span class="sc">{</span>train_Y<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">) samples."</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_X_embedded_scaled.shape[<span class="dv">1</span>] <span class="op">!=</span> m:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Warning: Mismatch between train_X columns (</span><span class="sc">{</span>train_X_embedded_scaled<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">) and embedding dim m (</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">)."</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Adjust m if possible, or raise error depending on desired behavior</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># m = train_X_embedded_scaled.shape[1] # Example: Adjust m</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># return None # Example: Fail</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define the kernel for the Gaussian Process</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Matern kernel is a common choice, nu=2.5 is smooth (twice differentiable)</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ConstantKernel handles the overall variance scaling</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># WhiteKernel handles the observation noise</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> ConstantKernel(<span class="fl">1.0</span>, constant_value_bounds<span class="op">=</span>(<span class="fl">1e-3</span>, <span class="fl">1e3</span>)) <span class="op">*</span> <span class="op">\</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>             Matern(length_scale<span class="op">=</span>np.ones(m), <span class="co"># Enable ARD, initialize length scales to 1</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>                    length_scale_bounds<span class="op">=</span>(<span class="fl">1e-2</span>, <span class="fl">1e2</span>),</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>                    nu<span class="op">=</span><span class="fl">2.5</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>             WhiteKernel(noise_level<span class="op">=</span><span class="fl">1e-4</span>, <span class="co"># Initial guess for noise</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>                         noise_level_bounds<span class="op">=</span>(<span class="fl">1e-6</span>, <span class="fl">1e1</span>)) <span class="co"># Bounds for noise level</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Instantiate the Gaussian Process Regressor</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># alpha: Value added to the diagonal of the kernel matrix during fitting</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">#        for numerical stability (can also be seen as additional noise)</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># n_restarts_optimizer: Restarts optimizer to find better hyperparameters</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    gp_model <span class="op">=</span> GaussianProcessRegressor(</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        kernel<span class="op">=</span>kernel,</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        alpha<span class="op">=</span><span class="fl">1e-10</span>, <span class="co"># Small value for numerical stability</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        n_restarts_optimizer<span class="op">=</span><span class="dv">10</span>, <span class="co"># More restarts -&gt; better hyperparams but slower</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        random_state<span class="op">=</span><span class="dv">42</span> <span class="co"># For reproducibility of optimizer restarts</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fit the GP model</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        gp_model.fit(train_X_embedded_scaled, train_Y)</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print("GP model fitted successfully.") # Debug</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"  Log-marginal-likelihood: {gp_model.log_marginal_likelihood_value_:.3f}") # Debug</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"  Kernel parameters: {gp_model.kernel_}") # Debug</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error fitting GP model: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Train X shape: </span><span class="sc">{</span>train_X_embedded_scaled<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Train Y shape: </span><span class="sc">{</span>train_Y<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span> <span class="co"># Return None if fitting fails</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gp_model</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Acquisition Functions ---</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expected_improvement(mu, sigma, f_best, xi<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the Expected Improvement acquisition function.</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes maximization (f_best is the current maximum observed NEGATIVE value).</span></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a><span class="co">        mu, sigma: Predicted mean and standard deviation (NumPy arrays).</span></span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a><span class="co">        f_best: Current best observed function value (scalar, max of negative objectives).</span></span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a><span class="co">        xi: Exploration-exploitation trade-off parameter.</span></span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a><span class="co">        ei: Expected improvement values (NumPy array).</span></span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure sigma is positive and non-zero to avoid division errors/warnings</span></span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.maximum(sigma, <span class="fl">1e-9</span>)</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> (mu <span class="op">-</span> f_best <span class="op">-</span> xi) <span class="op">/</span> sigma</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>    ei <span class="op">=</span> (mu <span class="op">-</span> f_best <span class="op">-</span> xi) <span class="op">*</span> norm.cdf(Z) <span class="op">+</span> sigma <span class="op">*</span> norm.pdf(Z)</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set EI to 0 where variance is negligible (or where sigma was clamped)</span></span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>    ei[sigma <span class="op">&lt;=</span> <span class="fl">1e-9</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ei</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lower_confidence_bound(mu, sigma, kappa<span class="op">=</span><span class="fl">2.576</span>):</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the Lower Confidence Bound (LCB) acquisition function.</span></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes GP model predicts NEGATIVE objective values (maximization target).</span></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a><span class="co">    We want to MAXIMIZE LCB = mu - kappa * sigma.</span></span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a><span class="co">    This corresponds to minimizing the original objective:</span></span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a><span class="co">    min (objective) &lt;=&gt; max (-objective)</span></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a><span class="co">    High mu (less negative) is good. Low sigma (low uncertainty) is preferred.</span></span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a><span class="co">    LCB balances predicted performance (mu) and uncertainty (sigma).</span></span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a><span class="co">        mu, sigma: Predicted mean and standard deviation (NumPy arrays).</span></span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a><span class="co">        kappa: Controls the balance between exploitation (high mu -&gt; low original obj)</span></span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a><span class="co">               and exploration (low sigma). Higher kappa encourages exploration more.</span></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a><span class="co">        lcb: Lower Confidence Bound values (NumPy array).</span></span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure sigma is non-negative</span></span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.maximum(sigma, <span class="dv">0</span>)</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>    lcb <span class="op">=</span> mu <span class="op">-</span> kappa <span class="op">*</span> sigma <span class="co"># Maximize this value</span></span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lcb</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Acquisition Function Optimization ---</span></span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimize_acqf_discrete_via_embedding(gp_model, scaler, dictionary_A, T, q, num_candidates, acquisition_func, current_best_neg_f_val<span class="op">=</span><span class="va">None</span>, kappa<span class="op">=</span><span class="va">None</span>, xi<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a><span class="co">    Optimizes the specified acquisition function (EI or LCB) by sampling random</span></span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a><span class="co">    binary candidates, embedding, SCALING, predicting with GP, and calculating acqf values.</span></span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a><span class="co">    Selects the top q candidates based on the acquisition function.</span></span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a><span class="co">        gp_model: The fitted Gaussian Process model.</span></span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a><span class="co">        scaler: The fitted scaler (e.g., MinMaxScaler).</span></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a><span class="co">        dictionary_A: The current dictionary used for embedding.</span></span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a><span class="co">        T: Dimension of the binary space.</span></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a><span class="co">        q: Number of top candidates to return (batch size).</span></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a><span class="co">        num_candidates: Number of random candidates to generate and evaluate.</span></span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a><span class="co">        acquisition_func: String identifier ('EI' or 'LCB').</span></span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a><span class="co">        current_best_neg_f_val (float, optional): Max negative objective value seen so far. Required for EI.</span></span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a><span class="co">        kappa (float, optional): Kappa value for LCB. Required for LCB.</span></span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a><span class="co">        xi (float, optional): Xi value for EI. Required for EI.</span></span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a><span class="co">        numpy.ndarray: Top q candidate U vectors as a numpy array (q x T).</span></span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a><span class="co">                       Returns empty array if inputs are invalid or process fails.</span></span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> gp_model <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> scaler <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Error: GP model or scaler is not provided."</span>)</span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> dictionary_A.shape[<span class="dv">0</span>]</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Generate Random Binary Candidates</span></span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>    candidate_u_vectors_np <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>(num_candidates, T))</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optional: Ensure unique candidates if needed (adds overhead but might be beneficial)</span></span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>    <span class="co"># candidate_u_vectors_np = np.unique(candidate_u_vectors_np, axis=0)</span></span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>    <span class="co"># num_candidates = candidate_u_vectors_np.shape[0] # Update count if unique is used</span></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> candidate_u_vectors_np.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Warning: No unique candidates generated."</span>)</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Embed the Candidates</span></span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a>    embedded_candidates_np <span class="op">=</span> embed_batch(candidate_u_vectors_np, dictionary_A)</span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Scale the Embedded Candidates</span></span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use the *fitted* scaler from the training data</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>        embedded_candidates_scaled_np <span class="op">=</span> scaler.transform(embedded_candidates_np)</span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error scaling candidates: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Predict Mean and Std Dev using the GP Model</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>        mu, std <span class="op">=</span> gp_model.predict(embedded_candidates_scaled_np, return_std<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error predicting with GP model: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5. Calculate Acquisition Function</span></span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> acquisition_func <span class="op">==</span> <span class="st">'EI'</span>:</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_best_neg_f_val <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> xi <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Error: current_best_neg_f_val and xi must be provided for EI."</span>)</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>        acq_values <span class="op">=</span> expected_improvement(mu, std, current_best_neg_f_val, xi<span class="op">=</span>xi)</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> acquisition_func <span class="op">==</span> <span class="st">'LCB'</span>:</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> kappa <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Error: kappa must be provided for LCB."</span>)</span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>        acq_values <span class="op">=</span> lower_confidence_bound(mu, std, kappa<span class="op">=</span>kappa)</span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error: Unknown acquisition function '</span><span class="sc">{</span>acquisition_func<span class="sc">}</span><span class="ss">'. Use 'EI' or 'LCB'."</span>)</span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 6. Select Top Candidates</span></span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use np.argsort to find indices that would sort the array (ascending)</span></span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select the last q indices for the highest acquisition values (EI or LCB)</span></span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If q=1, np.argmax(acq_values) is simpler but argsort works generally</span></span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> acq_values.size <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Warning: No acquisition values calculated."</span>)</span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure q is not larger than the number of candidates evaluated</span></span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>    q_actual <span class="op">=</span> <span class="bu">min</span>(q, acq_values.size)</span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> q_actual <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> np.empty((<span class="dv">0</span>, T), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get indices of the top q_actual values</span></span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Partition is faster than full sort for finding top k: O(N) vs O(N log N)</span></span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We want indices of the largest values, so partition around (N - q_actual)-th element</span></span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a>    kth_largest_idx <span class="op">=</span> acq_values.size <span class="op">-</span> q_actual</span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Indices of elements &gt;= the (N-q_actual)-th element</span></span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a>    top_indices_unordered <span class="op">=</span> np.argpartition(acq_values, kth_largest_idx)[kth_largest_idx:]</span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we need exactly q_actual and there are ties, we might get more. Refine:</span></span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(top_indices_unordered) <span class="op">&gt;</span> q_actual:</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort the values of these top candidates and take the highest q_actual</span></span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>        top_values <span class="op">=</span> acq_values[top_indices_unordered]</span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a>        sorted_within_top_indices <span class="op">=</span> np.argsort(top_values)[::<span class="op">-</span><span class="dv">1</span>] <span class="co"># Descending order of value</span></span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>        top_indices <span class="op">=</span> top_indices_unordered[sorted_within_top_indices[:q_actual]]</span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a>         <span class="co"># If we got exactly q_actual or fewer, sort them by value</span></span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>         top_values <span class="op">=</span> acq_values[top_indices_unordered]</span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a>         sorted_within_top_indices <span class="op">=</span> np.argsort(top_values)[::<span class="op">-</span><span class="dv">1</span>] <span class="co"># Descending order of value</span></span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a>         top_indices <span class="op">=</span> top_indices_unordered[sorted_within_top_indices]</span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the corresponding original U vectors</span></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> candidate_u_vectors_np[top_indices, :]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>4. Bayesian Optimization Loop:</strong></p>
<p>Execute the main BO loop, iterating, fitting the model, optimizing the acquisition function, and evaluating points. This needs to be run three times, changing the <code>ACQUISITION_FUNCTION</code> parameter and <code>KAPPA</code> / <code>KAPPA_INCREASE_FACTOR</code> as needed.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># BO Loop Parameters (Adjust per experiment variant)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Variant 1: Expected Improvement (EI) ---</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>ACQUISITION_FUNCTION <span class="op">=</span> <span class="st">'EI'</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>XI <span class="op">=</span> <span class="fl">0.01</span> <span class="co"># Exploration parameter for EI</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>KAPPA <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>INITIAL_KAPPA <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>KAPPA_INCREASE_FACTOR <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Use X from EI run in PDF</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># # --- Variant 2: Lower Confidence Bound (LCB) ---</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co"># ACQUISITION_FUNCTION = 'LCB'</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># XI = None</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># KAPPA = 2.576 # Fixed kappa for LCB</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co"># INITIAL_KAPPA = KAPPA</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co"># KAPPA_INCREASE_FACTOR = None</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># # Use X from LCB run in PDF</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co"># # --- Variant 3: LCB with Increasing Kappa (LCB-IK) ---</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co"># ACQUISITION_FUNCTION = 'LCB'</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co"># XI = None</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="co"># KAPPA = None # Kappa will be dynamic</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="co"># INITIAL_KAPPA = 3.75 # Starting kappa</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="co"># KAPPA_INCREASE_FACTOR = 1.3 # Factor to increase kappa on improvement</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="co"># # Use X from LCB-IK run in PDF</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Common Parameters ---</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>N_INITIAL <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>N_ITERATIONS <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>BATCH_SIZE_q <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>NUM_CANDIDATES_Acqf <span class="op">=</span> T <span class="op">*</span> <span class="dv">1024</span> <span class="co"># Number of random U's to sample for acqf opt</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">64</span> <span class="co"># Dimension of the embedding space</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Data Storage ---</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>evaluated_U_np_list <span class="op">=</span> [] <span class="co"># List to store evaluated U vectors (binary, as numpy arrays)</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>evaluated_f_vals <span class="op">=</span> []    <span class="co"># List to store raw objective values (lower is better)</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>train_Y_list <span class="op">=</span> []        <span class="co"># List to store NEGATED objective values for GP (higher is better)</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Initialization</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"--- Starting BO with </span><span class="sc">{</span>ACQUISITION_FUNCTION<span class="sc">}</span><span class="ss"> ---"</span>)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Generating </span><span class="sc">{</span>N_INITIAL<span class="sc">}</span><span class="ss"> initial points..."</span>)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>initial_candidates_U <span class="op">=</span> []</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(initial_candidates_U) <span class="op">&lt;</span> N_INITIAL:</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    U_init <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>T)</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure unique initial points (compare numpy arrays correctly)</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    is_duplicate <span class="op">=</span> <span class="bu">any</span>(np.array_equal(U_init, u) <span class="cf">for</span> u <span class="kw">in</span> initial_candidates_U)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> is_duplicate:</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>        initial_candidates_U.append(U_init)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, U_init <span class="kw">in</span> <span class="bu">enumerate</span>(initial_candidates_U):</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Evaluating initial point </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>N_INITIAL<span class="sc">}</span><span class="ss">..."</span>)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    f_val <span class="op">=</span> evaluate_objective(U_init, X, v_star, convolutions, d, w)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> f_val <span class="op">&lt;</span> LARGE_PENALTY: <span class="co"># Only store valid initial points</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>        neg_f_val <span class="op">=</span> <span class="op">-</span>f_val</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list.append(U_init)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals.append(f_val)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>        train_Y_list.append(neg_f_val)</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Initial point </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Obj = </span><span class="sc">{</span>f_val<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Initial point </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Infeasible (Penalty)"</span>)</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial best objective</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>best_obj_so_far <span class="op">=</span> <span class="bu">min</span>(evaluated_f_vals) <span class="cf">if</span> evaluated_f_vals <span class="cf">else</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial best objective value: </span><span class="sc">{</span>best_obj_so_far <span class="cf">if</span> np<span class="sc">.</span>isfinite(best_obj_so_far) <span class="cf">else</span> <span class="st">'None (all initial points infeasible)'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize kappa for LCB-IK</span></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>current_kappa <span class="op">=</span> INITIAL_KAPPA</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> ACQUISITION_FUNCTION <span class="op">==</span> <span class="st">'LCB'</span> <span class="kw">and</span> KAPPA_INCREASE_FACTOR <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Initial Kappa: </span><span class="sc">{</span>current_kappa<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. BO Iterations</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(N_ITERATIONS):</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Iteration </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>N_ITERATIONS<span class="sc">}</span><span class="ss"> ---"</span>)</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if we have any valid points to model</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> evaluated_U_np_list:</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Warning: No valid points evaluated yet. Evaluating random points."</span>)</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Try to evaluate a few more random points if initialization failed</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>        new_random_U <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>T)</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>        is_duplicate <span class="op">=</span> <span class="bu">any</span>(np.array_equal(new_random_U, u) <span class="cf">for</span> u <span class="kw">in</span> evaluated_U_np_list)</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_duplicate:</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>             f_val <span class="op">=</span> evaluate_objective(new_random_U, X, v_star, convolutions, d, w)</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>             <span class="cf">if</span> f_val <span class="op">&lt;</span> LARGE_PENALTY:</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>                 neg_f_val <span class="op">=</span> <span class="op">-</span>f_val</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>                 evaluated_U_np_list.append(new_random_U)</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>                 evaluated_f_vals.append(f_val)</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>                 train_Y_list.append(neg_f_val)</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>                 best_obj_so_far <span class="op">=</span> <span class="bu">min</span>(best_obj_so_far, f_val)</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="ss">f" Evaluated random point: Obj = </span><span class="sc">{</span>f_val<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>             <span class="cf">else</span>:</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="st">" Evaluated random point: Infeasible"</span>)</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> evaluated_U_np_list: <span class="co"># Still no points? Skip iteration.</span></span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>             <span class="bu">print</span>(<span class="st">"Skipping iteration as no valid points are available."</span>)</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>             <span class="cf">continue</span></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># a. Generate dictionary A for HED</span></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>    current_dictionary_A <span class="op">=</span> generate_diverse_random_dictionary(T, m)</span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># b. Embed ALL evaluated U vectors so far</span></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_array <span class="op">=</span> np.array(evaluated_U_np_list)</span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a>    embedded_train_X <span class="op">=</span> embed_batch(evaluated_U_np_array, current_dictionary_A)</span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>    <span class="co"># c. Scale the embedded training data</span></span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a>    scaler <span class="op">=</span> MinMaxScaler()</span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fit scaler only if there's data</span></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> embedded_train_X.shape[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fit and transform</span></span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a>        embedded_train_X_scaled <span class="op">=</span> scaler.fit_transform(embedded_train_X)</span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Handle case with no data (should have been caught above)</span></span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a>        embedded_train_X_scaled <span class="op">=</span> embedded_train_X <span class="co"># Will be empty</span></span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure train_Y is a NumPy array for fitting</span></span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>    train_Y_for_fit <span class="op">=</span> np.array(train_Y_list) <span class="co"># Use the list directly</span></span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>    <span class="co"># d. Fit GP Model using SCALED data</span></span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Fitting GP model..."</span>)</span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a>    gp_model <span class="op">=</span> get_fitted_model(embedded_train_X_scaled, train_Y_for_fit, m)</span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> gp_model <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Warning: Failed to fit GP model. Skipping acquisition function optimization."</span>)</span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span> <span class="co"># Skip if GP fitting failed</span></span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"GP model fitted."</span>)</span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a>    <span class="co"># e. Determine current best value for Acquisition Function</span></span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We are maximizing the negative objective in the GP</span></span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a>    current_best_neg_f_val <span class="op">=</span> np.<span class="bu">max</span>(train_Y_for_fit) <span class="cf">if</span> train_Y_for_fit.size <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prevent potential issues if all points were infeasible (very large negative values)</span></span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if the best value is close to the negative penalty</span></span>
<span id="cb4-137"><a href="#cb4-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_best_neg_f_val <span class="op">&lt;=</span> <span class="op">-</span>LARGE_PENALTY <span class="op">/</span> <span class="dv">2</span> <span class="kw">and</span> np.isfinite(current_best_neg_f_val):</span>
<span id="cb4-138"><a href="#cb4-138" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Warning: Current best NEGATIVE value (</span><span class="sc">{</span>current_best_neg_f_val<span class="sc">:.2f}</span><span class="ss">) is very low, possibly indicating only infeasible points found."</span>)</span>
<span id="cb4-139"><a href="#cb4-139" aria-hidden="true" tabindex="-1"></a>        <span class="co"># In EI, this might lead to near-zero acquisition values if xi is small.</span></span>
<span id="cb4-140"><a href="#cb4-140" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Consider adjusting xi or handling this case if it causes issues.</span></span>
<span id="cb4-141"><a href="#cb4-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-142"><a href="#cb4-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-143"><a href="#cb4-143" aria-hidden="true" tabindex="-1"></a>    <span class="co"># f. Optimize Acquisition Function</span></span>
<span id="cb4-144"><a href="#cb4-144" aria-hidden="true" tabindex="-1"></a>    acqf_params <span class="op">=</span> {}</span>
<span id="cb4-145"><a href="#cb4-145" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ACQUISITION_FUNCTION <span class="op">==</span> <span class="st">'EI'</span>:</span>
<span id="cb4-146"><a href="#cb4-146" aria-hidden="true" tabindex="-1"></a>        acqf_params[<span class="st">'xi'</span>] <span class="op">=</span> XI</span>
<span id="cb4-147"><a href="#cb4-147" aria-hidden="true" tabindex="-1"></a>        acqf_params[<span class="st">'current_best_neg_f_val'</span>] <span class="op">=</span> current_best_neg_f_val</span>
<span id="cb4-148"><a href="#cb4-148" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Optimizing acquisition function (</span><span class="sc">{</span>ACQUISITION_FUNCTION<span class="sc">}</span><span class="ss"> with xi=</span><span class="sc">{</span>XI<span class="sc">:.2f}</span><span class="ss">)..."</span>)</span>
<span id="cb4-149"><a href="#cb4-149" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> ACQUISITION_FUNCTION <span class="op">==</span> <span class="st">'LCB'</span>:</span>
<span id="cb4-150"><a href="#cb4-150" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use fixed KAPPA or dynamic current_kappa</span></span>
<span id="cb4-151"><a href="#cb4-151" aria-hidden="true" tabindex="-1"></a>        kappa_to_use <span class="op">=</span> KAPPA <span class="cf">if</span> KAPPA_INCREASE_FACTOR <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> current_kappa</span>
<span id="cb4-152"><a href="#cb4-152" aria-hidden="true" tabindex="-1"></a>        acqf_params[<span class="st">'kappa'</span>] <span class="op">=</span> kappa_to_use</span>
<span id="cb4-153"><a href="#cb4-153" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Optimizing acquisition function (</span><span class="sc">{</span>ACQUISITION_FUNCTION<span class="sc">}</span><span class="ss"> with Kappa=</span><span class="sc">{</span>kappa_to_use<span class="sc">:.3f}</span><span class="ss">)..."</span>)</span>
<span id="cb4-154"><a href="#cb4-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-155"><a href="#cb4-155" aria-hidden="true" tabindex="-1"></a>    next_U_candidates_np <span class="op">=</span> optimize_acqf_discrete_via_embedding(</span>
<span id="cb4-156"><a href="#cb4-156" aria-hidden="true" tabindex="-1"></a>        gp_model<span class="op">=</span>gp_model,</span>
<span id="cb4-157"><a href="#cb4-157" aria-hidden="true" tabindex="-1"></a>        scaler<span class="op">=</span>scaler, <span class="co"># Pass the fitted scaler</span></span>
<span id="cb4-158"><a href="#cb4-158" aria-hidden="true" tabindex="-1"></a>        dictionary_A<span class="op">=</span>current_dictionary_A,</span>
<span id="cb4-159"><a href="#cb4-159" aria-hidden="true" tabindex="-1"></a>        T<span class="op">=</span>T,</span>
<span id="cb4-160"><a href="#cb4-160" aria-hidden="true" tabindex="-1"></a>        q<span class="op">=</span>BATCH_SIZE_q,</span>
<span id="cb4-161"><a href="#cb4-161" aria-hidden="true" tabindex="-1"></a>        num_candidates<span class="op">=</span>NUM_CANDIDATES_Acqf,</span>
<span id="cb4-162"><a href="#cb4-162" aria-hidden="true" tabindex="-1"></a>        acquisition_func<span class="op">=</span>ACQUISITION_FUNCTION,</span>
<span id="cb4-163"><a href="#cb4-163" aria-hidden="true" tabindex="-1"></a>        <span class="op">**</span>acqf_params</span>
<span id="cb4-164"><a href="#cb4-164" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-165"><a href="#cb4-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-166"><a href="#cb4-166" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Selected </span><span class="sc">{</span>next_U_candidates_np<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> candidate(s)."</span>)</span>
<span id="cb4-167"><a href="#cb4-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-168"><a href="#cb4-168" aria-hidden="true" tabindex="-1"></a>    <span class="co"># g. Evaluate Objective for the selected candidate(s) &amp; Update Kappa if needed</span></span>
<span id="cb4-169"><a href="#cb4-169" aria-hidden="true" tabindex="-1"></a>    newly_evaluated_U <span class="op">=</span> []</span>
<span id="cb4-170"><a href="#cb4-170" aria-hidden="true" tabindex="-1"></a>    newly_evaluated_f <span class="op">=</span> []</span>
<span id="cb4-171"><a href="#cb4-171" aria-hidden="true" tabindex="-1"></a>    newly_evaluated_neg_f <span class="op">=</span> []</span>
<span id="cb4-172"><a href="#cb4-172" aria-hidden="true" tabindex="-1"></a>    improvement_found_in_batch <span class="op">=</span> <span class="va">False</span></span>
<span id="cb4-173"><a href="#cb4-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-174"><a href="#cb4-174" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> next_U_candidates_np.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-175"><a href="#cb4-175" aria-hidden="true" tabindex="-1"></a>         <span class="bu">print</span>(<span class="st">"Warning: No candidates selected by acquisition function."</span>)</span>
<span id="cb4-176"><a href="#cb4-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-177"><a href="#cb4-177" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(next_U_candidates_np.shape[<span class="dv">0</span>]):</span>
<span id="cb4-178"><a href="#cb4-178" aria-hidden="true" tabindex="-1"></a>        next_U <span class="op">=</span> next_U_candidates_np[i, :]</span>
<span id="cb4-179"><a href="#cb4-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-180"><a href="#cb4-180" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if this candidate was already evaluated</span></span>
<span id="cb4-181"><a href="#cb4-181" aria-hidden="true" tabindex="-1"></a>        already_evaluated <span class="op">=</span> <span class="bu">any</span>(np.array_equal(next_U, u) <span class="cf">for</span> u <span class="kw">in</span> evaluated_U_np_list)</span>
<span id="cb4-182"><a href="#cb4-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-183"><a href="#cb4-183" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> already_evaluated:</span>
<span id="cb4-184"><a href="#cb4-184" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Candidate </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> was already evaluated. Skipping re-evaluation."</span>)</span>
<span id="cb4-185"><a href="#cb4-185" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span> <span class="co"># Skip to next candidate</span></span>
<span id="cb4-186"><a href="#cb4-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-187"><a href="#cb4-187" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Evaluate the objective</span></span>
<span id="cb4-188"><a href="#cb4-188" aria-hidden="true" tabindex="-1"></a>        next_f <span class="op">=</span> evaluate_objective(next_U, X, v_star, convolutions, d, w)</span>
<span id="cb4-189"><a href="#cb4-189" aria-hidden="true" tabindex="-1"></a>        next_neg_f <span class="op">=</span> <span class="op">-</span>next_f <span class="co"># Negate for GP maximization</span></span>
<span id="cb4-190"><a href="#cb4-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-191"><a href="#cb4-191" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate Y for printing/verification (optional)</span></span>
<span id="cb4-192"><a href="#cb4-192" aria-hidden="true" tabindex="-1"></a>        V_sum_eval <span class="op">=</span> np.<span class="bu">sum</span>(v_star[next_U <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-193"><a href="#cb4-193" aria-hidden="true" tabindex="-1"></a>        Y_eval <span class="op">=</span> X <span class="op">+</span> V_sum_eval</span>
<span id="cb4-194"><a href="#cb4-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-195"><a href="#cb4-195" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Candidate </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Y=</span><span class="sc">{</span>Y_eval<span class="sc">.</span>astype(<span class="bu">int</span>)<span class="sc">}</span><span class="ss">, Obj = </span><span class="sc">{</span>next_f<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb4-196"><a href="#cb4-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-197"><a href="#cb4-197" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add to temporary lists for this iteration</span></span>
<span id="cb4-198"><a href="#cb4-198" aria-hidden="true" tabindex="-1"></a>        newly_evaluated_U.append(next_U)</span>
<span id="cb4-199"><a href="#cb4-199" aria-hidden="true" tabindex="-1"></a>        newly_evaluated_f.append(next_f)</span>
<span id="cb4-200"><a href="#cb4-200" aria-hidden="true" tabindex="-1"></a>        newly_evaluated_neg_f.append(next_neg_f) <span class="co"># Store negative value</span></span>
<span id="cb4-201"><a href="#cb4-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-202"><a href="#cb4-202" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update overall best objective found AND KAPPA if improved (for LCB-IK)</span></span>
<span id="cb4-203"><a href="#cb4-203" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> next_f <span class="op">&lt;</span> best_obj_so_far:</span>
<span id="cb4-204"><a href="#cb4-204" aria-hidden="true" tabindex="-1"></a>             <span class="bu">print</span>(<span class="ss">f"  ** Improvement found! Old best: </span><span class="sc">{</span>best_obj_so_far<span class="sc">:.4f}</span><span class="ss">, New best: </span><span class="sc">{</span>next_f<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb4-205"><a href="#cb4-205" aria-hidden="true" tabindex="-1"></a>             best_obj_so_far <span class="op">=</span> next_f</span>
<span id="cb4-206"><a href="#cb4-206" aria-hidden="true" tabindex="-1"></a>             <span class="co"># If using LCB-IK, increase Kappa</span></span>
<span id="cb4-207"><a href="#cb4-207" aria-hidden="true" tabindex="-1"></a>             <span class="cf">if</span> ACQUISITION_FUNCTION <span class="op">==</span> <span class="st">'LCB'</span> <span class="kw">and</span> KAPPA_INCREASE_FACTOR <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb4-208"><a href="#cb4-208" aria-hidden="true" tabindex="-1"></a>                 old_kappa <span class="op">=</span> current_kappa</span>
<span id="cb4-209"><a href="#cb4-209" aria-hidden="true" tabindex="-1"></a>                 current_kappa <span class="op">*=</span> KAPPA_INCREASE_FACTOR</span>
<span id="cb4-210"><a href="#cb4-210" aria-hidden="true" tabindex="-1"></a>                 <span class="co"># Optional: Cap Kappa</span></span>
<span id="cb4-211"><a href="#cb4-211" aria-hidden="true" tabindex="-1"></a>                 <span class="co"># current_kappa = min(current_kappa, MAX_KAPPA)</span></span>
<span id="cb4-212"><a href="#cb4-212" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="ss">f"  ** Increasing Kappa from </span><span class="sc">{</span>old_kappa<span class="sc">:.3f}</span><span class="ss"> to </span><span class="sc">{</span>current_kappa<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb4-213"><a href="#cb4-213" aria-hidden="true" tabindex="-1"></a>                 improvement_found_in_batch <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-214"><a href="#cb4-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-215"><a href="#cb4-215" aria-hidden="true" tabindex="-1"></a>    <span class="co"># h. Augment Dataset for next iteration</span></span>
<span id="cb4-216"><a href="#cb4-216" aria-hidden="true" tabindex="-1"></a>    evaluated_U_np_list.extend(newly_evaluated_U)</span>
<span id="cb4-217"><a href="#cb4-217" aria-hidden="true" tabindex="-1"></a>    evaluated_f_vals.extend(newly_evaluated_f)</span>
<span id="cb4-218"><a href="#cb4-218" aria-hidden="true" tabindex="-1"></a>    train_Y_list.extend(newly_evaluated_neg_f) <span class="co"># Add negative values for next GP fit</span></span>
<span id="cb4-219"><a href="#cb4-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-220"><a href="#cb4-220" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reporting</span></span>
<span id="cb4-221"><a href="#cb4-221" aria-hidden="true" tabindex="-1"></a>    iter_time <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="cb4-222"><a href="#cb4-222" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best objective value found so far: </span><span class="sc">{</span>best_obj_so_far<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb4-223"><a href="#cb4-223" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total points evaluated: </span><span class="sc">{</span><span class="bu">len</span>(evaluated_f_vals)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-224"><a href="#cb4-224" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ACQUISITION_FUNCTION <span class="op">==</span> <span class="st">'LCB'</span> <span class="kw">and</span> KAPPA_INCREASE_FACTOR <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb4-225"><a href="#cb4-225" aria-hidden="true" tabindex="-1"></a>         <span class="bu">print</span>(<span class="ss">f"Kappa for next iteration: </span><span class="sc">{</span>current_kappa<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb4-226"><a href="#cb4-226" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Iteration </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> completed in </span><span class="sc">{</span>iter_time<span class="sc">:.2f}</span><span class="ss"> seconds."</span>)</span>
<span id="cb4-227"><a href="#cb4-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-228"><a href="#cb4-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-229"><a href="#cb4-229" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Results Reporting and Verification</span></span>
<span id="cb4-230"><a href="#cb4-230" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Optimization Finished ---"</span>)</span>
<span id="cb4-231"><a href="#cb4-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-232"><a href="#cb4-232" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> evaluated_f_vals:</span>
<span id="cb4-233"><a href="#cb4-233" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"No points were successfully evaluated."</span>)</span>
<span id="cb4-234"><a href="#cb4-234" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb4-235"><a href="#cb4-235" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the best point among all evaluated points</span></span>
<span id="cb4-236"><a href="#cb4-236" aria-hidden="true" tabindex="-1"></a>    valid_indices <span class="op">=</span> [i <span class="cf">for</span> i, f <span class="kw">in</span> <span class="bu">enumerate</span>(evaluated_f_vals) <span class="cf">if</span> f <span class="op">&lt;</span> LARGE_PENALTY]</span>
<span id="cb4-237"><a href="#cb4-237" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> valid_indices:</span>
<span id="cb4-238"><a href="#cb4-238" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No feasible points were found during the optimization."</span>)</span>
<span id="cb4-239"><a href="#cb4-239" aria-hidden="true" tabindex="-1"></a>        final_best_f <span class="op">=</span> <span class="bu">min</span>(evaluated_f_vals) <span class="co"># Report the penalty value</span></span>
<span id="cb4-240"><a href="#cb4-240" aria-hidden="true" tabindex="-1"></a>        final_best_idx_in_all <span class="op">=</span> np.argmin(evaluated_f_vals)</span>
<span id="cb4-241"><a href="#cb4-241" aria-hidden="true" tabindex="-1"></a>        final_best_U <span class="op">=</span> evaluated_U_np_list[final_best_idx_in_all]</span>
<span id="cb4-242"><a href="#cb4-242" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Best Objective Value Found (Penalty): </span><span class="sc">{</span>final_best_f<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-243"><a href="#cb4-243" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Corresponding U vector: </span><span class="sc">{</span>final_best_U<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-244"><a href="#cb4-244" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-245"><a href="#cb4-245" aria-hidden="true" tabindex="-1"></a>        evaluated_f_vals_valid <span class="op">=</span> np.array(evaluated_f_vals)[valid_indices]</span>
<span id="cb4-246"><a href="#cb4-246" aria-hidden="true" tabindex="-1"></a>        evaluated_U_np_list_valid <span class="op">=</span> [evaluated_U_np_list[i] <span class="cf">for</span> i <span class="kw">in</span> valid_indices]</span>
<span id="cb4-247"><a href="#cb4-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-248"><a href="#cb4-248" aria-hidden="true" tabindex="-1"></a>        final_best_idx_in_valid <span class="op">=</span> np.argmin(evaluated_f_vals_valid) <span class="co"># Index within valid points</span></span>
<span id="cb4-249"><a href="#cb4-249" aria-hidden="true" tabindex="-1"></a>        final_best_U <span class="op">=</span> evaluated_U_np_list_valid[final_best_idx_in_valid]</span>
<span id="cb4-250"><a href="#cb4-250" aria-hidden="true" tabindex="-1"></a>        final_best_f <span class="op">=</span> evaluated_f_vals_valid[final_best_idx_in_valid]</span>
<span id="cb4-251"><a href="#cb4-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-252"><a href="#cb4-252" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Total evaluations: </span><span class="sc">{</span><span class="bu">len</span>(evaluated_f_vals)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-253"><a href="#cb4-253" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Best Feasible Objective Value Found: </span><span class="sc">{</span>final_best_f<span class="sc">:.8f}</span><span class="ss">"</span>) <span class="co"># More precision</span></span>
<span id="cb4-254"><a href="#cb4-254" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ensure U is printed correctly if it's long</span></span>
<span id="cb4-255"><a href="#cb4-255" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Best U vector Found: </span><span class="sc">{</span><span class="st">''</span><span class="sc">.</span>join(<span class="bu">map</span>(<span class="bu">str</span>, final_best_U))<span class="sc">}</span><span class="ss">"</span>) <span class="co"># Print as string</span></span>
<span id="cb4-256"><a href="#cb4-256" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"Best U vector Found (Indices of 1s): {np.where(final_best_U == 1)[0]}") # Alternative print</span></span>
<span id="cb4-257"><a href="#cb4-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-258"><a href="#cb4-258" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Verification: Recalculate Y and objective for the best U found</span></span>
<span id="cb4-259"><a href="#cb4-259" aria-hidden="true" tabindex="-1"></a>        V_sum_best <span class="op">=</span> np.<span class="bu">sum</span>(v_star[final_best_U <span class="op">==</span> <span class="dv">1</span>, :], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-260"><a href="#cb4-260" aria-hidden="true" tabindex="-1"></a>        Y_best <span class="op">=</span> X <span class="op">+</span> V_sum_best</span>
<span id="cb4-261"><a href="#cb4-261" aria-hidden="true" tabindex="-1"></a>        is_feasible <span class="op">=</span> np.<span class="bu">all</span>(Y_best <span class="op">&gt;=</span> <span class="dv">0</span>)</span>
<span id="cb4-262"><a href="#cb4-262" aria-hidden="true" tabindex="-1"></a>        recalculated_obj <span class="op">=</span> LARGE_PENALTY <span class="co"># Default to penalty</span></span>
<span id="cb4-263"><a href="#cb4-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-264"><a href="#cb4-264" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Verification ---"</span>)</span>
<span id="cb4-265"><a href="#cb4-265" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Is the best U feasible? </span><span class="sc">{</span>is_feasible<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-266"><a href="#cb4-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-267"><a href="#cb4-267" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_feasible:</span>
<span id="cb4-268"><a href="#cb4-268" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb4-269"><a href="#cb4-269" aria-hidden="true" tabindex="-1"></a>                Y_best_int <span class="op">=</span> Y_best.astype(<span class="bu">int</span>)</span>
<span id="cb4-270"><a href="#cb4-270" aria-hidden="true" tabindex="-1"></a>                ewt, esp <span class="op">=</span> calculate_objective_serv_time_lookup(Y_best_int, d, convolutions)</span>
<span id="cb4-271"><a href="#cb4-271" aria-hidden="true" tabindex="-1"></a>                recalculated_obj <span class="op">=</span> w <span class="op">*</span> ewt <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> esp</span>
<span id="cb4-272"><a href="#cb4-272" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Resulting Y vector for best U: </span><span class="sc">{</span>Y_best_int<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-273"><a href="#cb4-273" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Objective value (recalculated): </span><span class="sc">{</span>recalculated_obj<span class="sc">:.8f}</span><span class="ss">"</span>) <span class="co"># More precision</span></span>
<span id="cb4-274"><a href="#cb4-274" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> np.isclose(final_best_f, recalculated_obj, atol<span class="op">=</span><span class="fl">1e-6</span>): <span class="co"># Use tolerance</span></span>
<span id="cb4-275"><a href="#cb4-275" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Warning: Stored best objective (</span><span class="sc">{</span>final_best_f<span class="sc">}</span><span class="ss">) does not closely match recalculated (</span><span class="sc">{</span>recalculated_obj<span class="sc">}</span><span class="ss">)."</span>)</span>
<span id="cb4-276"><a href="#cb4-276" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb4-277"><a href="#cb4-277" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">"Recalculated objective matches stored value."</span>)</span>
<span id="cb4-278"><a href="#cb4-278" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb4-279"><a href="#cb4-279" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="ss">f"Error recalculating objective for verification: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-280"><a href="#cb4-280" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">print</span>(<span class="ss">f"Best Y vector was: </span><span class="sc">{</span>Y_best<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-281"><a href="#cb4-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-282"><a href="#cb4-282" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb4-283"><a href="#cb4-283" aria-hidden="true" tabindex="-1"></a>            <span class="co"># This case should ideally not happen if we selected from valid points</span></span>
<span id="cb4-284"><a href="#cb4-284" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Resulting Y vector (infeasible): </span><span class="sc">{</span>Y_best<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-285"><a href="#cb4-285" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Warning: The identified best U vector leads to an infeasible Y upon recalculation."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The experiment was run three times, varying the acquisition function. The key results are summarized below:</p>
<ul>
<li><strong>Run 1: Expected Improvement (EI)</strong>
<ul>
<li>Initial Best Objective: 47.9991</li>
<li>Final Best Objective Found: <strong>47.0549</strong></li>
<li>Best U Vector Found: <code>0011101101110111</code></li>
<li>Resulting Y Vector: <code>[2 1 1 1 0 1 1 0 1 1 1 0 1 1 3]</code> (Feasible)</li>
<li>Total Evaluations: 120</li>
<li>Observations: Found improvements steadily, particularly in early iterations (iter 4, 8, 9). Many later iterations proposed candidates that were already evaluated or did not improve the objective. Several infeasible candidates (penalty value) were proposed throughout.</li>
</ul></li>
<li><strong>Run 2: Lower Confidence Bound (LCB, fixed</strong> <span class="math inline">\(\kappa=2.576\)</span>)
<ul>
<li>Initial Best Objective: 48.0272</li>
<li>Final Best Objective Found: <strong>47.2109</strong></li>
<li>Best U Vector Found: <code>0011000001110111</code></li>
<li>Resulting Y Vector: <code>[2 1 1 0 1 0 1 1 1 1 1 0 1 1 3]</code> (Feasible)</li>
<li>Total Evaluations: 117 (some duplicates skipped)</li>
<li>Observations: Found improvements in iterations 6 and 9. Showed a tendency to explore, proposing many infeasible points or points that didn’t improve the best found value, especially in later iterations.</li>
</ul></li>
<li><strong>Run 3: LCB with Increasing Kappa (LCB-IK,</strong> <span class="math inline">\(\kappa_{start}=3.75, \text{factor}=1.3\)</span>)
<ul>
<li>Initial Best Objective: 47.4702</li>
<li>Final Best Objective Found: <strong>46.9551</strong></li>
<li>Best U Vector Found: <code>0011001001100111</code></li>
<li>Resulting Y Vector: <code>[2 1 1 0 1 1 0 1 1 1 0 1 1 1 3]</code> (Feasible)</li>
<li>Total Evaluations: 105 (several duplicates skipped)</li>
<li>Observations: Found improvements in iterations 7 (Kappa increased to 4.875) and 15 (Kappa increased to 6.338). The increasing kappa seemed to encourage finding better solutions later in the search compared to fixed LCB. Still proposed many non-improving or infeasible points. This variant achieved the lowest objective value among the three runs.</li>
</ul></li>
</ul>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>The experiment successfully applied Bayesian Optimization with Hamming Embedding via Dictionaries (HED) to the high-dimensional combinatorial scheduling problem. All three acquisition function variants (EI, LCB, LCB-IK) were able to find feasible solutions significantly better than the initial random points, demonstrating the effectiveness of the HED approach combined with BO for this problem type.</p>
<ul>
<li><strong>Comparison of Acquisition Functions:</strong>
<ul>
<li>LCB with Increasing Kappa (LCB-IK) achieved the best final objective value (46.9551), suggesting that dynamically increasing the exploration parameter (<span class="math inline">\(\kappa\)</span>) upon finding improvements helped escape local optima or explore more effectively later in the search process.</li>
<li>Expected Improvement (EI) found a good solution (47.0549) relatively quickly but seemed to stagnate more in later iterations compared to LCB-IK.</li>
<li>LCB with a fixed kappa found the worst solution among the three (47.2109), potentially indicating that the fixed exploration level was not optimal throughout the search.</li>
</ul></li>
<li><strong>HED Effectiveness:</strong> The ability of the GP model, built upon the HED embedding, to guide the search towards better solutions despite the <span class="math inline">\(2^{16}\)</span> (T=16 in LCB/LCB-IK runs) or <span class="math inline">\(2^{15}\)</span> (T=15 in EI run) size of the search space highlights the utility of the dictionary-based embedding for capturing relevant structure in the combinatorial space, as suggested by Deshwal et al.&nbsp;(2023). The use of ARD within the GP kernel likely helped focus on the more relevant dimensions of the embedding.</li>
<li><strong>Challenges:</strong> All methods frequently proposed candidate solutions that were either infeasible (resulting in the <code>LARGE_PENALTY</code>) or duplicates of previously evaluated points. This indicates the difficulty of optimizing the acquisition function effectively in this discrete space, even with the embedding. The random sampling approach within <code>optimize_acqf_discrete_via_embedding</code> might benefit from more sophisticated search strategies.</li>
<li><strong>Feasibility:</strong> The verification step confirmed that the best <span class="math inline">\(U\)</span> vectors found by each method corresponded to feasible schedules <span class="math inline">\(Y_{best}\)</span> and that the recalculated objective values matched the stored best values, validating the results.</li>
</ul>
<p>In conclusion, the HED-based Bayesian Optimization approach proved effective for this scheduling problem. The LCB acquisition function with an adaptive exploration parameter (LCB-IK) demonstrated the best performance in finding the lowest objective value within the given evaluation budget.</p>
</section>
<section id="timeline" class="level2">
<h2 class="anchored" data-anchor-id="timeline">Timeline</h2>
<ul>
<li><strong>Experiment Start Date:</strong> [Specify Date]</li>
<li><strong>Experiment End Date:</strong> [Specify Date]</li>
<li><strong>Analysis Date:</strong> 2025-05-05</li>
</ul>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li>Deshwal, A., Ament, S., Balandat, M., Bakshy, E., Doppa, J. R., Eriksson, D. (2023). Bayesian Optimization over High-Dimensional Combinatorial Spaces via Dictionary-based Embeddings. <em>Proceedings of the 26th International Conference on Artificial Intelligence and Statistics (AISTATS)</em>, PMLR 206.</li>
<li>[Add citation for source of EWT/ESP functions or scheduling problem, if applicable]</li>
<li>[Add citation for Gaussian Process library, e.g., Scikit-learn, GPyTorch/BoTorch if used]</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>