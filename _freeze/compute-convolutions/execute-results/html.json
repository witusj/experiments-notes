{
  "hash": "97d992098b257a1d3428a85be8911fc7",
  "result": {
    "engine": "jupyter",
    "markdown": "# `compute_convolutions` {.unnumbered}\n\nThis notebook provides documentation for the function `compute_convolutions`, which computes the k-fold convolution of a probability mass function (PMF) for k in the range 1 to N. The function is generic and can be applied to any PMF, not only those representing service times. Additionally, the function adjusts the PMF for no-shows using the `service_time_with_no_shows` function.\n\n## Function Documentation\n\n`compute_convolutions(probabilities: List[float], N: int, q: float = 0.0) -> Dict[int, np.ndarray]`\n\n#### Description\n\nComputes the k-fold convolution of a given probability mass function (PMF) for k from 1 up to N. Before computing the convolutions, the PMF is adjusted for no-shows using the provided no-show probability `q` via the `service_time_with_no_shows` function. Convolution is performed using NumPy's `np.convolve`.\n\n#### Parameters\n\n- **probabilities** (`List[float]`): The original PMF represented as a list where the index corresponds to a value (for instance, a service time) and the value at that index is its probability. This function is generic and does not have to be used solely for service times.\n- **N** (`int`): The maximum number of convolutions to compute.\n- **q** (`float`, optional): The probability of a no-show. Defaults to `0.0`.\n\n#### Returns\n\n- **`Dict[int, np.ndarray]`**: A dictionary where each key `k` (with 1 ≤ k ≤ N) corresponds to the PMF resulting from the k-fold convolution of the adjusted PMF.\n\n#### Example\n\n::: {#d44d4eb0 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom functions import compute_convolutions, service_time_with_no_shows\n\n# Example usage\noriginal_pmf = [0.0, 0.5, 0.3, 0.2]\nN = 3\nno_show_probability = 0.1\n\nconvs = compute_convolutions(original_pmf, N, no_show_probability)\nfor k, pmf in convs.items():\n    print(f\"{k}-fold convolution: {pmf}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1-fold convolution: [0.1  0.45 0.27 0.18]\n2-fold convolution: [0.01   0.09   0.2565 0.279  0.2349 0.0972 0.0324]\n3-fold convolution: [0.001    0.0135   0.06885  0.169425 0.234495 0.236925 0.160623 0.083106\n 0.026244 0.005832]\n```\n:::\n:::\n\n\n::: {#976f3aec .cell execution_count=2}\n``` {.python .cell-code}\nimport unittest\n\nclass TestComputeConvolutions(unittest.TestCase):\n    def test_single_convolution(self):\n        # When N = 1, the result should be the adjusted PMF\n        original_pmf = [0.0, 0.5, 0.3, 0.2]\n        no_show_probability = 0.1\n        N = 1\n        expected = np.array(service_time_with_no_shows(original_pmf, no_show_probability))\n        result = compute_convolutions(original_pmf, N, no_show_probability)\n        self.assertTrue(np.allclose(result[1], expected), \"Single convolution test failed\")\n\n    def test_multiple_convolutions(self):\n        # Test for N = 3 using a simple PMF\n        original_pmf = [0.0, 0.5, 0.3, 0.2]\n        no_show_probability = 0.0  # No adjustment for simplicity\n        N = 3\n        result = compute_convolutions(original_pmf, N, no_show_probability)\n\n        # For N=1, result is the original pmf\n        self.assertTrue(np.allclose(result[1], np.array(original_pmf)))\n\n        # For higher convolutions, ensure the sum of probabilities remains 1 (within numerical precision)\n        for k in range(1, N + 1):\n            self.assertAlmostEqual(np.sum(result[k]), 1.0, places=5, msg=f\"Sum of probabilities for {k}-fold convolution is not 1\")\n\nif __name__ == '__main__':\n    unittest.main(argv=[''], exit=False)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n..\n----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nOK\n```\n:::\n:::\n\n\n",
    "supporting": [
      "compute-convolutions_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}