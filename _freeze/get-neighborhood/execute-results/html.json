{
  "hash": "ec60d917c6e6f45d6ef600df3c75efbb",
  "result": {
    "engine": "jupyter",
    "markdown": "# `get_neighborhood` {.unnumbered}\n\nThis notebook provides documentation for the function `get_neighborhood`, which generates the neighborhood of a solution vector by adding combinations of adjustment vectors from a precomputed array (`v_star`). The function filters out any candidate neighbors that result in negative values.\n\n## Function Documentation\n\n`get_neighborhood(x: Union[List[int], np.ndarray], v_star: np.ndarray, ids: List[List[int]], verbose: bool = False) -> np.ndarray`\n\n#### Description\n\nThe `get_neighborhood` function computes a set of neighbor solutions by adding together selected rows from the array `v_star` to an initial solution vector `x`. The selection of rows is determined by the list of index lists `ids`, where each inner list represents a combination of indices. After generating the candidate neighbors, the function filters out any that contain negative values. An optional `verbose` flag provides debugging output during execution.\n\n#### Parameters\n\n- **x** (`Union[List[int], np.ndarray]`):  \n  The current solution vector. Can be provided as a list of integers or as a NumPy array.\n\n- **v_star** (`np.ndarray`):  \n  A 2D NumPy array where each row is an adjustment vector. These vectors are used to modify the current solution to explore its neighborhood.\n\n- **ids** (`List[List[int]]`):  \n  A list of index lists, where each inner list specifies which rows from `v_star` to sum together. Each combination represents a potential adjustment to the current solution.\n\n- **verbose** (`bool`, optional):  \n  A flag indicating whether to print debugging information (e.g., intermediate computations, progress messages). Defaults to `False`.\n\n#### Returns\n\n- **`np.ndarray`**:  \n  A 2D NumPy array where each row is a neighbor solution (i.e., the result of adding a valid combination of adjustment vectors from `v_star` to `x`). Only neighbors with all non-negative entries are included in the output.\n\n#### Example\n\n::: {#2c507463 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom functions import get_neighborhood, get_v_star, powerset\n\n# Define an initial solution vector\nx = [3, 2, 1]\n\n# Generate adjustment vectors using get_v_star\n# For instance, create a set of cyclic adjustment vectors of length 3\nv_star = get_v_star(3)\n\n# Generate combinations of indices (e.g., using a powerset for switching 1 patient)\nids = powerset(range(3), size=1)\n\n# Generate the neighborhood (neighbors with non-negative entries only)\nneighbors = get_neighborhood(x, v_star, ids, echo=True)\nprint(\"Neighbor solutions:\")\nprint(neighbors)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrinting every 50th result\nv_star[0]: [-1  0  1]\nx, x', delta:\n[3 2 1],\n[2 2 2],\n[-1  0  1]\n-----------------\nv_star[1]: [ 1 -1  0]\nv_star[2]: [ 0  1 -1]\nSize of raw neighborhood: 3\nFiltered out: 0 schedules with negative values.\nSize of filtered neighborhood: 3\nNeighbor solutions:\n[[2 2 2]\n [4 1 1]\n [3 3 0]]\n```\n:::\n:::\n\n\n::: {#9b7a0193 .cell execution_count=2}\n``` {.python .cell-code}\nimport unittest\nimport numpy as np\nfrom functions import get_neighborhood, get_v_star, powerset\n\nclass TestGetNeighborhood(unittest.TestCase):\n    def test_non_negative_neighbors(self):\n        # Test with a simple solution vector and adjustment vectors\n        x = [3, 2, 1]\n        v_star = get_v_star(3)\n        ids = powerset(range(3), size=1)\n        \n        neighbors = get_neighborhood(x, v_star, ids, echo=False)\n        \n        # Ensure that no neighbor has negative entries\n        self.assertTrue(np.all(neighbors >= 0), \"Some neighbor solutions contain negative values\")\n    \n    def test_neighborhood_shape(self):\n        # Test that the neighborhood returns a NumPy array with the proper dimensions\n        x = [3, 2, 1]\n        v_star = get_v_star(3)\n        ids = powerset(range(3), size=1)\n        neighbors = get_neighborhood(x, v_star, ids, echo=False)\n        self.assertIsInstance(neighbors, np.ndarray, \"Neighborhood is not a NumPy array\")\n        # The number of rows should equal the number of valid combinations in ids (after filtering negatives)\n        self.assertLessEqual(neighbors.shape[0], len(ids), \"Neighborhood size is larger than expected\")\n\nif __name__ == '__main__':\n    unittest.main(argv=[''], exit=False)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n..\n----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nOK\n```\n:::\n:::\n\n\n",
    "supporting": [
      "get-neighborhood_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}